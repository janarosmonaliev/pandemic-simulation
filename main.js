!(function (e) {
  var t = {};
  function n(i) {
    if (t[i]) return t[i].exports;
    var r = (t[i] = { i: i, l: !1, exports: {} });
    return e[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
  }
  (n.m = e),
    (n.c = t),
    (n.d = function (e, t, i) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i });
    }),
    (n.r = function (e) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (n.t = function (e, t) {
      if ((1 & t && (e = n(e)), 8 & t)) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", { enumerable: !0, value: e }),
        2 & t && "string" != typeof e)
      )
        for (var r in e)
          n.d(
            i,
            r,
            function (t) {
              return e[t];
            }.bind(null, r)
          );
      return i;
    }),
    (n.n = function (e) {
      var t =
        e && e.__esModule
          ? function () {
              return e.default;
            }
          : function () {
              return e;
            };
      return n.d(t, "a", t), t;
    }),
    (n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }),
    (n.p = ""),
    n((n.s = 0));
})([
  function (e, t, n) {
    e.exports = n(1);
  },
  function (e, t, n) {
    "use strict";
    n.r(t);
    /**
     * @license
     * Copyright 2010-2021 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const i = 0,
      r = 1,
      s = 2,
      a = 0,
      o = 1,
      l = 2,
      c = 3;
    class h {
      addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
      }
      hasEventListener(e, t) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t);
      }
      removeEventListener(e, t) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[e];
        if (void 0 !== n) {
          const e = n.indexOf(t);
          -1 !== e && n.splice(e, 1);
        }
      }
      dispatchEvent(e) {
        if (void 0 === this._listeners) return;
        const t = this._listeners[e.type];
        if (void 0 !== t) {
          e.target = this;
          const n = t.slice(0);
          for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
          e.target = null;
        }
      }
    }
    const u = [];
    for (let e = 0; e < 256; e++) u[e] = (e < 16 ? "0" : "") + e.toString(16);
    let d = 1234567;
    const p = Math.PI / 180,
      m = 180 / Math.PI;
    function f() {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0;
      return (
        u[255 & e] +
        u[(e >> 8) & 255] +
        u[(e >> 16) & 255] +
        u[(e >> 24) & 255] +
        "-" +
        u[255 & t] +
        u[(t >> 8) & 255] +
        "-" +
        u[((t >> 16) & 15) | 64] +
        u[(t >> 24) & 255] +
        "-" +
        u[(63 & n) | 128] +
        u[(n >> 8) & 255] +
        "-" +
        u[(n >> 16) & 255] +
        u[(n >> 24) & 255] +
        u[255 & i] +
        u[(i >> 8) & 255] +
        u[(i >> 16) & 255] +
        u[(i >> 24) & 255]
      ).toUpperCase();
    }
    function g(e, t, n) {
      return Math.max(t, Math.min(n, e));
    }
    function v(e, t) {
      return ((e % t) + t) % t;
    }
    function _(e, t, n) {
      return (1 - n) * e + n * t;
    }
    function x(e) {
      return 0 == (e & (e - 1)) && 0 !== e;
    }
    function y(e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }
    function b(e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    }
    var w = Object.freeze({
      __proto__: null,
      DEG2RAD: p,
      RAD2DEG: m,
      generateUUID: f,
      clamp: g,
      euclideanModulo: v,
      mapLinear: function (e, t, n, i, r) {
        return i + ((e - t) * (r - i)) / (n - t);
      },
      inverseLerp: function (e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0;
      },
      lerp: _,
      damp: function (e, t, n, i) {
        return _(e, t, 1 - Math.exp(-n * i));
      },
      pingpong: function (e, t = 1) {
        return t - Math.abs(v(e, 2 * t) - t);
      },
      smoothstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
      },
      smootherstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
      },
      randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      },
      randFloat: function (e, t) {
        return e + Math.random() * (t - e);
      },
      randFloatSpread: function (e) {
        return e * (0.5 - Math.random());
      },
      seededRandom: function (e) {
        return (
          void 0 !== e && (d = e % 2147483647),
          (d = (16807 * d) % 2147483647),
          (d - 1) / 2147483646
        );
      },
      degToRad: function (e) {
        return e * p;
      },
      radToDeg: function (e) {
        return e * m;
      },
      isPowerOfTwo: x,
      ceilPowerOfTwo: y,
      floorPowerOfTwo: b,
      setQuaternionFromProperEuler: function (e, t, n, i, r) {
        const s = Math.cos,
          a = Math.sin,
          o = s(n / 2),
          l = a(n / 2),
          c = s((t + i) / 2),
          h = a((t + i) / 2),
          u = s((t - i) / 2),
          d = a((t - i) / 2),
          p = s((i - t) / 2),
          m = a((i - t) / 2);
        switch (r) {
          case "XYX":
            e.set(o * h, l * u, l * d, o * c);
            break;
          case "YZY":
            e.set(l * d, o * h, l * u, o * c);
            break;
          case "ZXZ":
            e.set(l * u, l * d, o * h, o * c);
            break;
          case "XZX":
            e.set(o * h, l * m, l * p, o * c);
            break;
          case "YXY":
            e.set(l * p, o * h, l * m, o * c);
            break;
          case "ZYZ":
            e.set(l * m, l * p, o * h, o * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                r
            );
        }
      },
    });
    class M {
      constructor(e = 0, t = 0) {
        (this.x = e), (this.y = t);
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return (this.x = e), (this.y = t), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          i = e.elements;
        return (
          (this.x = i[0] * t + i[3] * n + i[6]),
          (this.y = i[1] * t + i[4] * n + i[7]),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y;
        return t * t + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          this
        );
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          this
        );
      }
      rotateAround(e, t) {
        const n = Math.cos(t),
          i = Math.sin(t),
          r = this.x - e.x,
          s = this.y - e.y;
        return (
          (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    }
    M.prototype.isVector2 = !0;
    class S {
      constructor() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, i, r, s, a, o, l) {
        const c = this.elements;
        return (
          (c[0] = e),
          (c[1] = i),
          (c[2] = a),
          (c[3] = t),
          (c[4] = r),
          (c[5] = o),
          (c[6] = n),
          (c[7] = s),
          (c[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrix3Column(this, 0),
          t.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return (
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        );
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          i = t.elements,
          r = this.elements,
          s = n[0],
          a = n[3],
          o = n[6],
          l = n[1],
          c = n[4],
          h = n[7],
          u = n[2],
          d = n[5],
          p = n[8],
          m = i[0],
          f = i[3],
          g = i[6],
          v = i[1],
          _ = i[4],
          x = i[7],
          y = i[2],
          b = i[5],
          w = i[8];
        return (
          (r[0] = s * m + a * v + o * y),
          (r[3] = s * f + a * _ + o * b),
          (r[6] = s * g + a * x + o * w),
          (r[1] = l * m + c * v + h * y),
          (r[4] = l * f + c * _ + h * b),
          (r[7] = l * g + c * x + h * w),
          (r[2] = u * m + d * v + p * y),
          (r[5] = u * f + d * _ + p * b),
          (r[8] = u * g + d * x + p * w),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[3] *= e),
          (t[6] *= e),
          (t[1] *= e),
          (t[4] *= e),
          (t[7] *= e),
          (t[2] *= e),
          (t[5] *= e),
          (t[8] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8];
        return (
          t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8],
          h = c * s - a * l,
          u = a * o - c * r,
          d = l * r - s * o,
          p = t * h + n * u + i * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / p;
        return (
          (e[0] = h * m),
          (e[1] = (i * l - c * n) * m),
          (e[2] = (a * n - i * s) * m),
          (e[3] = u * m),
          (e[4] = (c * t - i * o) * m),
          (e[5] = (i * r - a * t) * m),
          (e[6] = d * m),
          (e[7] = (n * o - l * t) * m),
          (e[8] = (s * t - n * r) * m),
          this
        );
      }
      transpose() {
        let e;
        const t = this.elements;
        return (
          (e = t[1]),
          (t[1] = t[3]),
          (t[3] = e),
          (e = t[2]),
          (t[2] = t[6]),
          (t[6] = e),
          (e = t[5]),
          (t[5] = t[7]),
          (t[7] = e),
          this
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        const t = this.elements;
        return (
          (e[0] = t[0]),
          (e[1] = t[3]),
          (e[2] = t[6]),
          (e[3] = t[1]),
          (e[4] = t[4]),
          (e[5] = t[7]),
          (e[6] = t[2]),
          (e[7] = t[5]),
          (e[8] = t[8]),
          this
        );
      }
      setUvTransform(e, t, n, i, r, s, a) {
        const o = Math.cos(r),
          l = Math.sin(r);
        return (
          this.set(
            n * o,
            n * l,
            -n * (o * s + l * a) + s + e,
            -i * l,
            i * o,
            -i * (-l * s + o * a) + a + t,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(e, t) {
        const n = this.elements;
        return (
          (n[0] *= e),
          (n[3] *= e),
          (n[6] *= e),
          (n[1] *= t),
          (n[4] *= t),
          (n[7] *= t),
          this
        );
      }
      rotate(e) {
        const t = Math.cos(e),
          n = Math.sin(e),
          i = this.elements,
          r = i[0],
          s = i[3],
          a = i[6],
          o = i[1],
          l = i[4],
          c = i[7];
        return (
          (i[0] = t * r + n * o),
          (i[3] = t * s + n * l),
          (i[6] = t * a + n * c),
          (i[1] = -n * r + t * o),
          (i[4] = -n * s + t * l),
          (i[7] = -n * a + t * c),
          this
        );
      }
      translate(e, t) {
        const n = this.elements;
        return (
          (n[0] += e * n[2]),
          (n[3] += e * n[5]),
          (n[6] += e * n[8]),
          (n[1] += t * n[2]),
          (n[4] += t * n[5]),
          (n[7] += t * n[8]),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          e
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    function T(e) {
      if (0 === e.length) return -1 / 0;
      let t = e[0];
      for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
      return t;
    }
    S.prototype.isMatrix3 = !0;
    Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array;
    function E(e) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", e);
    }
    function A(e, t = 0) {
      let n = 3735928559 ^ t,
        i = 1103547991 ^ t;
      for (let t, r = 0; r < e.length; r++)
        (t = e.charCodeAt(r)),
          (n = Math.imul(n ^ t, 2654435761)),
          (i = Math.imul(i ^ t, 1597334677));
      return (
        (n =
          Math.imul(n ^ (n >>> 16), 2246822507) ^
          Math.imul(i ^ (i >>> 13), 3266489909)),
        (i =
          Math.imul(i ^ (i >>> 16), 2246822507) ^
          Math.imul(n ^ (n >>> 13), 3266489909)),
        4294967296 * (2097151 & i) + (n >>> 0)
      );
    }
    let L;
    class R {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          void 0 === L && (L = E("canvas")),
            (L.width = e.width),
            (L.height = e.height);
          const n = L.getContext("2d");
          e instanceof ImageData
            ? n.putImageData(e, 0, 0)
            : n.drawImage(e, 0, 0, e.width, e.height),
            (t = L);
        }
        return t.width > 2048 || t.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              e
            ),
            t.toDataURL("image/jpeg", 0.6))
          : t.toDataURL("image/png");
      }
    }
    let C = 0;
    class P extends h {
      constructor(
        e = P.DEFAULT_IMAGE,
        t = P.DEFAULT_MAPPING,
        n = 1001,
        i = 1001,
        r = 1006,
        s = 1008,
        a = 1023,
        o = 1009,
        l = 1,
        c = 3e3
      ) {
        super(),
          Object.defineProperty(this, "id", { value: C++ }),
          (this.uuid = f()),
          (this.name = ""),
          (this.image = e),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = n),
          (this.wrapT = i),
          (this.magFilter = r),
          (this.minFilter = s),
          (this.anisotropy = l),
          (this.format = a),
          (this.internalFormat = null),
          (this.type = o),
          (this.offset = new M(0, 0)),
          (this.repeat = new M(1, 1)),
          (this.center = new M(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new S()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = c),
          (this.userData = {}),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1);
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.image = e.image),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
          return e.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          const i = this.image;
          if (
            (void 0 === i.uuid && (i.uuid = f()),
            !t && void 0 === e.images[i.uuid])
          ) {
            let t;
            if (Array.isArray(i)) {
              t = [];
              for (let e = 0, n = i.length; e < n; e++)
                i[e].isDataTexture ? t.push(I(i[e].image)) : t.push(I(i[e]));
            } else t = I(i);
            e.images[i.uuid] = { uuid: i.uuid, url: t };
          }
          n.image = i.uuid;
        }
        return (
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          t || (e.textures[this.uuid] = n),
          n
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(e) {
        if (300 !== this.mapping) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case 1e3:
              e.x = e.x - Math.floor(e.x);
              break;
            case 1001:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(e.x) % 2)
                ? (e.x = Math.ceil(e.x) - e.x)
                : (e.x = e.x - Math.floor(e.x));
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case 1e3:
              e.y = e.y - Math.floor(e.y);
              break;
            case 1001:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(e.y) % 2)
                ? (e.y = Math.ceil(e.y) - e.y)
                : (e.y = e.y - Math.floor(e.y));
          }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }
    function I(e) {
      return ("undefined" != typeof HTMLImageElement &&
        e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
        ? R.getDataURL(e)
        : e.data
        ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    (P.DEFAULT_IMAGE = void 0),
      (P.DEFAULT_MAPPING = 300),
      (P.prototype.isTexture = !0);
    class D {
      constructor(e = 0, t = 0, n = 0, i = 1) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = i);
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, n, i) {
        return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setW(e) {
        return (this.w = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return (
          (this.x = e.x),
          (this.y = e.y),
          (this.z = e.z),
          (this.w = void 0 !== e.w ? e.w : 1),
          this
        );
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x),
          (this.y = e.y + t.y),
          (this.z = e.z + t.z),
          (this.w = e.w + t.w),
          this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t),
          (this.y += e.y * t),
          (this.z += e.z * t),
          (this.w += e.w * t),
          this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x),
          (this.y = e.y - t.y),
          (this.z = e.z - t.z),
          (this.w = e.w - t.w),
          this
        );
      }
      multiply(e) {
        return (
          (this.x *= e.x),
          (this.y *= e.y),
          (this.z *= e.z),
          (this.w *= e.w),
          this
        );
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
          (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
          (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
          (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
          this
        );
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
          t < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(e) {
        let t, n, i, r;
        const s = e.elements,
          a = s[0],
          o = s[4],
          l = s[8],
          c = s[1],
          h = s[5],
          u = s[9],
          d = s[2],
          p = s[6],
          m = s[10];
        if (
          Math.abs(o - c) < 0.01 &&
          Math.abs(l - d) < 0.01 &&
          Math.abs(u - p) < 0.01
        ) {
          if (
            Math.abs(o + c) < 0.1 &&
            Math.abs(l + d) < 0.1 &&
            Math.abs(u + p) < 0.1 &&
            Math.abs(a + h + m - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const e = (a + 1) / 2,
            s = (h + 1) / 2,
            f = (m + 1) / 2,
            g = (o + c) / 4,
            v = (l + d) / 4,
            _ = (u + p) / 4;
          return (
            e > s && e > f
              ? e < 0.01
                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                : ((n = Math.sqrt(e)), (i = g / n), (r = v / n))
              : s > f
              ? s < 0.01
                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                : ((i = Math.sqrt(s)), (n = g / i), (r = _ / i))
              : f < 0.01
              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
              : ((r = Math.sqrt(f)), (n = v / r), (i = _ / r)),
            this.set(n, i, r, t),
            this
          );
        }
        let f = Math.sqrt(
          (p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o)
        );
        return (
          Math.abs(f) < 0.001 && (f = 1),
          (this.x = (p - u) / f),
          (this.y = (l - d) / f),
          (this.z = (c - o) / f),
          (this.w = Math.acos((a + h + m - 1) / 2)),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          (this.w = Math.min(this.w, e.w)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          (this.w = Math.max(this.w, e.w)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          (this.w = Math.max(e.w, Math.min(t.w, this.w))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          (this.w = Math.max(e, Math.min(t, this.w))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          (this.w += (e.w - this.w) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          (this.w = e.w + (t.w - e.w) * n),
          this
        );
      }
      equals(e) {
        return (
          e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this.x = e[t]),
          (this.y = e[t + 1]),
          (this.z = e[t + 2]),
          (this.w = e[t + 3]),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this.x),
          (e[t + 1] = this.y),
          (e[t + 2] = this.z),
          (e[t + 3] = this.w),
          e
        );
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          (this.w = e.getW(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    }
    D.prototype.isVector4 = !0;
    class N extends h {
      constructor(e, t, n = {}) {
        super(),
          (this.width = e),
          (this.height = t),
          (this.depth = 1),
          (this.scissor = new D(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new D(0, 0, e, t)),
          (this.texture = new P(
            void 0,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.image = { width: e, height: t, depth: 1 }),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.internalFormat =
            void 0 !== n.internalFormat ? n.internalFormat : null),
          (this.texture.minFilter =
            void 0 !== n.minFilter ? n.minFilter : 1006),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      setTexture(e) {
        (e.image = {
          width: this.width,
          height: this.height,
          depth: this.depth,
        }),
          (this.texture = e);
      }
      setSize(e, t, n = 1) {
        (this.width === e && this.height === t && this.depth === n) ||
          ((this.width = e),
          (this.height = t),
          (this.depth = n),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = n),
          this.dispose()),
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.copy(e.viewport),
          (this.texture = e.texture.clone()),
          (this.texture.image = { ...this.texture.image }),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          (this.depthTexture = e.depthTexture),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    N.prototype.isWebGLRenderTarget = !0;
    (class extends N {
      constructor(e, t, n) {
        super(e, t);
        const i = this.texture;
        this.texture = [];
        for (let e = 0; e < n; e++) this.texture[e] = i.clone();
      }
      setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
          (this.width = e), (this.height = t), (this.depth = n);
          for (let i = 0, r = this.texture.length; i < r; i++)
            (this.texture[i].image.width = e),
              (this.texture[i].image.height = t),
              (this.texture[i].image.depth = n);
          this.dispose();
        }
        return (
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
        );
      }
      copy(e) {
        this.dispose(),
          (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.set(0, 0, this.width, this.height),
          this.scissor.set(0, 0, this.width, this.height),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          (this.depthTexture = e.depthTexture),
          (this.texture.length = 0);
        for (let t = 0, n = e.texture.length; t < n; t++)
          this.texture[t] = e.texture[t].clone();
        return this;
      }
    }.prototype.isWebGLMultipleRenderTargets = !0);
    class O extends N {
      constructor(e, t, n = {}) {
        super(e, t, n),
          (this.samples = 4),
          (this.ignoreDepthForMultisampleCopy =
            void 0 === n.ignoreDepth || n.ignoreDepth),
          (this.useRenderToTexture =
            void 0 !== n.useRenderToTexture && n.useRenderToTexture),
          (this.useRenderbuffer = !1 === this.useRenderToTexture);
      }
      copy(e) {
        return (
          super.copy.call(this, e),
          (this.samples = e.samples),
          (this.useRenderToTexture = e.useRenderToTexture),
          (this.useRenderbuffer = e.useRenderbuffer),
          this
        );
      }
    }
    O.prototype.isWebGLMultisampleRenderTarget = !0;
    class z {
      constructor(e = 0, t = 0, n = 0, i = 1) {
        (this._x = e), (this._y = t), (this._z = n), (this._w = i);
      }
      static slerp(e, t, n, i) {
        return (
          console.warn(
            "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
          ),
          n.slerpQuaternions(e, t, i)
        );
      }
      static slerpFlat(e, t, n, i, r, s, a) {
        let o = n[i + 0],
          l = n[i + 1],
          c = n[i + 2],
          h = n[i + 3];
        const u = r[s + 0],
          d = r[s + 1],
          p = r[s + 2],
          m = r[s + 3];
        if (0 === a)
          return (
            (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = c), void (e[t + 3] = h)
          );
        if (1 === a)
          return (
            (e[t + 0] = u), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = m)
          );
        if (h !== m || o !== u || l !== d || c !== p) {
          let e = 1 - a;
          const t = o * u + l * d + c * p + h * m,
            n = t >= 0 ? 1 : -1,
            i = 1 - t * t;
          if (i > Number.EPSILON) {
            const r = Math.sqrt(i),
              s = Math.atan2(r, t * n);
            (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
          }
          const r = a * n;
          if (
            ((o = o * e + u * r),
            (l = l * e + d * r),
            (c = c * e + p * r),
            (h = h * e + m * r),
            e === 1 - a)
          ) {
            const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
            (o *= e), (l *= e), (c *= e), (h *= e);
          }
        }
        (e[t] = o), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = h);
      }
      static multiplyQuaternionsFlat(e, t, n, i, r, s) {
        const a = n[i],
          o = n[i + 1],
          l = n[i + 2],
          c = n[i + 3],
          h = r[s],
          u = r[s + 1],
          d = r[s + 2],
          p = r[s + 3];
        return (
          (e[t] = a * p + c * h + o * d - l * u),
          (e[t + 1] = o * p + c * u + l * h - a * d),
          (e[t + 2] = l * p + c * d + a * u - o * h),
          (e[t + 3] = c * p - a * h - o * u - l * d),
          e
        );
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        (this._w = e), this._onChangeCallback();
      }
      set(e, t, n, i) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._w = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return (
          (this._x = e.x),
          (this._y = e.y),
          (this._z = e.z),
          (this._w = e.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(e, t) {
        if (!e || !e.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
          );
        const n = e._x,
          i = e._y,
          r = e._z,
          s = e._order,
          a = Math.cos,
          o = Math.sin,
          l = a(n / 2),
          c = a(i / 2),
          h = a(r / 2),
          u = o(n / 2),
          d = o(i / 2),
          p = o(r / 2);
        switch (s) {
          case "XYZ":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "YXZ":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          case "ZXY":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "ZYX":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          case "YZX":
            (this._x = u * c * h + l * d * p),
              (this._y = l * d * h + u * c * p),
              (this._z = l * c * p - u * d * h),
              (this._w = l * c * h - u * d * p);
            break;
          case "XZY":
            (this._x = u * c * h - l * d * p),
              (this._y = l * d * h - u * c * p),
              (this._z = l * c * p + u * d * h),
              (this._w = l * c * h + u * d * p);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                s
            );
        }
        return !1 !== t && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        const n = t / 2,
          i = Math.sin(n);
        return (
          (this._x = e.x * i),
          (this._y = e.y * i),
          (this._z = e.z * i),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e) {
        const t = e.elements,
          n = t[0],
          i = t[4],
          r = t[8],
          s = t[1],
          a = t[5],
          o = t[9],
          l = t[2],
          c = t[6],
          h = t[10],
          u = n + a + h;
        if (u > 0) {
          const e = 0.5 / Math.sqrt(u + 1);
          (this._w = 0.25 / e),
            (this._x = (c - o) * e),
            (this._y = (r - l) * e),
            (this._z = (s - i) * e);
        } else if (n > a && n > h) {
          const e = 2 * Math.sqrt(1 + n - a - h);
          (this._w = (c - o) / e),
            (this._x = 0.25 * e),
            (this._y = (i + s) / e),
            (this._z = (r + l) / e);
        } else if (a > h) {
          const e = 2 * Math.sqrt(1 + a - n - h);
          (this._w = (r - l) / e),
            (this._x = (i + s) / e),
            (this._y = 0.25 * e),
            (this._z = (o + c) / e);
        } else {
          const e = 2 * Math.sqrt(1 + h - n - a);
          (this._w = (s - i) / e),
            (this._x = (r + l) / e),
            (this._y = (o + c) / e),
            (this._z = 0.25 * e);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return (
          n < Number.EPSILON
            ? ((n = 0),
              Math.abs(e.x) > Math.abs(e.z)
                ? ((this._x = -e.y),
                  (this._y = e.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -e.z),
                  (this._z = e.y),
                  (this._w = n)))
            : ((this._x = e.y * t.z - e.z * t.y),
              (this._y = e.z * t.x - e.x * t.z),
              (this._z = e.x * t.y - e.y * t.x),
              (this._w = n)),
          this.normalize()
        );
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(g(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (0 === n) return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(e) {
        return (
          this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let e = this.length();
        return (
          0 === e
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((e = 1 / e),
              (this._x = this._x * e),
              (this._y = this._y * e),
              (this._z = this._z * e),
              (this._w = this._w * e)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
            ),
            this.multiplyQuaternions(e, t))
          : this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        const n = e._x,
          i = e._y,
          r = e._z,
          s = e._w,
          a = t._x,
          o = t._y,
          l = t._z,
          c = t._w;
        return (
          (this._x = n * c + s * a + i * l - r * o),
          (this._y = i * c + s * o + r * a - n * l),
          (this._z = r * c + s * l + n * o - i * a),
          (this._w = s * c - n * a - i * o - r * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        const n = this._x,
          i = this._y,
          r = this._z,
          s = this._w;
        let a = s * e._w + n * e._x + i * e._y + r * e._z;
        if (
          (a < 0
            ? ((this._w = -e._w),
              (this._x = -e._x),
              (this._y = -e._y),
              (this._z = -e._z),
              (a = -a))
            : this.copy(e),
          a >= 1)
        )
          return (
            (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
          );
        const o = 1 - a * a;
        if (o <= Number.EPSILON) {
          const e = 1 - t;
          return (
            (this._w = e * s + t * this._w),
            (this._x = e * n + t * this._x),
            (this._y = e * i + t * this._y),
            (this._z = e * r + t * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(o),
          c = Math.atan2(l, a),
          h = Math.sin((1 - t) * c) / l,
          u = Math.sin(t * c) / l;
        return (
          (this._w = s * h + this._w * u),
          (this._x = n * h + this._x * u),
          (this._y = i * h + this._y * u),
          (this._z = r * h + this._z * u),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(e, t, n) {
        this.copy(e).slerp(t, n);
      }
      random() {
        const e = Math.random(),
          t = Math.sqrt(1 - e),
          n = Math.sqrt(e),
          i = 2 * Math.PI * Math.random(),
          r = 2 * Math.PI * Math.random();
        return this.set(
          t * Math.cos(i),
          n * Math.sin(r),
          n * Math.cos(r),
          t * Math.sin(i)
        );
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._w === this._w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this._x = e[t]),
          (this._y = e[t + 1]),
          (this._z = e[t + 2]),
          (this._w = e[t + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._w),
          e
        );
      }
      fromBufferAttribute(e, t) {
        return (
          (this._x = e.getX(t)),
          (this._y = e.getY(t)),
          (this._z = e.getZ(t)),
          (this._w = e.getW(t)),
          this
        );
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    z.prototype.isQuaternion = !0;
    class F {
      constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
      }
      set(e, t, n) {
        return (
          void 0 === n && (n = this.z),
          (this.x = e),
          (this.y = t),
          (this.z = n),
          this
        );
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(e, t))
          : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
      }
      multiplyVectors(e, t) {
        return (
          (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
        );
      }
      applyEuler(e) {
        return (
          (e && e.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(U.setFromEuler(e))
        );
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(U.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[3] * n + r[6] * i),
          (this.y = r[1] * t + r[4] * n + r[7] * i),
          (this.z = r[2] * t + r[5] * n + r[8] * i),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements,
          s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
          (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
          (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
          this
        );
      }
      applyQuaternion(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.x,
          s = e.y,
          a = e.z,
          o = e.w,
          l = o * t + s * i - a * n,
          c = o * n + a * t - r * i,
          h = o * i + r * n - s * t,
          u = -r * t - s * n - a * i;
        return (
          (this.x = l * o + u * -r + c * -a - h * -s),
          (this.y = c * o + u * -s + h * -r - l * -a),
          (this.z = h * o + u * -a + l * -s - c * -r),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
          e.projectionMatrix
        );
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
          e.matrixWorld
        );
      }
      transformDirection(e) {
        const t = this.x,
          n = this.y,
          i = this.z,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[4] * n + r[8] * i),
          (this.y = r[1] * t + r[5] * n + r[9] * i),
          (this.z = r[2] * t + r[6] * n + r[10] * i),
          this.normalize()
        );
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          this
        );
      }
      cross(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(e, t))
          : this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = t.x,
          a = t.y,
          o = t.z;
        return (
          (this.x = i * o - r * a),
          (this.y = r * s - n * o),
          (this.z = n * a - i * s),
          this
        );
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
      }
      projectOnPlane(e) {
        return B.copy(this).projectOnVector(e), this.sub(B);
      }
      reflect(e) {
        return this.sub(B.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(g(n, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y,
          i = this.z - e.z;
        return t * t + n * n + i * i;
      }
      manhattanDistanceTo(e) {
        return (
          Math.abs(this.x - e.x) +
          Math.abs(this.y - e.y) +
          Math.abs(this.z - e.z)
        );
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(t) * e),
          (this.z = i * Math.cos(n)),
          this
        );
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, n) {
        return (
          (this.x = e * Math.sin(t)),
          (this.y = n),
          (this.z = e * Math.cos(t)),
          this
        );
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
          n = this.setFromMatrixColumn(e, 1).length(),
          i = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = n), (this.z = i), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
      randomDirection() {
        const e = 2 * (Math.random() - 0.5),
          t = Math.random() * Math.PI * 2,
          n = Math.sqrt(1 - e ** 2);
        return (
          (this.x = n * Math.cos(t)),
          (this.y = n * Math.sin(t)),
          (this.z = e),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    }
    F.prototype.isVector3 = !0;
    const B = new F(),
      U = new z();
    class H {
      constructor(
        e = new F(1 / 0, 1 / 0, 1 / 0),
        t = new F(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        let t = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.length; o < l; o += 3) {
          const l = e[o],
            c = e[o + 1],
            h = e[o + 2];
          l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h);
        }
        return this.min.set(t, n, i), this.max.set(r, s, a), this;
      }
      setFromBufferAttribute(e) {
        let t = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          s = -1 / 0,
          a = -1 / 0;
        for (let o = 0, l = e.count; o < l; o++) {
          const l = e.getX(o),
            c = e.getY(o),
            h = e.getZ(o);
          l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h);
        }
        return this.min.set(t, n, i), this.max.set(r, s, a), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = G.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      setFromObject(e) {
        return this.makeEmpty(), this.expandByObject(e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e) {
        e.updateWorldMatrix(!1, !1);
        const t = e.geometry;
        void 0 !== t &&
          (null === t.boundingBox && t.computeBoundingBox(),
          V.copy(t.boundingBox),
          V.applyMatrix4(e.matrixWorld),
          this.union(V));
        const n = e.children;
        for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
        return this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y ||
          e.z < this.min.z ||
          e.z > this.max.z
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y &&
          this.min.z <= e.min.z &&
          e.max.z <= this.max.z
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y),
          (e.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y ||
          e.max.z < this.min.z ||
          e.min.z > this.max.z
        );
      }
      intersectsSphere(e) {
        return (
          this.clampPoint(e.center, G),
          G.distanceToSquared(e.center) <= e.radius * e.radius
        );
      }
      intersectsPlane(e) {
        let t, n;
        return (
          e.normal.x > 0
            ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
            : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
          e.normal.y > 0
            ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
            : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
          e.normal.z > 0
            ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
            : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
          t <= -e.constant && n >= -e.constant
        );
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Z),
          K.subVectors(this.max, Z),
          W.subVectors(e.a, Z),
          j.subVectors(e.b, Z),
          q.subVectors(e.c, Z),
          X.subVectors(j, W),
          Y.subVectors(q, j),
          J.subVectors(W, q);
        let t = [
          0,
          -X.z,
          X.y,
          0,
          -Y.z,
          Y.y,
          0,
          -J.z,
          J.y,
          X.z,
          0,
          -X.x,
          Y.z,
          0,
          -Y.x,
          J.z,
          0,
          -J.x,
          -X.y,
          X.x,
          0,
          -Y.y,
          Y.x,
          0,
          -J.y,
          J.x,
          0,
        ];
        return (
          !!ee(t, W, j, q, K) &&
          ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!ee(t, W, j, q, K) &&
            (Q.crossVectors(X, Y), (t = [Q.x, Q.y, Q.z]), ee(t, W, j, q, K)))
        );
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return G.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      getBoundingSphere(e) {
        return (
          this.getCenter(e.center),
          (e.radius = 0.5 * this.getSize(G).length()),
          e
        );
      }
      intersect(e) {
        return (
          this.min.max(e.min),
          this.max.min(e.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return (
          this.isEmpty() ||
            (k[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            k[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            k[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            k[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            k[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            k[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            k[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            k[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(k)),
          this
        );
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    H.prototype.isBox3 = !0;
    const k = [
        new F(),
        new F(),
        new F(),
        new F(),
        new F(),
        new F(),
        new F(),
        new F(),
      ],
      G = new F(),
      V = new H(),
      W = new F(),
      j = new F(),
      q = new F(),
      X = new F(),
      Y = new F(),
      J = new F(),
      Z = new F(),
      K = new F(),
      Q = new F(),
      $ = new F();
    function ee(e, t, n, i, r) {
      for (let s = 0, a = e.length - 3; s <= a; s += 3) {
        $.fromArray(e, s);
        const a =
            r.x * Math.abs($.x) + r.y * Math.abs($.y) + r.z * Math.abs($.z),
          o = t.dot($),
          l = n.dot($),
          c = i.dot($);
        if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
      }
      return !0;
    }
    const te = new H(),
      ne = new F(),
      ie = new F(),
      re = new F();
    class se {
      constructor(e = new F(), t = -1) {
        (this.center = e), (this.radius = t);
      }
      set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
      }
      setFromPoints(e, t) {
        const n = this.center;
        void 0 !== t ? n.copy(t) : te.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let t = 0, r = e.length; t < r; t++)
          i = Math.max(i, n.distanceToSquared(e[t]));
        return (this.radius = Math.sqrt(i)), this;
      }
      copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return (
          t.copy(e),
          n > this.radius * this.radius &&
            (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      }
      getBoundingBox(e) {
        return this.isEmpty()
          ? (e.makeEmpty(), e)
          : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }
      applyMatrix4(e) {
        return (
          this.center.applyMatrix4(e),
          (this.radius = this.radius * e.getMaxScaleOnAxis()),
          this
        );
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        re.subVectors(e, this.center);
        const t = re.lengthSq();
        if (t > this.radius * this.radius) {
          const e = Math.sqrt(t),
            n = 0.5 * (e - this.radius);
          this.center.add(re.multiplyScalar(n / e)), (this.radius += n);
        }
        return this;
      }
      union(e) {
        return (
          ie
            .subVectors(e.center, this.center)
            .normalize()
            .multiplyScalar(e.radius),
          this.expandByPoint(ne.copy(e.center).add(ie)),
          this.expandByPoint(ne.copy(e.center).sub(ie)),
          this
        );
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const ae = new F(),
      oe = new F(),
      le = new F(),
      ce = new F(),
      he = new F(),
      ue = new F(),
      de = new F();
    class pe {
      constructor(e = new F(), t = new F(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return (
          this.origin.copy(e.origin), this.direction.copy(e.direction), this
        );
      }
      at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, ae)), this;
      }
      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0
          ? t.copy(this.origin)
          : t.copy(this.direction).multiplyScalar(n).add(this.origin);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        const t = ae.subVectors(e, this.origin).dot(this.direction);
        return t < 0
          ? this.origin.distanceToSquared(e)
          : (ae.copy(this.direction).multiplyScalar(t).add(this.origin),
            ae.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, n, i) {
        oe.copy(e).add(t).multiplyScalar(0.5),
          le.copy(t).sub(e).normalize(),
          ce.copy(this.origin).sub(oe);
        const r = 0.5 * e.distanceTo(t),
          s = -this.direction.dot(le),
          a = ce.dot(this.direction),
          o = -ce.dot(le),
          l = ce.lengthSq(),
          c = Math.abs(1 - s * s);
        let h, u, d, p;
        if (c > 0)
          if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
            if (u >= -p)
              if (u <= p) {
                const e = 1 / c;
                (h *= e),
                  (u *= e),
                  (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
              } else
                (u = r),
                  (h = Math.max(0, -(s * u + a))),
                  (d = -h * h + u * (u + 2 * o) + l);
            else
              (u = -r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
          else
            u <= -p
              ? ((h = Math.max(0, -(-s * r + a))),
                (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                (d = -h * h + u * (u + 2 * o) + l))
              : u <= p
              ? ((h = 0),
                (u = Math.min(Math.max(-r, -o), r)),
                (d = u * (u + 2 * o) + l))
              : ((h = Math.max(0, -(s * r + a))),
                (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                (d = -h * h + u * (u + 2 * o) + l));
        else
          (u = s > 0 ? -r : r),
            (h = Math.max(0, -(s * u + a))),
            (d = -h * h + u * (u + 2 * o) + l);
        return (
          n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
          i && i.copy(le).multiplyScalar(u).add(oe),
          d
        );
      }
      intersectSphere(e, t) {
        ae.subVectors(e.center, this.origin);
        const n = ae.dot(this.direction),
          i = ae.dot(ae) - n * n,
          r = e.radius * e.radius;
        if (i > r) return null;
        const s = Math.sqrt(r - i),
          a = n - s,
          o = n + s;
        return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
      }
      intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        if (0 === t) return !0;
        return e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let n, i, r, s, a, o;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          h = 1 / this.direction.z,
          u = this.origin;
        return (
          l >= 0
            ? ((n = (e.min.x - u.x) * l), (i = (e.max.x - u.x) * l))
            : ((n = (e.max.x - u.x) * l), (i = (e.min.x - u.x) * l)),
          c >= 0
            ? ((r = (e.min.y - u.y) * c), (s = (e.max.y - u.y) * c))
            : ((r = (e.max.y - u.y) * c), (s = (e.min.y - u.y) * c)),
          n > s || r > i
            ? null
            : ((r > n || n != n) && (n = r),
              (s < i || i != i) && (i = s),
              h >= 0
                ? ((a = (e.min.z - u.z) * h), (o = (e.max.z - u.z) * h))
                : ((a = (e.max.z - u.z) * h), (o = (e.min.z - u.z) * h)),
              n > o || a > i
                ? null
                : ((a > n || n != n) && (n = a),
                  (o < i || i != i) && (i = o),
                  i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        );
      }
      intersectsBox(e) {
        return null !== this.intersectBox(e, ae);
      }
      intersectTriangle(e, t, n, i, r) {
        he.subVectors(t, e), ue.subVectors(n, e), de.crossVectors(he, ue);
        let s,
          a = this.direction.dot(de);
        if (a > 0) {
          if (i) return null;
          s = 1;
        } else {
          if (!(a < 0)) return null;
          (s = -1), (a = -a);
        }
        ce.subVectors(this.origin, e);
        const o = s * this.direction.dot(ue.crossVectors(ce, ue));
        if (o < 0) return null;
        const l = s * this.direction.dot(he.cross(ce));
        if (l < 0) return null;
        if (o + l > a) return null;
        const c = -s * ce.dot(de);
        return c < 0 ? null : this.at(c / a, r);
      }
      applyMatrix4(e) {
        return (
          this.origin.applyMatrix4(e),
          this.direction.transformDirection(e),
          this
        );
      }
      equals(e) {
        return (
          e.origin.equals(this.origin) && e.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class me {
      constructor() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
        const g = this.elements;
        return (
          (g[0] = e),
          (g[4] = t),
          (g[8] = n),
          (g[12] = i),
          (g[1] = r),
          (g[5] = s),
          (g[9] = a),
          (g[13] = o),
          (g[2] = l),
          (g[6] = c),
          (g[10] = h),
          (g[14] = u),
          (g[3] = d),
          (g[7] = p),
          (g[11] = m),
          (g[15] = f),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new me().fromArray(this.elements);
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          (t[9] = n[9]),
          (t[10] = n[10]),
          (t[11] = n[11]),
          (t[12] = n[12]),
          (t[13] = n[13]),
          (t[14] = n[14]),
          (t[15] = n[15]),
          this
        );
      }
      copyPosition(e) {
        const t = this.elements,
          n = e.elements;
        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
      }
      setFromMatrix3(e) {
        const t = e.elements;
        return (
          this.set(
            t[0],
            t[3],
            t[6],
            0,
            t[1],
            t[4],
            t[7],
            0,
            t[2],
            t[5],
            t[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(e, t, n) {
        return (
          this.set(
            e.x,
            t.x,
            n.x,
            0,
            e.y,
            t.y,
            n.y,
            0,
            e.z,
            t.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(e) {
        const t = this.elements,
          n = e.elements,
          i = 1 / fe.setFromMatrixColumn(e, 0).length(),
          r = 1 / fe.setFromMatrixColumn(e, 1).length(),
          s = 1 / fe.setFromMatrixColumn(e, 2).length();
        return (
          (t[0] = n[0] * i),
          (t[1] = n[1] * i),
          (t[2] = n[2] * i),
          (t[3] = 0),
          (t[4] = n[4] * r),
          (t[5] = n[5] * r),
          (t[6] = n[6] * r),
          (t[7] = 0),
          (t[8] = n[8] * s),
          (t[9] = n[9] * s),
          (t[10] = n[10] * s),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromEuler(e) {
        (e && e.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        const t = this.elements,
          n = e.x,
          i = e.y,
          r = e.z,
          s = Math.cos(n),
          a = Math.sin(n),
          o = Math.cos(i),
          l = Math.sin(i),
          c = Math.cos(r),
          h = Math.sin(r);
        if ("XYZ" === e.order) {
          const e = s * c,
            n = s * h,
            i = a * c,
            r = a * h;
          (t[0] = o * c),
            (t[4] = -o * h),
            (t[8] = l),
            (t[1] = n + i * l),
            (t[5] = e - r * l),
            (t[9] = -a * o),
            (t[2] = r - e * l),
            (t[6] = i + n * l),
            (t[10] = s * o);
        } else if ("YXZ" === e.order) {
          const e = o * c,
            n = o * h,
            i = l * c,
            r = l * h;
          (t[0] = e + r * a),
            (t[4] = i * a - n),
            (t[8] = s * l),
            (t[1] = s * h),
            (t[5] = s * c),
            (t[9] = -a),
            (t[2] = n * a - i),
            (t[6] = r + e * a),
            (t[10] = s * o);
        } else if ("ZXY" === e.order) {
          const e = o * c,
            n = o * h,
            i = l * c,
            r = l * h;
          (t[0] = e - r * a),
            (t[4] = -s * h),
            (t[8] = i + n * a),
            (t[1] = n + i * a),
            (t[5] = s * c),
            (t[9] = r - e * a),
            (t[2] = -s * l),
            (t[6] = a),
            (t[10] = s * o);
        } else if ("ZYX" === e.order) {
          const e = s * c,
            n = s * h,
            i = a * c,
            r = a * h;
          (t[0] = o * c),
            (t[4] = i * l - n),
            (t[8] = e * l + r),
            (t[1] = o * h),
            (t[5] = r * l + e),
            (t[9] = n * l - i),
            (t[2] = -l),
            (t[6] = a * o),
            (t[10] = s * o);
        } else if ("YZX" === e.order) {
          const e = s * o,
            n = s * l,
            i = a * o,
            r = a * l;
          (t[0] = o * c),
            (t[4] = r - e * h),
            (t[8] = i * h + n),
            (t[1] = h),
            (t[5] = s * c),
            (t[9] = -a * c),
            (t[2] = -l * c),
            (t[6] = n * h + i),
            (t[10] = e - r * h);
        } else if ("XZY" === e.order) {
          const e = s * o,
            n = s * l,
            i = a * o,
            r = a * l;
          (t[0] = o * c),
            (t[4] = -h),
            (t[8] = l * c),
            (t[1] = e * h + r),
            (t[5] = s * c),
            (t[9] = n * h - i),
            (t[2] = i * h - n),
            (t[6] = a * c),
            (t[10] = r * h + e);
        }
        return (
          (t[3] = 0),
          (t[7] = 0),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(e) {
        return this.compose(ve, e, _e);
      }
      lookAt(e, t, n) {
        const i = this.elements;
        return (
          be.subVectors(e, t),
          0 === be.lengthSq() && (be.z = 1),
          be.normalize(),
          xe.crossVectors(n, be),
          0 === xe.lengthSq() &&
            (1 === Math.abs(n.z) ? (be.x += 1e-4) : (be.z += 1e-4),
            be.normalize(),
            xe.crossVectors(n, be)),
          xe.normalize(),
          ye.crossVectors(be, xe),
          (i[0] = xe.x),
          (i[4] = ye.x),
          (i[8] = be.x),
          (i[1] = xe.y),
          (i[5] = ye.y),
          (i[9] = be.y),
          (i[2] = xe.z),
          (i[6] = ye.z),
          (i[10] = be.z),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(e, t))
          : this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          i = t.elements,
          r = this.elements,
          s = n[0],
          a = n[4],
          o = n[8],
          l = n[12],
          c = n[1],
          h = n[5],
          u = n[9],
          d = n[13],
          p = n[2],
          m = n[6],
          f = n[10],
          g = n[14],
          v = n[3],
          _ = n[7],
          x = n[11],
          y = n[15],
          b = i[0],
          w = i[4],
          M = i[8],
          S = i[12],
          T = i[1],
          E = i[5],
          A = i[9],
          L = i[13],
          R = i[2],
          C = i[6],
          P = i[10],
          I = i[14],
          D = i[3],
          N = i[7],
          O = i[11],
          z = i[15];
        return (
          (r[0] = s * b + a * T + o * R + l * D),
          (r[4] = s * w + a * E + o * C + l * N),
          (r[8] = s * M + a * A + o * P + l * O),
          (r[12] = s * S + a * L + o * I + l * z),
          (r[1] = c * b + h * T + u * R + d * D),
          (r[5] = c * w + h * E + u * C + d * N),
          (r[9] = c * M + h * A + u * P + d * O),
          (r[13] = c * S + h * L + u * I + d * z),
          (r[2] = p * b + m * T + f * R + g * D),
          (r[6] = p * w + m * E + f * C + g * N),
          (r[10] = p * M + m * A + f * P + g * O),
          (r[14] = p * S + m * L + f * I + g * z),
          (r[3] = v * b + _ * T + x * R + y * D),
          (r[7] = v * w + _ * E + x * C + y * N),
          (r[11] = v * M + _ * A + x * P + y * O),
          (r[15] = v * S + _ * L + x * I + y * z),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[4] *= e),
          (t[8] *= e),
          (t[12] *= e),
          (t[1] *= e),
          (t[5] *= e),
          (t[9] *= e),
          (t[13] *= e),
          (t[2] *= e),
          (t[6] *= e),
          (t[10] *= e),
          (t[14] *= e),
          (t[3] *= e),
          (t[7] *= e),
          (t[11] *= e),
          (t[15] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[4],
          i = e[8],
          r = e[12],
          s = e[1],
          a = e[5],
          o = e[9],
          l = e[13],
          c = e[2],
          h = e[6],
          u = e[10],
          d = e[14];
        return (
          e[3] *
            (+r * o * h -
              i * l * h -
              r * a * u +
              n * l * u +
              i * a * d -
              n * o * d) +
          e[7] *
            (+t * o * d -
              t * l * u +
              r * s * u -
              i * s * d +
              i * l * c -
              r * o * c) +
          e[11] *
            (+t * l * h -
              t * a * d -
              r * s * h +
              n * s * d +
              r * a * c -
              n * l * c) +
          e[15] *
            (-i * a * c -
              t * o * h +
              t * a * u +
              i * s * h -
              n * s * u +
              n * o * c)
        );
      }
      transpose() {
        const e = this.elements;
        let t;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      }
      setPosition(e, t, n) {
        const i = this.elements;
        return (
          e.isVector3
            ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
            : ((i[12] = e), (i[13] = t), (i[14] = n)),
          this
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          i = e[2],
          r = e[3],
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          c = e[8],
          h = e[9],
          u = e[10],
          d = e[11],
          p = e[12],
          m = e[13],
          f = e[14],
          g = e[15],
          v =
            h * f * l -
            m * u * l +
            m * o * d -
            a * f * d -
            h * o * g +
            a * u * g,
          _ =
            p * u * l -
            c * f * l -
            p * o * d +
            s * f * d +
            c * o * g -
            s * u * g,
          x =
            c * m * l -
            p * h * l +
            p * a * d -
            s * m * d -
            c * a * g +
            s * h * g,
          y =
            p * h * o -
            c * m * o -
            p * a * u +
            s * m * u +
            c * a * f -
            s * h * f,
          b = t * v + n * _ + i * x + r * y;
        if (0 === b)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / b;
        return (
          (e[0] = v * w),
          (e[1] =
            (m * u * r -
              h * f * r -
              m * i * d +
              n * f * d +
              h * i * g -
              n * u * g) *
            w),
          (e[2] =
            (a * f * r -
              m * o * r +
              m * i * l -
              n * f * l -
              a * i * g +
              n * o * g) *
            w),
          (e[3] =
            (h * o * r -
              a * u * r -
              h * i * l +
              n * u * l +
              a * i * d -
              n * o * d) *
            w),
          (e[4] = _ * w),
          (e[5] =
            (c * f * r -
              p * u * r +
              p * i * d -
              t * f * d -
              c * i * g +
              t * u * g) *
            w),
          (e[6] =
            (p * o * r -
              s * f * r -
              p * i * l +
              t * f * l +
              s * i * g -
              t * o * g) *
            w),
          (e[7] =
            (s * u * r -
              c * o * r +
              c * i * l -
              t * u * l -
              s * i * d +
              t * o * d) *
            w),
          (e[8] = x * w),
          (e[9] =
            (p * h * r -
              c * m * r -
              p * n * d +
              t * m * d +
              c * n * g -
              t * h * g) *
            w),
          (e[10] =
            (s * m * r -
              p * a * r +
              p * n * l -
              t * m * l -
              s * n * g +
              t * a * g) *
            w),
          (e[11] =
            (c * a * r -
              s * h * r -
              c * n * l +
              t * h * l +
              s * n * d -
              t * a * d) *
            w),
          (e[12] = y * w),
          (e[13] =
            (c * m * i -
              p * h * i +
              p * n * u -
              t * m * u -
              c * n * f +
              t * h * f) *
            w),
          (e[14] =
            (p * a * i -
              s * m * i -
              p * n * o +
              t * m * o +
              s * n * f -
              t * a * f) *
            w),
          (e[15] =
            (s * h * i -
              c * a * i +
              c * n * o -
              t * h * o -
              s * n * u +
              t * a * u) *
            w),
          this
        );
      }
      scale(e) {
        const t = this.elements,
          n = e.x,
          i = e.y,
          r = e.z;
        return (
          (t[0] *= n),
          (t[4] *= i),
          (t[8] *= r),
          (t[1] *= n),
          (t[5] *= i),
          (t[9] *= r),
          (t[2] *= n),
          (t[6] *= i),
          (t[10] *= r),
          (t[3] *= n),
          (t[7] *= i),
          (t[11] *= r),
          this
        );
      }
      getMaxScaleOnAxis() {
        const e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i));
      }
      makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        const n = Math.cos(t),
          i = Math.sin(t),
          r = 1 - n,
          s = e.x,
          a = e.y,
          o = e.z,
          l = r * s,
          c = r * a;
        return (
          this.set(
            l * s + n,
            l * a - i * o,
            l * o + i * a,
            0,
            l * a + i * o,
            c * a + n,
            c * o - i * s,
            0,
            l * o - i * a,
            c * o + i * s,
            r * o * o + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, n, i, r, s) {
        return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, n) {
        const i = this.elements,
          r = t._x,
          s = t._y,
          a = t._z,
          o = t._w,
          l = r + r,
          c = s + s,
          h = a + a,
          u = r * l,
          d = r * c,
          p = r * h,
          m = s * c,
          f = s * h,
          g = a * h,
          v = o * l,
          _ = o * c,
          x = o * h,
          y = n.x,
          b = n.y,
          w = n.z;
        return (
          (i[0] = (1 - (m + g)) * y),
          (i[1] = (d + x) * y),
          (i[2] = (p - _) * y),
          (i[3] = 0),
          (i[4] = (d - x) * b),
          (i[5] = (1 - (u + g)) * b),
          (i[6] = (f + v) * b),
          (i[7] = 0),
          (i[8] = (p + _) * w),
          (i[9] = (f - v) * w),
          (i[10] = (1 - (u + m)) * w),
          (i[11] = 0),
          (i[12] = e.x),
          (i[13] = e.y),
          (i[14] = e.z),
          (i[15] = 1),
          this
        );
      }
      decompose(e, t, n) {
        const i = this.elements;
        let r = fe.set(i[0], i[1], i[2]).length();
        const s = fe.set(i[4], i[5], i[6]).length(),
          a = fe.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (e.x = i[12]),
          (e.y = i[13]),
          (e.z = i[14]),
          ge.copy(this);
        const o = 1 / r,
          l = 1 / s,
          c = 1 / a;
        return (
          (ge.elements[0] *= o),
          (ge.elements[1] *= o),
          (ge.elements[2] *= o),
          (ge.elements[4] *= l),
          (ge.elements[5] *= l),
          (ge.elements[6] *= l),
          (ge.elements[8] *= c),
          (ge.elements[9] *= c),
          (ge.elements[10] *= c),
          t.setFromRotationMatrix(ge),
          (n.x = r),
          (n.y = s),
          (n.z = a),
          this
        );
      }
      makePerspective(e, t, n, i, r, s) {
        void 0 === s &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        const a = this.elements,
          o = (2 * r) / (t - e),
          l = (2 * r) / (n - i),
          c = (t + e) / (t - e),
          h = (n + i) / (n - i),
          u = -(s + r) / (s - r),
          d = (-2 * s * r) / (s - r);
        return (
          (a[0] = o),
          (a[4] = 0),
          (a[8] = c),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = l),
          (a[9] = h),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = u),
          (a[14] = d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(e, t, n, i, r, s) {
        const a = this.elements,
          o = 1 / (t - e),
          l = 1 / (n - i),
          c = 1 / (s - r),
          h = (t + e) * o,
          u = (n + i) * l,
          d = (s + r) * c;
        return (
          (a[0] = 2 * o),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -h),
          (a[1] = 0),
          (a[5] = 2 * l),
          (a[9] = 0),
          (a[13] = -u),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * c),
          (a[14] = -d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          (e[t + 9] = n[9]),
          (e[t + 10] = n[10]),
          (e[t + 11] = n[11]),
          (e[t + 12] = n[12]),
          (e[t + 13] = n[13]),
          (e[t + 14] = n[14]),
          (e[t + 15] = n[15]),
          e
        );
      }
    }
    me.prototype.isMatrix4 = !0;
    const fe = new F(),
      ge = new me(),
      ve = new F(0, 0, 0),
      _e = new F(1, 1, 1),
      xe = new F(),
      ye = new F(),
      be = new F(),
      we = new me(),
      Me = new z();
    class Se {
      constructor(e = 0, t = 0, n = 0, i = Se.DefaultOrder) {
        (this._x = e), (this._y = t), (this._z = n), (this._order = i);
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        (this._order = e), this._onChangeCallback();
      }
      set(e, t, n, i = this._order) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._order = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return (
          (this._x = e._x),
          (this._y = e._y),
          (this._z = e._z),
          (this._order = e._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e, t = this._order, n = !0) {
        const i = e.elements,
          r = i[0],
          s = i[4],
          a = i[8],
          o = i[1],
          l = i[5],
          c = i[9],
          h = i[2],
          u = i[6],
          d = i[10];
        switch (t) {
          case "XYZ":
            (this._y = Math.asin(g(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                : ((this._x = Math.atan2(u, l)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-g(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                : ((this._y = Math.atan2(-h, r)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(g(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
                : ((this._y = 0), (this._z = Math.atan2(o, r)));
            break;
          case "ZYX":
            (this._y = Math.asin(-g(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
                : ((this._x = 0), (this._z = Math.atan2(-s, l)));
            break;
          case "YZX":
            (this._z = Math.asin(g(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
                : ((this._x = 0), (this._y = Math.atan2(a, d)));
            break;
          case "XZY":
            (this._z = Math.asin(-g(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
                : ((this._x = Math.atan2(-c, d)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                t
            );
        }
        return (this._order = t), !0 === n && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, n) {
        return (
          we.makeRotationFromQuaternion(e), this.setFromRotationMatrix(we, t, n)
        );
      }
      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }
      reorder(e) {
        return Me.setFromEuler(this), this.setFromQuaternion(Me, e);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._order === this._order
        );
      }
      fromArray(e) {
        return (
          (this._x = e[0]),
          (this._y = e[1]),
          (this._z = e[2]),
          void 0 !== e[3] && (this._order = e[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._order),
          e
        );
      }
      toVector3(e) {
        return e
          ? e.set(this._x, this._y, this._z)
          : new F(this._x, this._y, this._z);
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    (Se.prototype.isEuler = !0),
      (Se.DefaultOrder = "XYZ"),
      (Se.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
    class Te {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = ((1 << e) | 0) >>> 0;
      }
      enable(e) {
        this.mask |= (1 << e) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= (1 << e) | 0;
      }
      disable(e) {
        this.mask &= ~((1 << e) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return 0 != (this.mask & e.mask);
      }
      isEnabled(e) {
        return 0 != (this.mask & ((1 << e) | 0));
      }
    }
    let Ee = 0;
    const Ae = new F(),
      Le = new z(),
      Re = new me(),
      Ce = new F(),
      Pe = new F(),
      Ie = new F(),
      De = new z(),
      Ne = new F(1, 0, 0),
      Oe = new F(0, 1, 0),
      ze = new F(0, 0, 1),
      Fe = { type: "added" },
      Be = { type: "removed" };
    class Ue extends h {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: Ee++ }),
          (this.uuid = f()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = Ue.DefaultUp.clone());
        const e = new F(),
          t = new Se(),
          n = new z(),
          i = new F(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }),
          n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: n },
            scale: { configurable: !0, enumerable: !0, value: i },
            modelViewMatrix: { value: new me() },
            normalMatrix: { value: new S() },
          }),
          (this.matrix = new me()),
          (this.matrixWorld = new me()),
          (this.matrixAutoUpdate = Ue.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new Te()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return Le.setFromAxisAngle(e, t), this.quaternion.multiply(Le), this;
      }
      rotateOnWorldAxis(e, t) {
        return Le.setFromAxisAngle(e, t), this.quaternion.premultiply(Le), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(Ne, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(Oe, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(ze, e);
      }
      translateOnAxis(e, t) {
        return (
          Ae.copy(e).applyQuaternion(this.quaternion),
          this.position.add(Ae.multiplyScalar(t)),
          this
        );
      }
      translateX(e) {
        return this.translateOnAxis(Ne, e);
      }
      translateY(e) {
        return this.translateOnAxis(Oe, e);
      }
      translateZ(e) {
        return this.translateOnAxis(ze, e);
      }
      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return e.applyMatrix4(Re.copy(this.matrixWorld).invert());
      }
      lookAt(e, t, n) {
        e.isVector3 ? Ce.copy(e) : Ce.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
          Pe.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? Re.lookAt(Pe, Ce, this.up)
            : Re.lookAt(Ce, Pe, this.up),
          this.quaternion.setFromRotationMatrix(Re),
          i &&
            (Re.extractRotation(i.matrixWorld),
            Le.setFromRotationMatrix(Re),
            this.quaternion.premultiply(Le.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              e
            ),
            this)
          : (e && e.isObject3D
              ? (null !== e.parent && e.parent.remove(e),
                (e.parent = this),
                this.children.push(e),
                e.dispatchEvent(Fe))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  e
                ),
            this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return (
          -1 !== t &&
            ((e.parent = null),
            this.children.splice(t, 1),
            e.dispatchEvent(Be)),
          this
        );
      }
      removeFromParent() {
        const e = this.parent;
        return null !== e && e.remove(this), this;
      }
      clear() {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          (t.parent = null), t.dispatchEvent(Be);
        }
        return (this.children.length = 0), this;
      }
      attach(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          Re.copy(this.matrixWorld).invert(),
          null !== e.parent &&
            (e.parent.updateWorldMatrix(!0, !1),
            Re.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(Re),
          this.add(e),
          e.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
          const i = this.children[n].getObjectByProperty(e, t);
          if (void 0 !== i) return i;
        }
      }
      getWorldPosition(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Pe, e, Ie),
          e
        );
      }
      getWorldScale(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Pe, De, e),
          e
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
      }
      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
      }
      updateWorldMatrix(e, t) {
        const n = this.parent;
        if (
          (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, n = e.length; t < n; t++)
            e[t].updateWorldMatrix(!1, !0);
        }
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e,
          n = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const i = {};
        function r(t, n) {
          return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = "InstancedMesh"),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor &&
              (i.instanceColor = this.instanceColor.toJSON())),
          this.isScene)
        )
          this.background &&
            (this.background.isColor
              ? (i.background = this.background.toJSON())
              : this.background.isTexture &&
                (i.background = this.background.toJSON(e).uuid)),
            this.environment &&
              this.environment.isTexture &&
              (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          i.geometry = r(e.geometries, this.geometry);
          const t = this.geometry.parameters;
          if (void 0 !== t && void 0 !== t.shapes) {
            const n = t.shapes;
            if (Array.isArray(n))
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                r(e.shapes, i);
              }
            else r(e.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((i.bindMode = this.bindMode),
            (i.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (r(e.skeletons, this.skeleton),
              (i.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const t = [];
            for (let n = 0, i = this.material.length; n < i; n++)
              t.push(r(e.materials, this.material[n]));
            i.material = t;
          } else i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (let t = 0; t < this.children.length; t++)
            i.children.push(this.children[t].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          i.animations = [];
          for (let t = 0; t < this.animations.length; t++) {
            const n = this.animations[t];
            i.animations.push(r(e.animations, n));
          }
        }
        if (t) {
          const t = s(e.geometries),
            i = s(e.materials),
            r = s(e.textures),
            a = s(e.images),
            o = s(e.shapes),
            l = s(e.skeletons),
            c = s(e.animations);
          t.length > 0 && (n.geometries = t),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            a.length > 0 && (n.images = a),
            o.length > 0 && (n.shapes = o),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c);
        }
        return (n.object = i), n;
        function s(e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            delete i.metadata, t.push(i);
          }
          return t;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) {
            const n = e.children[t];
            this.add(n.clone());
          }
        return this;
      }
    }
    (Ue.DefaultUp = new F(0, 1, 0)),
      (Ue.DefaultMatrixAutoUpdate = !0),
      (Ue.prototype.isObject3D = !0);
    const He = new F(),
      ke = new F(),
      Ge = new F(),
      Ve = new F(),
      We = new F(),
      je = new F(),
      qe = new F(),
      Xe = new F(),
      Ye = new F(),
      Je = new F();
    class Ze {
      constructor(e = new F(), t = new F(), n = new F()) {
        (this.a = e), (this.b = t), (this.c = n);
      }
      static getNormal(e, t, n, i) {
        i.subVectors(n, t), He.subVectors(e, t), i.cross(He);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      }
      static getBarycoord(e, t, n, i, r) {
        He.subVectors(i, t), ke.subVectors(n, t), Ge.subVectors(e, t);
        const s = He.dot(He),
          a = He.dot(ke),
          o = He.dot(Ge),
          l = ke.dot(ke),
          c = ke.dot(Ge),
          h = s * l - a * a;
        if (0 === h) return r.set(-2, -1, -1);
        const u = 1 / h,
          d = (l * o - a * c) * u,
          p = (s * c - a * o) * u;
        return r.set(1 - d - p, p, d);
      }
      static containsPoint(e, t, n, i) {
        return (
          this.getBarycoord(e, t, n, i, Ve),
          Ve.x >= 0 && Ve.y >= 0 && Ve.x + Ve.y <= 1
        );
      }
      static getUV(e, t, n, i, r, s, a, o) {
        return (
          this.getBarycoord(e, t, n, i, Ve),
          o.set(0, 0),
          o.addScaledVector(r, Ve.x),
          o.addScaledVector(s, Ve.y),
          o.addScaledVector(a, Ve.z),
          o
        );
      }
      static isFrontFacing(e, t, n, i) {
        return (
          He.subVectors(n, t), ke.subVectors(e, t), He.cross(ke).dot(i) < 0
        );
      }
      set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
      }
      setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
      }
      setFromAttributeAndIndices(e, t, n, i) {
        return (
          this.a.fromBufferAttribute(e, t),
          this.b.fromBufferAttribute(e, n),
          this.c.fromBufferAttribute(e, i),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return (
          He.subVectors(this.c, this.b),
          ke.subVectors(this.a, this.b),
          0.5 * He.cross(ke).length()
        );
      }
      getMidpoint(e) {
        return e
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(e) {
        return Ze.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(e, t) {
        return Ze.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getUV(e, t, n, i, r) {
        return Ze.getUV(e, this.a, this.b, this.c, t, n, i, r);
      }
      containsPoint(e) {
        return Ze.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return Ze.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        const n = this.a,
          i = this.b,
          r = this.c;
        let s, a;
        We.subVectors(i, n), je.subVectors(r, n), Xe.subVectors(e, n);
        const o = We.dot(Xe),
          l = je.dot(Xe);
        if (o <= 0 && l <= 0) return t.copy(n);
        Ye.subVectors(e, i);
        const c = We.dot(Ye),
          h = je.dot(Ye);
        if (c >= 0 && h <= c) return t.copy(i);
        const u = o * h - c * l;
        if (u <= 0 && o >= 0 && c <= 0)
          return (s = o / (o - c)), t.copy(n).addScaledVector(We, s);
        Je.subVectors(e, r);
        const d = We.dot(Je),
          p = je.dot(Je);
        if (p >= 0 && d <= p) return t.copy(r);
        const m = d * l - o * p;
        if (m <= 0 && l >= 0 && p <= 0)
          return (a = l / (l - p)), t.copy(n).addScaledVector(je, a);
        const f = c * p - d * h;
        if (f <= 0 && h - c >= 0 && d - p >= 0)
          return (
            qe.subVectors(r, i),
            (a = (h - c) / (h - c + (d - p))),
            t.copy(i).addScaledVector(qe, a)
          );
        const g = 1 / (f + m + u);
        return (
          (s = m * g),
          (a = u * g),
          t.copy(n).addScaledVector(We, s).addScaledVector(je, a)
        );
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    }
    let Ke = 0;
    class Qe extends h {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: Ke++ }),
          (this.uuid = f()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.blending = 1),
          (this.side = 0),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.format = 1023),
          (this.transparent = !1),
          (this.blendSrc = 204),
          (this.blendDst = 205),
          (this.blendEquation = 100),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = 3),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = 519),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = 7680),
          (this.stencilZFail = 7680),
          (this.stencilZPass = 7680),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
      }
      onBuild() {}
      onBeforeRender() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(e) {
        if (void 0 !== e)
          for (const t in e) {
            const n = e[t];
            if (void 0 === n) {
              console.warn(
                "THREE.Material: '" + t + "' parameter is undefined."
              );
              continue;
            }
            if ("shading" === t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = 1 === n);
              continue;
            }
            const i = this[t];
            void 0 !== i
              ? i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[t] = n)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
          }
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        t && (e = { textures: {}, images: {} });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function i(e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            delete i.metadata, t.push(i);
          }
          return t;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          void 0 !== this.sheen && (n.sheen = this.sheen),
          this.sheenColor &&
            this.sheenColor.isColor &&
            (n.sheenColor = this.sheenColor.getHex()),
          void 0 !== this.sheenRoughness &&
            (n.sheenRoughness = this.sheenRoughness),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity &&
            (n.specularIntensity = this.specularIntensity),
          this.specularColor &&
            this.specularColor.isColor &&
            (n.specularColor = this.specularColor.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((n.lightMap = this.lightMap.toJSON(e).uuid),
            (n.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(e).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(e).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(e).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
          this.specularColorMap &&
            this.specularColorMap.isTexture &&
            (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(e).uuid),
            void 0 !== this.combine && (n.combine = this.combine)),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio &&
            (n.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(e).uuid),
          void 0 !== this.transmission && (n.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
          void 0 !== this.thickness && (n.thickness = this.thickness),
          this.thicknessMap &&
            this.thicknessMap.isTexture &&
            (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
          void 0 !== this.attenuationDistance &&
            (n.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationColor &&
            (n.attenuationColor = this.attenuationColor.getHex()),
          void 0 !== this.size && (n.size = this.size),
          null !== this.shadowSide && (n.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (n.blending = this.blending),
          0 !== this.side && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          1023 !== this.format && (n.format = this.format),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.colorWrite = this.colorWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.alphaToCoverage &&
            (n.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          t)
        ) {
          const t = i(e.textures),
            r = i(e.images);
          t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
        }
        return n;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.name = e.name),
          (this.fog = e.fog),
          (this.blending = e.blending),
          (this.side = e.side),
          (this.vertexColors = e.vertexColors),
          (this.opacity = e.opacity),
          (this.format = e.format),
          (this.transparent = e.transparent),
          (this.blendSrc = e.blendSrc),
          (this.blendDst = e.blendDst),
          (this.blendEquation = e.blendEquation),
          (this.blendSrcAlpha = e.blendSrcAlpha),
          (this.blendDstAlpha = e.blendDstAlpha),
          (this.blendEquationAlpha = e.blendEquationAlpha),
          (this.depthFunc = e.depthFunc),
          (this.depthTest = e.depthTest),
          (this.depthWrite = e.depthWrite),
          (this.stencilWriteMask = e.stencilWriteMask),
          (this.stencilFunc = e.stencilFunc),
          (this.stencilRef = e.stencilRef),
          (this.stencilFuncMask = e.stencilFuncMask),
          (this.stencilFail = e.stencilFail),
          (this.stencilZFail = e.stencilZFail),
          (this.stencilZPass = e.stencilZPass),
          (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let n = null;
        if (null !== t) {
          const e = t.length;
          n = new Array(e);
          for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = e.clipIntersection),
          (this.clipShadows = e.clipShadows),
          (this.shadowSide = e.shadowSide),
          (this.colorWrite = e.colorWrite),
          (this.precision = e.precision),
          (this.polygonOffset = e.polygonOffset),
          (this.polygonOffsetFactor = e.polygonOffsetFactor),
          (this.polygonOffsetUnits = e.polygonOffsetUnits),
          (this.dithering = e.dithering),
          (this.alphaTest = e.alphaTest),
          (this.alphaToCoverage = e.alphaToCoverage),
          (this.premultipliedAlpha = e.premultipliedAlpha),
          (this.visible = e.visible),
          (this.toneMapped = e.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }
    Qe.prototype.isMaterial = !0;
    const $e = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      et = { h: 0, s: 0, l: 0 },
      tt = { h: 0, s: 0, l: 0 };
    function nt(e, t, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? e + 6 * (t - e) * n
          : n < 0.5
          ? t
          : n < 2 / 3
          ? e + 6 * (t - e) * (2 / 3 - n)
          : e
      );
    }
    function it(e) {
      return e < 0.04045
        ? 0.0773993808 * e
        : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
    }
    function rt(e) {
      return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
    }
    class st {
      constructor(e, t, n) {
        return void 0 === t && void 0 === n
          ? this.set(e)
          : this.setRGB(e, t, n);
      }
      set(e) {
        return (
          e && e.isColor
            ? this.copy(e)
            : "number" == typeof e
            ? this.setHex(e)
            : "string" == typeof e && this.setStyle(e),
          this
        );
      }
      setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
      }
      setHex(e) {
        return (
          (e = Math.floor(e)),
          (this.r = ((e >> 16) & 255) / 255),
          (this.g = ((e >> 8) & 255) / 255),
          (this.b = (255 & e) / 255),
          this
        );
      }
      setRGB(e, t, n) {
        return (this.r = e), (this.g = t), (this.b = n), this;
      }
      setHSL(e, t, n) {
        if (((e = v(e, 1)), (t = g(t, 0, 1)), (n = g(n, 0, 1)), 0 === t))
          this.r = this.g = this.b = n;
        else {
          const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
            r = 2 * n - i;
          (this.r = nt(r, i, e + 1 / 3)),
            (this.g = nt(r, i, e)),
            (this.b = nt(r, i, e - 1 / 3));
        }
        return this;
      }
      setStyle(e) {
        function t(t) {
          void 0 !== t &&
            parseFloat(t) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + e + " will be ignored."
            );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
          let e;
          const i = n[1],
            r = n[2];
          switch (i) {
            case "rgb":
            case "rgba":
              if (
                (e =
                  /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                  t(e[4]),
                  this
                );
              if (
                (e =
                  /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                  t(e[4]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (e =
                  /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r
                  ))
              ) {
                const n = parseFloat(e[1]) / 360,
                  i = parseInt(e[2], 10) / 100,
                  r = parseInt(e[3], 10) / 100;
                return t(e[4]), this.setHSL(n, i, r);
              }
          }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
          const e = n[1],
            t = e.length;
          if (3 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
              (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
              (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
              this
            );
          if (6 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
              (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
              (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
              this
            );
        }
        return e && e.length > 0 ? this.setColorName(e) : this;
      }
      setColorName(e) {
        const t = $e[e.toLowerCase()];
        return (
          void 0 !== t
            ? this.setHex(t)
            : console.warn("THREE.Color: Unknown color " + e),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
      }
      copyGammaToLinear(e, t = 2) {
        return (
          (this.r = Math.pow(e.r, t)),
          (this.g = Math.pow(e.g, t)),
          (this.b = Math.pow(e.b, t)),
          this
        );
      }
      copyLinearToGamma(e, t = 2) {
        const n = t > 0 ? 1 / t : 1;
        return (
          (this.r = Math.pow(e.r, n)),
          (this.g = Math.pow(e.g, n)),
          (this.b = Math.pow(e.b, n)),
          this
        );
      }
      convertGammaToLinear(e) {
        return this.copyGammaToLinear(this, e), this;
      }
      convertLinearToGamma(e) {
        return this.copyLinearToGamma(this, e), this;
      }
      copySRGBToLinear(e) {
        return (this.r = it(e.r)), (this.g = it(e.g)), (this.b = it(e.b)), this;
      }
      copyLinearToSRGB(e) {
        return (this.r = rt(e.r)), (this.g = rt(e.g)), (this.b = rt(e.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(e) {
        const t = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(t, n, i),
          s = Math.min(t, n, i);
        let a, o;
        const l = (s + r) / 2;
        if (s === r) (a = 0), (o = 0);
        else {
          const e = r - s;
          switch (((o = l <= 0.5 ? e / (r + s) : e / (2 - r - s)), r)) {
            case t:
              a = (n - i) / e + (n < i ? 6 : 0);
              break;
            case n:
              a = (i - t) / e + 2;
              break;
            case i:
              a = (t - n) / e + 4;
          }
          a /= 6;
        }
        return (e.h = a), (e.s = o), (e.l = l), e;
      }
      getStyle() {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      }
      offsetHSL(e, t, n) {
        return (
          this.getHSL(et),
          (et.h += e),
          (et.s += t),
          (et.l += n),
          this.setHSL(et.h, et.s, et.l),
          this
        );
      }
      add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
      }
      addColors(e, t) {
        return (
          (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
        );
      }
      addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
      }
      sub(e) {
        return (
          (this.r = Math.max(0, this.r - e.r)),
          (this.g = Math.max(0, this.g - e.g)),
          (this.b = Math.max(0, this.b - e.b)),
          this
        );
      }
      multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
      }
      multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
      }
      lerp(e, t) {
        return (
          (this.r += (e.r - this.r) * t),
          (this.g += (e.g - this.g) * t),
          (this.b += (e.b - this.b) * t),
          this
        );
      }
      lerpColors(e, t, n) {
        return (
          (this.r = e.r + (t.r - e.r) * n),
          (this.g = e.g + (t.g - e.g) * n),
          (this.b = e.b + (t.b - e.b) * n),
          this
        );
      }
      lerpHSL(e, t) {
        this.getHSL(et), e.getHSL(tt);
        const n = _(et.h, tt.h, t),
          i = _(et.s, tt.s, t),
          r = _(et.l, tt.l, t);
        return this.setHSL(n, i, r), this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
      }
      fromBufferAttribute(e, t) {
        return (
          (this.r = e.getX(t)),
          (this.g = e.getY(t)),
          (this.b = e.getZ(t)),
          !0 === e.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
    }
    (st.NAMES = $e),
      (st.prototype.isColor = !0),
      (st.prototype.r = 1),
      (st.prototype.g = 1),
      (st.prototype.b = 1);
    class at extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshBasicMaterial"),
          (this.color = new st(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    at.prototype.isMeshBasicMaterial = !0;
    const ot = new F(),
      lt = new M();
    class ct {
      constructor(e, t, n) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === n),
          (this.usage = 35044),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.itemSize), (n *= t.itemSize);
        for (let i = 0, r = this.itemSize; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      copyColorsArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              i
            ),
            (r = new st())),
            (t[n++] = r.r),
            (t[n++] = r.g),
            (t[n++] = r.b);
        }
        return this;
      }
      copyVector2sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              i
            ),
            (r = new M())),
            (t[n++] = r.x),
            (t[n++] = r.y);
        }
        return this;
      }
      copyVector3sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              i
            ),
            (r = new F())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z);
        }
        return this;
      }
      copyVector4sArray(e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              i
            ),
            (r = new D())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z),
            (t[n++] = r.w);
        }
        return this;
      }
      applyMatrix3(e) {
        if (2 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            lt.fromBufferAttribute(this, t),
              lt.applyMatrix3(e),
              this.setXY(t, lt.x, lt.y);
        else if (3 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            ot.fromBufferAttribute(this, t),
              ot.applyMatrix3(e),
              this.setXYZ(t, ot.x, ot.y, ot.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (ot.x = this.getX(t)),
            (ot.y = this.getY(t)),
            (ot.z = this.getZ(t)),
            ot.applyMatrix4(e),
            this.setXYZ(t, ot.x, ot.y, ot.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (ot.x = this.getX(t)),
            (ot.y = this.getY(t)),
            (ot.z = this.getZ(t)),
            ot.applyNormalMatrix(e),
            this.setXYZ(t, ot.x, ot.y, ot.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (ot.x = this.getX(t)),
            (ot.y = this.getY(t)),
            (ot.z = this.getZ(t)),
            ot.transformDirection(e),
            this.setXYZ(t, ot.x, ot.y, ot.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getX(e) {
        return this.array[e * this.itemSize];
      }
      setX(e, t) {
        return (this.array[e * this.itemSize] = t), this;
      }
      getY(e) {
        return this.array[e * this.itemSize + 1];
      }
      setY(e, t) {
        return (this.array[e * this.itemSize + 1] = t), this;
      }
      getZ(e) {
        return this.array[e * this.itemSize + 2];
      }
      setZ(e, t) {
        return (this.array[e * this.itemSize + 2] = t), this;
      }
      getW(e) {
        return this.array[e * this.itemSize + 3];
      }
      setW(e, t) {
        return (this.array[e * this.itemSize + 3] = t), this;
      }
      setXY(e, t, n) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, i) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          this
        );
      }
      setXYZW(e, t, n, i, r) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          (this.array[e + 3] = r),
          this
        );
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
        return (
          "" !== this.name && (e.name = this.name),
          35044 !== this.usage && (e.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
            (e.updateRange = this.updateRange),
          e
        );
      }
    }
    ct.prototype.isBufferAttribute = !0;
    class ht extends ct {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }
    class ut extends ct {
      constructor(e, t, n) {
        super(new Uint32Array(e), t, n);
      }
    }
    (class extends ct {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }.prototype.isFloat16BufferAttribute = !0);
    class dt extends ct {
      constructor(e, t, n) {
        super(new Float32Array(e), t, n);
      }
    }
    let pt = 0;
    const mt = new me(),
      ft = new Ue(),
      gt = new F(),
      vt = new H(),
      _t = new H(),
      xt = new F();
    class yt extends h {
      constructor() {
        super(),
          Object.defineProperty(this, "id", { value: pt++ }),
          (this.uuid = f()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return (
          Array.isArray(e)
            ? (this.index = new (T(e) > 65535 ? ut : ht)(e, 1))
            : (this.index = e),
          this
        );
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return (this.attributes[e] = t), this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return void 0 !== this.attributes[e];
      }
      addGroup(e, t, n = 0) {
        this.groups.push({ start: e, count: t, materialIndex: n });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
      }
      applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const t = new S().getNormalMatrix(e);
          n.applyNormalMatrix(t), (n.needsUpdate = !0);
        }
        const i = this.attributes.tangent;
        return (
          void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(e) {
        return mt.makeRotationFromQuaternion(e), this.applyMatrix4(mt), this;
      }
      rotateX(e) {
        return mt.makeRotationX(e), this.applyMatrix4(mt), this;
      }
      rotateY(e) {
        return mt.makeRotationY(e), this.applyMatrix4(mt), this;
      }
      rotateZ(e) {
        return mt.makeRotationZ(e), this.applyMatrix4(mt), this;
      }
      translate(e, t, n) {
        return mt.makeTranslation(e, t, n), this.applyMatrix4(mt), this;
      }
      scale(e, t, n) {
        return mt.makeScale(e, t, n), this.applyMatrix4(mt), this;
      }
      lookAt(e) {
        return (
          ft.lookAt(e), ft.updateMatrix(), this.applyMatrix4(ft.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(gt).negate(),
          this.translate(gt.x, gt.y, gt.z),
          this
        );
      }
      setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
          const i = e[n];
          t.push(i.x, i.y, i.z || 0);
        }
        return this.setAttribute("position", new dt(t, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new H());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingBox.set(
              new F(-1 / 0, -1 / 0, -1 / 0),
              new F(1 / 0, 1 / 0, 1 / 0)
            )
          );
        if (void 0 !== e) {
          if ((this.boundingBox.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              vt.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (xt.addVectors(this.boundingBox.min, vt.min),
                    this.boundingBox.expandByPoint(xt),
                    xt.addVectors(this.boundingBox.max, vt.max),
                    this.boundingBox.expandByPoint(xt))
                  : (this.boundingBox.expandByPoint(vt.min),
                    this.boundingBox.expandByPoint(vt.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new se());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingSphere.set(new F(), 1 / 0)
          );
        if (e) {
          const n = this.boundingSphere.center;
          if ((vt.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              _t.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (xt.addVectors(vt.min, _t.min),
                    vt.expandByPoint(xt),
                    xt.addVectors(vt.max, _t.max),
                    vt.expandByPoint(xt))
                  : (vt.expandByPoint(_t.min), vt.expandByPoint(_t.max));
            }
          vt.getCenter(n);
          let i = 0;
          for (let t = 0, r = e.count; t < r; t++)
            xt.fromBufferAttribute(e, t),
              (i = Math.max(i, n.distanceToSquared(xt)));
          if (t)
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                a = this.morphTargetsRelative;
              for (let t = 0, r = s.count; t < r; t++)
                xt.fromBufferAttribute(s, t),
                  a && (gt.fromBufferAttribute(e, t), xt.add(gt)),
                  (i = Math.max(i, n.distanceToSquared(xt)));
            }
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeTangents() {
        const e = this.index,
          t = this.attributes;
        if (
          null === e ||
          void 0 === t.position ||
          void 0 === t.normal ||
          void 0 === t.uv
        )
          return void console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
        const n = e.array,
          i = t.position.array,
          r = t.normal.array,
          s = t.uv.array,
          a = i.length / 3;
        void 0 === t.tangent &&
          this.setAttribute("tangent", new ct(new Float32Array(4 * a), 4));
        const o = t.tangent.array,
          l = [],
          c = [];
        for (let e = 0; e < a; e++) (l[e] = new F()), (c[e] = new F());
        const h = new F(),
          u = new F(),
          d = new F(),
          p = new M(),
          m = new M(),
          f = new M(),
          g = new F(),
          v = new F();
        function _(e, t, n) {
          h.fromArray(i, 3 * e),
            u.fromArray(i, 3 * t),
            d.fromArray(i, 3 * n),
            p.fromArray(s, 2 * e),
            m.fromArray(s, 2 * t),
            f.fromArray(s, 2 * n),
            u.sub(h),
            d.sub(h),
            m.sub(p),
            f.sub(p);
          const r = 1 / (m.x * f.y - f.x * m.y);
          isFinite(r) &&
            (g
              .copy(u)
              .multiplyScalar(f.y)
              .addScaledVector(d, -m.y)
              .multiplyScalar(r),
            v
              .copy(d)
              .multiplyScalar(m.x)
              .addScaledVector(u, -f.x)
              .multiplyScalar(r),
            l[e].add(g),
            l[t].add(g),
            l[n].add(g),
            c[e].add(v),
            c[t].add(v),
            c[n].add(v));
        }
        let x = this.groups;
        0 === x.length && (x = [{ start: 0, count: n.length }]);
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            i = t.start;
          for (let e = i, r = i + t.count; e < r; e += 3)
            _(n[e + 0], n[e + 1], n[e + 2]);
        }
        const y = new F(),
          b = new F(),
          w = new F(),
          S = new F();
        function T(e) {
          w.fromArray(r, 3 * e), S.copy(w);
          const t = l[e];
          y.copy(t),
            y.sub(w.multiplyScalar(w.dot(t))).normalize(),
            b.crossVectors(S, t);
          const n = b.dot(c[e]) < 0 ? -1 : 1;
          (o[4 * e] = y.x),
            (o[4 * e + 1] = y.y),
            (o[4 * e + 2] = y.z),
            (o[4 * e + 3] = n);
        }
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            i = t.start;
          for (let e = i, r = i + t.count; e < r; e += 3)
            T(n[e + 0]), T(n[e + 1]), T(n[e + 2]);
        }
      }
      computeVertexNormals() {
        const e = this.index,
          t = this.getAttribute("position");
        if (void 0 !== t) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new ct(new Float32Array(3 * t.count), 3)),
              this.setAttribute("normal", n);
          else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
          const i = new F(),
            r = new F(),
            s = new F(),
            a = new F(),
            o = new F(),
            l = new F(),
            c = new F(),
            h = new F();
          if (e)
            for (let u = 0, d = e.count; u < d; u += 3) {
              const d = e.getX(u + 0),
                p = e.getX(u + 1),
                m = e.getX(u + 2);
              i.fromBufferAttribute(t, d),
                r.fromBufferAttribute(t, p),
                s.fromBufferAttribute(t, m),
                c.subVectors(s, r),
                h.subVectors(i, r),
                c.cross(h),
                a.fromBufferAttribute(n, d),
                o.fromBufferAttribute(n, p),
                l.fromBufferAttribute(n, m),
                a.add(c),
                o.add(c),
                l.add(c),
                n.setXYZ(d, a.x, a.y, a.z),
                n.setXYZ(p, o.x, o.y, o.z),
                n.setXYZ(m, l.x, l.y, l.z);
            }
          else
            for (let e = 0, a = t.count; e < a; e += 3)
              i.fromBufferAttribute(t, e + 0),
                r.fromBufferAttribute(t, e + 1),
                s.fromBufferAttribute(t, e + 2),
                c.subVectors(s, r),
                h.subVectors(i, r),
                c.cross(h),
                n.setXYZ(e + 0, c.x, c.y, c.z),
                n.setXYZ(e + 1, c.x, c.y, c.z),
                n.setXYZ(e + 2, c.x, c.y, c.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      }
      merge(e, t) {
        if (!e || !e.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            e
          );
        void 0 === t &&
          ((t = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        const n = this.attributes;
        for (const i in n) {
          if (void 0 === e.attributes[i]) continue;
          const r = n[i].array,
            s = e.attributes[i],
            a = s.array,
            o = s.itemSize * t,
            l = Math.min(a.length, r.length - o);
          for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e];
        }
        return this;
      }
      normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
          xt.fromBufferAttribute(e, t),
            xt.normalize(),
            e.setXYZ(t, xt.x, xt.y, xt.z);
      }
      toNonIndexed() {
        function e(e, t) {
          const n = e.array,
            i = e.itemSize,
            r = e.normalized,
            s = new n.constructor(t.length * i);
          let a = 0,
            o = 0;
          for (let r = 0, l = t.length; r < l; r++) {
            a = e.isInterleavedBufferAttribute
              ? t[r] * e.data.stride + e.offset
              : t[r] * i;
            for (let e = 0; e < i; e++) s[o++] = n[a++];
          }
          return new ct(s, i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        const t = new yt(),
          n = this.index.array,
          i = this.attributes;
        for (const r in i) {
          const s = e(i[r], n);
          t.setAttribute(r, s);
        }
        const r = this.morphAttributes;
        for (const i in r) {
          const s = [],
            a = r[i];
          for (let t = 0, i = a.length; t < i; t++) {
            const i = e(a[t], n);
            s.push(i);
          }
          t.morphAttributes[i] = s;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e];
          t.addGroup(n.start, n.count, n.materialIndex);
        }
        return t;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((e.uuid = this.uuid),
          (e.type = this.type),
          "" !== this.name && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const t = this.parameters;
          for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
          return e;
        }
        e.data = { attributes: {} };
        const t = this.index;
        null !== t &&
          (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array),
          });
        const n = this.attributes;
        for (const t in n) {
          const i = n[t];
          e.data.attributes[t] = i.toJSON(e.data);
        }
        const i = {};
        let r = !1;
        for (const t in this.morphAttributes) {
          const n = this.morphAttributes[t],
            s = [];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            s.push(i.toJSON(e.data));
          }
          s.length > 0 && ((i[t] = s), (r = !0));
        }
        r &&
          ((e.data.morphAttributes = i),
          (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const a = this.boundingSphere;
        return (
          null !== a &&
            (e.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius,
            }),
          e
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const e in i) {
          const n = i[e];
          this.setAttribute(e, n.clone(t));
        }
        const r = e.morphAttributes;
        for (const e in r) {
          const n = [],
            i = r[e];
          for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
          this.morphAttributes[e] = n;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;
        for (let e = 0, t = s.length; e < t; e++) {
          const t = s[e];
          this.addGroup(t.start, t.count, t.materialIndex);
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const o = e.boundingSphere;
        return (
          null !== o && (this.boundingSphere = o.clone()),
          (this.drawRange.start = e.drawRange.start),
          (this.drawRange.count = e.drawRange.count),
          (this.userData = e.userData),
          void 0 !== e.parameters &&
            (this.parameters = Object.assign({}, e.parameters)),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    yt.prototype.isBufferGeometry = !0;
    const bt = new me(),
      wt = new pe(),
      Mt = new se(),
      St = new F(),
      Tt = new F(),
      Et = new F(),
      At = new F(),
      Lt = new F(),
      Rt = new F(),
      Ct = new F(),
      Pt = new F(),
      It = new F(),
      Dt = new M(),
      Nt = new M(),
      Ot = new M(),
      zt = new F(),
      Ft = new F();
    class Bt extends Ue {
      constructor(e = new yt(), t = new at()) {
        super(),
          (this.type = "Mesh"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.morphTargetInfluences &&
            (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          void 0 !== e.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              e.morphTargetDictionary
            )),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
        if (void 0 === i) return;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Mt.copy(n.boundingSphere),
          Mt.applyMatrix4(r),
          !1 === e.ray.intersectsSphere(Mt))
        )
          return;
        if (
          (bt.copy(r).invert(),
          wt.copy(e.ray).applyMatrix4(bt),
          null !== n.boundingBox && !1 === wt.intersectsBox(n.boundingBox))
        )
          return;
        let s;
        if (n.isBufferGeometry) {
          const r = n.index,
            a = n.attributes.position,
            o = n.morphAttributes.position,
            l = n.morphTargetsRelative,
            c = n.attributes.uv,
            h = n.attributes.uv2,
            u = n.groups,
            d = n.drawRange;
          if (null !== r)
            if (Array.isArray(i))
              for (let n = 0, p = u.length; n < p; n++) {
                const p = u[n],
                  m = i[p.materialIndex];
                for (
                  let n = Math.max(p.start, d.start),
                    i = Math.min(
                      r.count,
                      Math.min(p.start + p.count, d.start + d.count)
                    );
                  n < i;
                  n += 3
                ) {
                  const i = r.getX(n),
                    u = r.getX(n + 1),
                    d = r.getX(n + 2);
                  (s = Ut(this, m, e, wt, a, o, l, c, h, i, u, d)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = p.materialIndex),
                      t.push(s));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  u = Math.min(r.count, d.start + d.count);
                n < u;
                n += 3
              ) {
                const u = r.getX(n),
                  d = r.getX(n + 1),
                  p = r.getX(n + 2);
                (s = Ut(this, i, e, wt, a, o, l, c, h, u, d, p)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
              }
            }
          else if (void 0 !== a)
            if (Array.isArray(i))
              for (let n = 0, r = u.length; n < r; n++) {
                const r = u[n],
                  p = i[r.materialIndex];
                for (
                  let n = Math.max(r.start, d.start),
                    i = Math.min(
                      a.count,
                      Math.min(r.start + r.count, d.start + d.count)
                    );
                  n < i;
                  n += 3
                ) {
                  (s = Ut(this, p, e, wt, a, o, l, c, h, n, n + 1, n + 2)),
                    s &&
                      ((s.faceIndex = Math.floor(n / 3)),
                      (s.face.materialIndex = r.materialIndex),
                      t.push(s));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  r = Math.min(a.count, d.start + d.count);
                n < r;
                n += 3
              ) {
                (s = Ut(this, i, e, wt, a, o, l, c, h, n, n + 1, n + 2)),
                  s && ((s.faceIndex = Math.floor(n / 3)), t.push(s));
              }
            }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
    }
    function Ut(e, t, n, i, r, s, a, o, l, c, h, u) {
      St.fromBufferAttribute(r, c),
        Tt.fromBufferAttribute(r, h),
        Et.fromBufferAttribute(r, u);
      const d = e.morphTargetInfluences;
      if (s && d) {
        Ct.set(0, 0, 0), Pt.set(0, 0, 0), It.set(0, 0, 0);
        for (let e = 0, t = s.length; e < t; e++) {
          const t = d[e],
            n = s[e];
          0 !== t &&
            (At.fromBufferAttribute(n, c),
            Lt.fromBufferAttribute(n, h),
            Rt.fromBufferAttribute(n, u),
            a
              ? (Ct.addScaledVector(At, t),
                Pt.addScaledVector(Lt, t),
                It.addScaledVector(Rt, t))
              : (Ct.addScaledVector(At.sub(St), t),
                Pt.addScaledVector(Lt.sub(Tt), t),
                It.addScaledVector(Rt.sub(Et), t)));
        }
        St.add(Ct), Tt.add(Pt), Et.add(It);
      }
      e.isSkinnedMesh &&
        (e.boneTransform(c, St),
        e.boneTransform(h, Tt),
        e.boneTransform(u, Et));
      const p = (function (e, t, n, i, r, s, a, o) {
        let l;
        if (
          ((l =
            1 === t.side
              ? i.intersectTriangle(a, s, r, !0, o)
              : i.intersectTriangle(r, s, a, 2 !== t.side, o)),
          null === l)
        )
          return null;
        Ft.copy(o), Ft.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(Ft);
        return c < n.near || c > n.far
          ? null
          : { distance: c, point: Ft.clone(), object: e };
      })(e, t, n, i, St, Tt, Et, zt);
      if (p) {
        o &&
          (Dt.fromBufferAttribute(o, c),
          Nt.fromBufferAttribute(o, h),
          Ot.fromBufferAttribute(o, u),
          (p.uv = Ze.getUV(zt, St, Tt, Et, Dt, Nt, Ot, new M()))),
          l &&
            (Dt.fromBufferAttribute(l, c),
            Nt.fromBufferAttribute(l, h),
            Ot.fromBufferAttribute(l, u),
            (p.uv2 = Ze.getUV(zt, St, Tt, Et, Dt, Nt, Ot, new M())));
        const e = { a: c, b: h, c: u, normal: new F(), materialIndex: 0 };
        Ze.getNormal(St, Tt, Et, e.normal), (p.face = e);
      }
      return p;
    }
    Bt.prototype.isMesh = !0;
    class Ht extends yt {
      constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
        super(),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s,
          });
        const a = this;
        (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
        const o = [],
          l = [],
          c = [],
          h = [];
        let u = 0,
          d = 0;
        function p(e, t, n, i, r, s, p, m, f, g, v) {
          const _ = s / f,
            x = p / g,
            y = s / 2,
            b = p / 2,
            w = m / 2,
            M = f + 1,
            S = g + 1;
          let T = 0,
            E = 0;
          const A = new F();
          for (let s = 0; s < S; s++) {
            const a = s * x - b;
            for (let o = 0; o < M; o++) {
              const u = o * _ - y;
              (A[e] = u * i),
                (A[t] = a * r),
                (A[n] = w),
                l.push(A.x, A.y, A.z),
                (A[e] = 0),
                (A[t] = 0),
                (A[n] = m > 0 ? 1 : -1),
                c.push(A.x, A.y, A.z),
                h.push(o / f),
                h.push(1 - s / g),
                (T += 1);
            }
          }
          for (let e = 0; e < g; e++)
            for (let t = 0; t < f; t++) {
              const n = u + t + M * e,
                i = u + t + M * (e + 1),
                r = u + (t + 1) + M * (e + 1),
                s = u + (t + 1) + M * e;
              o.push(n, i, s), o.push(i, r, s), (E += 6);
            }
          a.addGroup(d, E, v), (d += E), (u += T);
        }
        p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
          p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
          p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
          p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
          p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
          p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
          this.setIndex(o),
          this.setAttribute("position", new dt(l, 3)),
          this.setAttribute("normal", new dt(c, 3)),
          this.setAttribute("uv", new dt(h, 2));
      }
      static fromJSON(e) {
        return new Ht(
          e.width,
          e.height,
          e.depth,
          e.widthSegments,
          e.heightSegments,
          e.depthSegments
        );
      }
    }
    function kt(e) {
      const t = {};
      for (const n in e) {
        t[n] = {};
        for (const i in e[n]) {
          const r = e[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture ||
            r.isQuaternion)
            ? (t[n][i] = r.clone())
            : Array.isArray(r)
            ? (t[n][i] = r.slice())
            : (t[n][i] = r);
        }
      }
      return t;
    }
    function Gt(e) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const i = kt(e[n]);
        for (const e in i) t[e] = i[e];
      }
      return t;
    }
    const Vt = { clone: kt, merge: Gt };
    class Wt extends Qe {
      constructor(e) {
        super(),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(e));
      }
      copy(e) {
        return (
          super.copy(e),
          (this.fragmentShader = e.fragmentShader),
          (this.vertexShader = e.vertexShader),
          (this.uniforms = kt(e.uniforms)),
          (this.defines = Object.assign({}, e.defines)),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.lights = e.lights),
          (this.clipping = e.clipping),
          (this.extensions = Object.assign({}, e.extensions)),
          (this.glslVersion = e.glslVersion),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const n in this.uniforms) {
          const i = this.uniforms[n].value;
          i && i.isTexture
            ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
            : i && i.isColor
            ? (t.uniforms[n] = { type: "c", value: i.getHex() })
            : i && i.isVector2
            ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
            : i && i.isVector3
            ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
            : i && i.isVector4
            ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
            : i && i.isMatrix3
            ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
            : i && i.isMatrix4
            ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
            : (t.uniforms[n] = { value: i });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          (t.vertexShader = this.vertexShader),
          (t.fragmentShader = this.fragmentShader);
        const n = {};
        for (const e in this.extensions)
          !0 === this.extensions[e] && (n[e] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t;
      }
    }
    Wt.prototype.isShaderMaterial = !0;
    class jt extends Ue {
      constructor() {
        super(),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new me()),
          (this.projectionMatrix = new me()),
          (this.projectionMatrixInverse = new me());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    jt.prototype.isCamera = !0;
    class qt extends jt {
      constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
        super(),
          (this.type = "PerspectiveCamera"),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = n),
          (this.far = i),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      }
      setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = 2 * m * Math.atan(t)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const e = Math.tan(0.5 * p * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      }
      getEffectiveFOV() {
        return 2 * m * Math.atan(Math.tan(0.5 * p * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, n, i, r, s) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(0.5 * p * this.fov)) / this.zoom,
          n = 2 * t,
          i = this.aspect * n,
          r = -0.5 * i;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
          const e = s.fullWidth,
            a = s.fullHeight;
          (r += (s.offsetX * i) / e),
            (t -= (s.offsetY * n) / a),
            (i *= s.width / e),
            (n *= s.height / a);
        }
        const a = this.filmOffset;
        0 !== a && (r += (e * a) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            t,
            t - n,
            e,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      }
    }
    qt.prototype.isPerspectiveCamera = !0;
    class Xt extends Ue {
      constructor(e, t, n) {
        if (
          (super(),
          (this.type = "CubeCamera"),
          !0 !== n.isWebGLCubeRenderTarget)
        )
          return void console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
        this.renderTarget = n;
        const i = new qt(90, 1, e, t);
        (i.layers = this.layers),
          i.up.set(0, -1, 0),
          i.lookAt(new F(1, 0, 0)),
          this.add(i);
        const r = new qt(90, 1, e, t);
        (r.layers = this.layers),
          r.up.set(0, -1, 0),
          r.lookAt(new F(-1, 0, 0)),
          this.add(r);
        const s = new qt(90, 1, e, t);
        (s.layers = this.layers),
          s.up.set(0, 0, 1),
          s.lookAt(new F(0, 1, 0)),
          this.add(s);
        const a = new qt(90, 1, e, t);
        (a.layers = this.layers),
          a.up.set(0, 0, -1),
          a.lookAt(new F(0, -1, 0)),
          this.add(a);
        const o = new qt(90, 1, e, t);
        (o.layers = this.layers),
          o.up.set(0, -1, 0),
          o.lookAt(new F(0, 0, 1)),
          this.add(o);
        const l = new qt(90, 1, e, t);
        (l.layers = this.layers),
          l.up.set(0, -1, 0),
          l.lookAt(new F(0, 0, -1)),
          this.add(l);
      }
      update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
          [i, r, s, a, o, l] = this.children,
          c = e.xr.enabled,
          h = e.getRenderTarget();
        e.xr.enabled = !1;
        const u = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          e.setRenderTarget(n, 0),
          e.render(t, i),
          e.setRenderTarget(n, 1),
          e.render(t, r),
          e.setRenderTarget(n, 2),
          e.render(t, s),
          e.setRenderTarget(n, 3),
          e.render(t, a),
          e.setRenderTarget(n, 4),
          e.render(t, o),
          (n.texture.generateMipmaps = u),
          e.setRenderTarget(n, 5),
          e.render(t, l),
          e.setRenderTarget(h),
          (e.xr.enabled = c);
      }
    }
    class Yt extends P {
      constructor(e, t, n, i, r, s, a, o, l, c) {
        super(
          (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : 301),
          n,
          i,
          r,
          s,
          a,
          o,
          l,
          c
        ),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    }
    Yt.prototype.isCubeTexture = !0;
    class Jt extends N {
      constructor(e, t, n) {
        Number.isInteger(t) &&
          (console.warn(
            "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
          ),
          (t = n)),
          super(e, e, t),
          (t = t || {}),
          (this.texture = new Yt(
            void 0,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps =
            void 0 !== t.generateMipmaps && t.generateMipmaps),
          (this.texture.minFilter =
            void 0 !== t.minFilter ? t.minFilter : 1006),
          (this.texture._needsFlipEnvMap = !1);
      }
      fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
          (this.texture.format = 1023),
          (this.texture.encoding = t.encoding),
          (this.texture.generateMipmaps = t.generateMipmaps),
          (this.texture.minFilter = t.minFilter),
          (this.texture.magFilter = t.magFilter);
        const n = {
            uniforms: { tEquirect: { value: null } },
            vertexShader:
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader:
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
          },
          i = new Ht(5, 5, 5),
          r = new Wt({
            name: "CubemapFromEquirect",
            uniforms: kt(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: 1,
            blending: 0,
          });
        r.uniforms.tEquirect.value = t;
        const s = new Bt(i, r),
          a = t.minFilter;
        1008 === t.minFilter && (t.minFilter = 1006);
        return (
          new Xt(1, 10, this).update(e, s),
          (t.minFilter = a),
          s.geometry.dispose(),
          s.material.dispose(),
          this
        );
      }
      clear(e, t, n, i) {
        const r = e.getRenderTarget();
        for (let r = 0; r < 6; r++)
          e.setRenderTarget(this, r), e.clear(t, n, i);
        e.setRenderTarget(r);
      }
    }
    Jt.prototype.isWebGLCubeRenderTarget = !0;
    const Zt = new F(),
      Kt = new F(),
      Qt = new S();
    class $t {
      constructor(e = new F(1, 0, 0), t = 0) {
        (this.normal = e), (this.constant = t);
      }
      set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
      }
      setComponents(e, t, n, i) {
        return this.normal.set(e, t, n), (this.constant = i), this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
      }
      setFromCoplanarPoints(e, t, n) {
        const i = Zt.subVectors(n, t).cross(Kt.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
      }
      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return t
          .copy(this.normal)
          .multiplyScalar(-this.distanceToPoint(e))
          .add(e);
      }
      intersectLine(e, t) {
        const n = e.delta(Zt),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start);
      }
      intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
          n = this.distanceToPoint(e.end);
        return (t < 0 && n > 0) || (n < 0 && t > 0);
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(e, t) {
        const n = t || Qt.getNormalMatrix(e),
          i = this.coplanarPoint(Zt).applyMatrix4(e),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      }
      translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    $t.prototype.isPlane = !0;
    const en = new se(),
      tn = new F();
    class nn {
      constructor(
        e = new $t(),
        t = new $t(),
        n = new $t(),
        i = new $t(),
        r = new $t(),
        s = new $t()
      ) {
        this.planes = [e, t, n, i, r, s];
      }
      set(e, t, n, i, r, s) {
        const a = this.planes;
        return (
          a[0].copy(e),
          a[1].copy(t),
          a[2].copy(n),
          a[3].copy(i),
          a[4].copy(r),
          a[5].copy(s),
          this
        );
      }
      copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this;
      }
      setFromProjectionMatrix(e) {
        const t = this.planes,
          n = e.elements,
          i = n[0],
          r = n[1],
          s = n[2],
          a = n[3],
          o = n[4],
          l = n[5],
          c = n[6],
          h = n[7],
          u = n[8],
          d = n[9],
          p = n[10],
          m = n[11],
          f = n[12],
          g = n[13],
          v = n[14],
          _ = n[15];
        return (
          t[0].setComponents(a - i, h - o, m - u, _ - f).normalize(),
          t[1].setComponents(a + i, h + o, m + u, _ + f).normalize(),
          t[2].setComponents(a + r, h + l, m + d, _ + g).normalize(),
          t[3].setComponents(a - r, h - l, m - d, _ - g).normalize(),
          t[4].setComponents(a - s, h - c, m - p, _ - v).normalize(),
          t[5].setComponents(a + s, h + c, m + p, _ + v).normalize(),
          this
        );
      }
      intersectsObject(e) {
        const t = e.geometry;
        return (
          null === t.boundingSphere && t.computeBoundingSphere(),
          en.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
          this.intersectsSphere(en)
        );
      }
      intersectsSprite(e) {
        return (
          en.center.set(0, 0, 0),
          (en.radius = 0.7071067811865476),
          en.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(en)
        );
      }
      intersectsSphere(e) {
        const t = this.planes,
          n = e.center,
          i = -e.radius;
        for (let e = 0; e < 6; e++) {
          if (t[e].distanceToPoint(n) < i) return !1;
        }
        return !0;
      }
      intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
          const i = t[n];
          if (
            ((tn.x = i.normal.x > 0 ? e.max.x : e.min.x),
            (tn.y = i.normal.y > 0 ? e.max.y : e.min.y),
            (tn.z = i.normal.z > 0 ? e.max.z : e.min.z),
            i.distanceToPoint(tn) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    function rn() {
      let e = null,
        t = !1,
        n = null,
        i = null;
      function r(t, s) {
        n(t, s), (i = e.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== t &&
            null !== n &&
            ((i = e.requestAnimationFrame(r)), (t = !0));
        },
        stop: function () {
          e.cancelAnimationFrame(i), (t = !1);
        },
        setAnimationLoop: function (e) {
          n = e;
        },
        setContext: function (t) {
          e = t;
        },
      };
    }
    function sn(e, t) {
      const n = t.isWebGL2,
        i = new WeakMap();
      return {
        get: function (e) {
          return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
        },
        remove: function (t) {
          t.isInterleavedBufferAttribute && (t = t.data);
          const n = i.get(t);
          n && (e.deleteBuffer(n.buffer), i.delete(t));
        },
        update: function (t, r) {
          if (t.isGLBufferAttribute) {
            const e = i.get(t);
            return void (
              (!e || e.version < t.version) &&
              i.set(t, {
                buffer: t.buffer,
                type: t.type,
                bytesPerElement: t.elementSize,
                version: t.version,
              })
            );
          }
          t.isInterleavedBufferAttribute && (t = t.data);
          const s = i.get(t);
          void 0 === s
            ? i.set(
                t,
                (function (t, i) {
                  const r = t.array,
                    s = t.usage,
                    a = e.createBuffer();
                  e.bindBuffer(i, a),
                    e.bufferData(i, r, s),
                    t.onUploadCallback();
                  let o = 5126;
                  return (
                    r instanceof Float32Array
                      ? (o = 5126)
                      : r instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : r instanceof Uint16Array
                      ? t.isFloat16BufferAttribute
                        ? n
                          ? (o = 5131)
                          : console.warn(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            )
                        : (o = 5123)
                      : r instanceof Int16Array
                      ? (o = 5122)
                      : r instanceof Uint32Array
                      ? (o = 5125)
                      : r instanceof Int32Array
                      ? (o = 5124)
                      : r instanceof Int8Array
                      ? (o = 5120)
                      : (r instanceof Uint8Array ||
                          r instanceof Uint8ClampedArray) &&
                        (o = 5121),
                    {
                      buffer: a,
                      type: o,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: t.version,
                    }
                  );
                })(t, r)
              )
            : s.version < t.version &&
              (!(function (t, i, r) {
                const s = i.array,
                  a = i.updateRange;
                e.bindBuffer(r, t),
                  -1 === a.count
                    ? e.bufferSubData(r, 0, s)
                    : (n
                        ? e.bufferSubData(
                            r,
                            a.offset * s.BYTES_PER_ELEMENT,
                            s,
                            a.offset,
                            a.count
                          )
                        : e.bufferSubData(
                            r,
                            a.offset * s.BYTES_PER_ELEMENT,
                            s.subarray(a.offset, a.offset + a.count)
                          ),
                      (a.count = -1));
              })(s.buffer, t, r),
              (s.version = t.version));
        },
      };
    }
    class an extends yt {
      constructor(e = 1, t = 1, n = 1, i = 1) {
        super(),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i,
          });
        const r = e / 2,
          s = t / 2,
          a = Math.floor(n),
          o = Math.floor(i),
          l = a + 1,
          c = o + 1,
          h = e / a,
          u = t / o,
          d = [],
          p = [],
          m = [],
          f = [];
        for (let e = 0; e < c; e++) {
          const t = e * u - s;
          for (let n = 0; n < l; n++) {
            const i = n * h - r;
            p.push(i, -t, 0), m.push(0, 0, 1), f.push(n / a), f.push(1 - e / o);
          }
        }
        for (let e = 0; e < o; e++)
          for (let t = 0; t < a; t++) {
            const n = t + l * e,
              i = t + l * (e + 1),
              r = t + 1 + l * (e + 1),
              s = t + 1 + l * e;
            d.push(n, i, s), d.push(i, r, s);
          }
        this.setIndex(d),
          this.setAttribute("position", new dt(p, 3)),
          this.setAttribute("normal", new dt(m, 3)),
          this.setAttribute("uv", new dt(f, 2));
      }
      static fromJSON(e) {
        return new an(e.width, e.height, e.widthSegments, e.heightSegments);
      }
    }
    const on = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment:
          "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin:
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex:
          "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        output_fragment:
          "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment:
          "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
        transmission_pars_fragment:
          "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      },
      ln = {
        common: {
          diffuse: { value: new st(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new S() },
          uv2Transform: { value: new S() },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          ior: { value: 1.5 },
          refractionRatio: { value: 0.98 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new M(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new st(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: { direction: {}, color: {} },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: { color: {}, position: {}, decay: {}, distance: {} },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
          ltc_1: { value: null },
          ltc_2: { value: null },
        },
        points: {
          diffuse: { value: new st(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new S() },
        },
        sprite: {
          diffuse: { value: new st(16777215) },
          opacity: { value: 1 },
          center: { value: new M(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new S() },
        },
      },
      cn = {
        basic: {
          uniforms: Gt([
            ln.common,
            ln.specularmap,
            ln.envmap,
            ln.aomap,
            ln.lightmap,
            ln.fog,
          ]),
          vertexShader: on.meshbasic_vert,
          fragmentShader: on.meshbasic_frag,
        },
        lambert: {
          uniforms: Gt([
            ln.common,
            ln.specularmap,
            ln.envmap,
            ln.aomap,
            ln.lightmap,
            ln.emissivemap,
            ln.fog,
            ln.lights,
            { emissive: { value: new st(0) } },
          ]),
          vertexShader: on.meshlambert_vert,
          fragmentShader: on.meshlambert_frag,
        },
        phong: {
          uniforms: Gt([
            ln.common,
            ln.specularmap,
            ln.envmap,
            ln.aomap,
            ln.lightmap,
            ln.emissivemap,
            ln.bumpmap,
            ln.normalmap,
            ln.displacementmap,
            ln.fog,
            ln.lights,
            {
              emissive: { value: new st(0) },
              specular: { value: new st(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: on.meshphong_vert,
          fragmentShader: on.meshphong_frag,
        },
        standard: {
          uniforms: Gt([
            ln.common,
            ln.envmap,
            ln.aomap,
            ln.lightmap,
            ln.emissivemap,
            ln.bumpmap,
            ln.normalmap,
            ln.displacementmap,
            ln.roughnessmap,
            ln.metalnessmap,
            ln.fog,
            ln.lights,
            {
              emissive: { value: new st(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: on.meshphysical_vert,
          fragmentShader: on.meshphysical_frag,
        },
        toon: {
          uniforms: Gt([
            ln.common,
            ln.aomap,
            ln.lightmap,
            ln.emissivemap,
            ln.bumpmap,
            ln.normalmap,
            ln.displacementmap,
            ln.gradientmap,
            ln.fog,
            ln.lights,
            { emissive: { value: new st(0) } },
          ]),
          vertexShader: on.meshtoon_vert,
          fragmentShader: on.meshtoon_frag,
        },
        matcap: {
          uniforms: Gt([
            ln.common,
            ln.bumpmap,
            ln.normalmap,
            ln.displacementmap,
            ln.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: on.meshmatcap_vert,
          fragmentShader: on.meshmatcap_frag,
        },
        points: {
          uniforms: Gt([ln.points, ln.fog]),
          vertexShader: on.points_vert,
          fragmentShader: on.points_frag,
        },
        dashed: {
          uniforms: Gt([
            ln.common,
            ln.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: on.linedashed_vert,
          fragmentShader: on.linedashed_frag,
        },
        depth: {
          uniforms: Gt([ln.common, ln.displacementmap]),
          vertexShader: on.depth_vert,
          fragmentShader: on.depth_frag,
        },
        normal: {
          uniforms: Gt([
            ln.common,
            ln.bumpmap,
            ln.normalmap,
            ln.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: on.meshnormal_vert,
          fragmentShader: on.meshnormal_frag,
        },
        sprite: {
          uniforms: Gt([ln.sprite, ln.fog]),
          vertexShader: on.sprite_vert,
          fragmentShader: on.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new S() }, t2D: { value: null } },
          vertexShader: on.background_vert,
          fragmentShader: on.background_frag,
        },
        cube: {
          uniforms: Gt([ln.envmap, { opacity: { value: 1 } }]),
          vertexShader: on.cube_vert,
          fragmentShader: on.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: on.equirect_vert,
          fragmentShader: on.equirect_frag,
        },
        distanceRGBA: {
          uniforms: Gt([
            ln.common,
            ln.displacementmap,
            {
              referencePosition: { value: new F() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: on.distanceRGBA_vert,
          fragmentShader: on.distanceRGBA_frag,
        },
        shadow: {
          uniforms: Gt([
            ln.lights,
            ln.fog,
            { color: { value: new st(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: on.shadow_vert,
          fragmentShader: on.shadow_frag,
        },
      };
    function hn(e, t, n, i, r) {
      const s = new st(0);
      let a,
        o,
        l = 0,
        c = null,
        h = 0,
        u = null;
      function d(e, t) {
        n.buffers.color.setClear(e.r, e.g, e.b, t, r);
      }
      return {
        getClearColor: function () {
          return s;
        },
        setClearColor: function (e, t = 1) {
          s.set(e), (l = t), d(s, l);
        },
        getClearAlpha: function () {
          return l;
        },
        setClearAlpha: function (e) {
          (l = e), d(s, l);
        },
        render: function (n, r) {
          let p = !1,
            m = !0 === r.isScene ? r.background : null;
          m && m.isTexture && (m = t.get(m));
          const f = e.xr,
            g = f.getSession && f.getSession();
          g && "additive" === g.environmentBlendMode && (m = null),
            null === m ? d(s, l) : m && m.isColor && (d(m, 1), (p = !0)),
            (e.autoClear || p) &&
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            m && (m.isCubeTexture || 306 === m.mapping)
              ? (void 0 === o &&
                  ((o = new Bt(
                    new Ht(1, 1, 1),
                    new Wt({
                      name: "BackgroundCubeMaterial",
                      uniforms: kt(cn.cube.uniforms),
                      vertexShader: cn.cube.vertexShader,
                      fragmentShader: cn.cube.fragmentShader,
                      side: 1,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  o.geometry.deleteAttribute("normal"),
                  o.geometry.deleteAttribute("uv"),
                  (o.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(o.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  i.update(o)),
                (o.material.uniforms.envMap.value = m),
                (o.material.uniforms.flipEnvMap.value =
                  m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1),
                (c === m && h === m.version && u === e.toneMapping) ||
                  ((o.material.needsUpdate = !0),
                  (c = m),
                  (h = m.version),
                  (u = e.toneMapping)),
                n.unshift(o, o.geometry, o.material, 0, 0, null))
              : m &&
                m.isTexture &&
                (void 0 === a &&
                  ((a = new Bt(
                    new an(2, 2),
                    new Wt({
                      name: "BackgroundMaterial",
                      uniforms: kt(cn.background.uniforms),
                      vertexShader: cn.background.vertexShader,
                      fragmentShader: cn.background.fragmentShader,
                      side: 0,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  i.update(a)),
                (a.material.uniforms.t2D.value = m),
                !0 === m.matrixAutoUpdate && m.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(m.matrix),
                (c === m && h === m.version && u === e.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (c = m),
                  (h = m.version),
                  (u = e.toneMapping)),
                n.unshift(a, a.geometry, a.material, 0, 0, null));
        },
      };
    }
    function un(e, t, n, i) {
      const r = e.getParameter(34921),
        s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
        a = i.isWebGL2 || null !== s,
        o = {},
        l = d(null);
      let c = l;
      function h(t) {
        return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t);
      }
      function u(t) {
        return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t);
      }
      function d(e) {
        const t = [],
          n = [],
          i = [];
        for (let e = 0; e < r; e++) (t[e] = 0), (n[e] = 0), (i[e] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: t,
          enabledAttributes: n,
          attributeDivisors: i,
          object: e,
          attributes: {},
          index: null,
        };
      }
      function p() {
        const e = c.newAttributes;
        for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
      }
      function m(e) {
        f(e, 0);
      }
      function f(n, r) {
        const s = c.newAttributes,
          a = c.enabledAttributes,
          o = c.attributeDivisors;
        if (
          ((s[n] = 1),
          0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
          o[n] !== r)
        ) {
          (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
            (o[n] = r);
        }
      }
      function g() {
        const t = c.newAttributes,
          n = c.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
          n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
      }
      function v(t, n, r, s, a, o) {
        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
          ? e.vertexAttribPointer(t, n, r, s, a, o)
          : e.vertexAttribIPointer(t, n, r, a, o);
      }
      function _() {
        x(), c !== l && ((c = l), h(c.object));
      }
      function x() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (r, l, u, _, x) {
          let y = !1;
          if (a) {
            const t = (function (t, n, r) {
              const a = !0 === r.wireframe;
              let l = o[t.id];
              void 0 === l && ((l = {}), (o[t.id] = l));
              let c = l[n.id];
              void 0 === c && ((c = {}), (l[n.id] = c));
              let h = c[a];
              void 0 === h &&
                ((h = d(
                  i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()
                )),
                (c[a] = h));
              return h;
            })(_, u, l);
            c !== t && ((c = t), h(c.object)),
              (y = (function (e, t) {
                const n = c.attributes,
                  i = e.attributes;
                let r = 0;
                for (const e in i) {
                  const t = n[e],
                    s = i[e];
                  if (void 0 === t) return !0;
                  if (t.attribute !== s) return !0;
                  if (t.data !== s.data) return !0;
                  r++;
                }
                return c.attributesNum !== r || c.index !== t;
              })(_, x)),
              y &&
                (function (e, t) {
                  const n = {},
                    i = e.attributes;
                  let r = 0;
                  for (const e in i) {
                    const t = i[e],
                      s = {};
                    (s.attribute = t),
                      t.data && (s.data = t.data),
                      (n[e] = s),
                      r++;
                  }
                  (c.attributes = n), (c.attributesNum = r), (c.index = t);
                })(_, x);
          } else {
            const e = !0 === l.wireframe;
            (c.geometry === _.id && c.program === u.id && c.wireframe === e) ||
              ((c.geometry = _.id),
              (c.program = u.id),
              (c.wireframe = e),
              (y = !0));
          }
          !0 === r.isInstancedMesh && (y = !0),
            null !== x && n.update(x, 34963),
            y &&
              (!(function (r, s, a, o) {
                if (
                  !1 === i.isWebGL2 &&
                  (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                  null === t.get("ANGLE_instanced_arrays")
                )
                  return;
                p();
                const l = o.attributes,
                  c = a.getAttributes(),
                  h = s.defaultAttributeValues;
                for (const t in c) {
                  const i = c[t];
                  if (i.location >= 0) {
                    let s = l[t];
                    if (
                      (void 0 === s &&
                        ("instanceMatrix" === t &&
                          r.instanceMatrix &&
                          (s = r.instanceMatrix),
                        "instanceColor" === t &&
                          r.instanceColor &&
                          (s = r.instanceColor)),
                      void 0 !== s)
                    ) {
                      const t = s.normalized,
                        a = s.itemSize,
                        l = n.get(s);
                      if (void 0 === l) continue;
                      const c = l.buffer,
                        h = l.type,
                        u = l.bytesPerElement;
                      if (s.isInterleavedBufferAttribute) {
                        const n = s.data,
                          l = n.stride,
                          d = s.offset;
                        if (n && n.isInstancedInterleavedBuffer) {
                          for (let e = 0; e < i.locationSize; e++)
                            f(i.location + e, n.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === o._maxInstanceCount &&
                            (o._maxInstanceCount =
                              n.meshPerAttribute * n.count);
                        } else
                          for (let e = 0; e < i.locationSize; e++)
                            m(i.location + e);
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < i.locationSize; e++)
                          v(
                            i.location + e,
                            a / i.locationSize,
                            h,
                            t,
                            l * u,
                            (d + (a / i.locationSize) * e) * u
                          );
                      } else {
                        if (s.isInstancedBufferAttribute) {
                          for (let e = 0; e < i.locationSize; e++)
                            f(i.location + e, s.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === o._maxInstanceCount &&
                            (o._maxInstanceCount =
                              s.meshPerAttribute * s.count);
                        } else
                          for (let e = 0; e < i.locationSize; e++)
                            m(i.location + e);
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < i.locationSize; e++)
                          v(
                            i.location + e,
                            a / i.locationSize,
                            h,
                            t,
                            a * u,
                            (a / i.locationSize) * e * u
                          );
                      }
                    } else if (void 0 !== h) {
                      const n = h[t];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            e.vertexAttrib2fv(i.location, n);
                            break;
                          case 3:
                            e.vertexAttrib3fv(i.location, n);
                            break;
                          case 4:
                            e.vertexAttrib4fv(i.location, n);
                            break;
                          default:
                            e.vertexAttrib1fv(i.location, n);
                        }
                    }
                  }
                }
                g();
              })(r, l, u, _),
              null !== x && e.bindBuffer(34963, n.get(x).buffer));
        },
        reset: _,
        resetDefaultState: x,
        dispose: function () {
          _();
          for (const e in o) {
            const t = o[e];
            for (const e in t) {
              const n = t[e];
              for (const e in n) u(n[e].object), delete n[e];
              delete t[e];
            }
            delete o[e];
          }
        },
        releaseStatesOfGeometry: function (e) {
          if (void 0 === o[e.id]) return;
          const t = o[e.id];
          for (const e in t) {
            const n = t[e];
            for (const e in n) u(n[e].object), delete n[e];
            delete t[e];
          }
          delete o[e.id];
        },
        releaseStatesOfProgram: function (e) {
          for (const t in o) {
            const n = o[t];
            if (void 0 === n[e.id]) continue;
            const i = n[e.id];
            for (const e in i) u(i[e].object), delete i[e];
            delete n[e.id];
          }
        },
        initAttributes: p,
        enableAttribute: m,
        disableUnusedAttributes: g,
      };
    }
    function dn(e, t, n, i) {
      const r = i.isWebGL2;
      let s;
      (this.setMode = function (e) {
        s = e;
      }),
        (this.render = function (t, i) {
          e.drawArrays(s, t, i), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, a, o) {
          if (0 === o) return;
          let l, c;
          if (r) (l = e), (c = "drawArraysInstanced");
          else if (
            ((l = t.get("ANGLE_instanced_arrays")),
            (c = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[c](s, i, a, o), n.update(a, s, o);
        });
    }
    function pn(e, t, n) {
      let i;
      function r(t) {
        if ("highp" === t) {
          if (
            e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          t = "mediump";
        }
        return "mediump" === t &&
          e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          e.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      const s =
        ("undefined" != typeof WebGL2RenderingContext &&
          e instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          e instanceof WebGL2ComputeRenderingContext);
      let a = void 0 !== n.precision ? n.precision : "highp";
      const o = r(a);
      o !== a &&
        (console.warn(
          "THREE.WebGLRenderer:",
          a,
          "not supported, using",
          o,
          "instead."
        ),
        (a = o));
      const l = s || t.has("WEBGL_draw_buffers"),
        c = !0 === n.logarithmicDepthBuffer,
        h = e.getParameter(34930),
        u = e.getParameter(35660),
        d = e.getParameter(3379),
        p = e.getParameter(34076),
        m = e.getParameter(34921),
        f = e.getParameter(36347),
        g = e.getParameter(36348),
        v = e.getParameter(36349),
        _ = u > 0,
        x = s || t.has("OES_texture_float");
      return {
        isWebGL2: s,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          if (!0 === t.has("EXT_texture_filter_anisotropic")) {
            const n = t.get("EXT_texture_filter_anisotropic");
            i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else i = 0;
          return i;
        },
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: h,
        maxVertexTextures: u,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: m,
        maxVertexUniforms: f,
        maxVaryings: g,
        maxFragmentUniforms: v,
        vertexTextures: _,
        floatFragmentTextures: x,
        floatVertexTextures: _ && x,
        maxSamples: s ? e.getParameter(36183) : 0,
      };
    }
    function mn(e) {
      const t = this;
      let n = null,
        i = 0,
        r = !1,
        s = !1;
      const a = new $t(),
        o = new S(),
        l = { value: null, needsUpdate: !1 };
      function c() {
        l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
          (t.numPlanes = i),
          (t.numIntersection = 0);
      }
      function h(e, n, i, r) {
        const s = null !== e ? e.length : 0;
        let c = null;
        if (0 !== s) {
          if (((c = l.value), !0 !== r || null === c)) {
            const t = i + 4 * s,
              r = n.matrixWorldInverse;
            o.getNormalMatrix(r),
              (null === c || c.length < t) && (c = new Float32Array(t));
            for (let t = 0, n = i; t !== s; ++t, n += 4)
              a.copy(e[t]).applyMatrix4(r, o),
                a.normal.toArray(c, n),
                (c[n + 3] = a.constant);
          }
          (l.value = c), (l.needsUpdate = !0);
        }
        return (t.numPlanes = s), (t.numIntersection = 0), c;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (e, t, s) {
          const a = 0 !== e.length || t || 0 !== i || r;
          return (r = t), (n = h(e, s, 0)), (i = e.length), a;
        }),
        (this.beginShadows = function () {
          (s = !0), h(null);
        }),
        (this.endShadows = function () {
          (s = !1), c();
        }),
        (this.setState = function (t, a, o) {
          const u = t.clippingPlanes,
            d = t.clipIntersection,
            p = t.clipShadows,
            m = e.get(t);
          if (!r || null === u || 0 === u.length || (s && !p))
            s ? h(null) : c();
          else {
            const e = s ? 0 : i,
              t = 4 * e;
            let r = m.clippingState || null;
            (l.value = r), (r = h(u, a, t, o));
            for (let e = 0; e !== t; ++e) r[e] = n[e];
            (m.clippingState = r),
              (this.numIntersection = d ? this.numPlanes : 0),
              (this.numPlanes += e);
          }
        });
    }
    function fn(e) {
      let t = new WeakMap();
      function n(e, t) {
        return (
          303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e
        );
      }
      function i(e) {
        const n = e.target;
        n.removeEventListener("dispose", i);
        const r = t.get(n);
        void 0 !== r && (t.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
            const s = r.mapping;
            if (303 === s || 304 === s) {
              if (t.has(r)) {
                return n(t.get(r).texture, r.mapping);
              }
              {
                const s = r.image;
                if (s && s.height > 0) {
                  const a = e.getRenderTarget(),
                    o = new Jt(s.height / 2);
                  return (
                    o.fromEquirectangularTexture(e, r),
                    t.set(r, o),
                    e.setRenderTarget(a),
                    r.addEventListener("dispose", i),
                    n(o.texture, r.mapping)
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    cn.physical = {
      uniforms: Gt([
        cn.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new M(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: new st(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 0 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: new M() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: new st(0) },
          specularIntensity: { value: 0 },
          specularIntensityMap: { value: null },
          specularColor: { value: new st(1, 1, 1) },
          specularColorMap: { value: null },
        },
      ]),
      vertexShader: on.meshphysical_vert,
      fragmentShader: on.meshphysical_frag,
    };
    class gn extends jt {
      constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
        super(),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = n),
          (this.bottom = i),
          (this.near = r),
          (this.far = s),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          this
        );
      }
      setViewOffset(e, t, n, i, r, s) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
        let r = n - e,
          s = n + e,
          a = i + t,
          o = i - t;
        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (r += e * this.view.offsetX),
            (s = r + e * this.view.width),
            (a -= t * this.view.offsetY),
            (o = a - t * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      }
    }
    gn.prototype.isOrthographicCamera = !0;
    class vn extends Wt {
      constructor(e) {
        super(e), (this.type = "RawShaderMaterial");
      }
    }
    vn.prototype.isRawShaderMaterial = !0;
    const _n = Math.pow(2, 8),
      xn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      yn = 5 + xn.length,
      bn = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
      wn = new gn(),
      { _lodPlanes: Mn, _sizeLods: Sn, _sigmas: Tn } = Dn(),
      En = new st();
    let An = null;
    const Ln = (1 + Math.sqrt(5)) / 2,
      Rn = 1 / Ln,
      Cn = [
        new F(1, 1, 1),
        new F(-1, 1, 1),
        new F(1, 1, -1),
        new F(-1, 1, -1),
        new F(0, Ln, Rn),
        new F(0, Ln, -Rn),
        new F(Rn, 0, Ln),
        new F(-Rn, 0, Ln),
        new F(Ln, Rn, 0),
        new F(-Ln, Rn, 0),
      ];
    class Pn {
      constructor(e) {
        (this._renderer = e),
          (this._pingPongRenderTarget = null),
          (this._blurMaterial = (function (e) {
            const t = new Float32Array(e),
              n = new F(0, 1, 0);
            return new vn({
              name: "SphericalGaussianBlur",
              defines: { n: e },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: t },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: n },
                inputEncoding: { value: bn[3e3] },
                outputEncoding: { value: bn[3e3] },
              },
              vertexShader: Bn(),
              fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Un()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(20)),
          (this._equirectShader = null),
          (this._cubemapShader = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(e, t = 0, n = 0.1, i = 100) {
        An = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return (
          this._sceneToCubeUV(e, n, i, r),
          t > 0 && this._blur(r, 0, 0, t),
          this._applyPMREM(r),
          this._cleanup(r),
          r
        );
      }
      fromEquirectangular(e) {
        return this._fromTexture(e);
      }
      fromCubemap(e) {
        return this._fromTexture(e);
      }
      compileCubemapShader() {
        null === this._cubemapShader &&
          ((this._cubemapShader = Fn()),
          this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader &&
          ((this._equirectShader = zn()),
          this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(),
          null !== this._cubemapShader && this._cubemapShader.dispose(),
          null !== this._equirectShader && this._equirectShader.dispose();
        for (let e = 0; e < Mn.length; e++) Mn[e].dispose();
      }
      _cleanup(e) {
        this._pingPongRenderTarget.dispose(),
          this._renderer.setRenderTarget(An),
          (e.scissorTest = !1),
          On(e, 0, 0, e.width, e.height);
      }
      _fromTexture(e) {
        An = this._renderer.getRenderTarget();
        const t = this._allocateTargets(e);
        return (
          this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
        );
      }
      _allocateTargets(e) {
        const t = {
            magFilter: 1003,
            minFilter: 1003,
            generateMipmaps: !1,
            type: 1009,
            format: 1023,
            encoding: In(e) ? e.encoding : 3002,
            depthBuffer: !1,
          },
          n = Nn(t);
        return (n.depthBuffer = !e), (this._pingPongRenderTarget = Nn(t)), n;
      }
      _compileMaterial(e) {
        const t = new Bt(Mn[0], e);
        this._renderer.compile(t, wn);
      }
      _sceneToCubeUV(e, t, n, i) {
        const r = new qt(90, 1, t, n),
          s = [1, -1, 1, 1, 1, 1],
          a = [1, 1, 1, -1, -1, -1],
          o = this._renderer,
          l = o.autoClear,
          c = o.outputEncoding,
          h = o.toneMapping;
        o.getClearColor(En),
          (o.toneMapping = 0),
          (o.outputEncoding = 3e3),
          (o.autoClear = !1);
        const u = new at({
            name: "PMREM.Background",
            side: 1,
            depthWrite: !1,
            depthTest: !1,
          }),
          d = new Bt(new Ht(), u);
        let p = !1;
        const m = e.background;
        m
          ? m.isColor && (u.color.copy(m), (e.background = null), (p = !0))
          : (u.color.copy(En), (p = !0));
        for (let t = 0; t < 6; t++) {
          const n = t % 3;
          0 == n
            ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
            : 1 == n
            ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
            : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])),
            On(i, n * _n, t > 2 ? _n : 0, _n, _n),
            o.setRenderTarget(i),
            p && o.render(d, r),
            o.render(e, r);
        }
        d.geometry.dispose(),
          d.material.dispose(),
          (o.toneMapping = h),
          (o.outputEncoding = c),
          (o.autoClear = l),
          (e.background = m);
      }
      _setEncoding(e, t) {
        e.value = bn[t.encoding];
      }
      _textureToCubeUV(e, t) {
        const n = this._renderer,
          i = 301 === e.mapping || 302 === e.mapping;
        i
          ? null == this._cubemapShader && (this._cubemapShader = Fn())
          : null == this._equirectShader && (this._equirectShader = zn());
        const r = i ? this._cubemapShader : this._equirectShader,
          s = new Bt(Mn[0], r),
          a = r.uniforms;
        (a.envMap.value = e),
          i || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
          this._setEncoding(a.inputEncoding, e),
          this._setEncoding(a.outputEncoding, t.texture),
          On(t, 0, 0, 3 * _n, 2 * _n),
          n.setRenderTarget(t),
          n.render(s, wn);
      }
      _applyPMREM(e) {
        const t = this._renderer,
          n = t.autoClear;
        t.autoClear = !1;
        for (let t = 1; t < yn; t++) {
          const n = Math.sqrt(Tn[t] * Tn[t] - Tn[t - 1] * Tn[t - 1]),
            i = Cn[(t - 1) % Cn.length];
          this._blur(e, t - 1, t, n, i);
        }
        t.autoClear = n;
      }
      _blur(e, t, n, i, r) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(e, s, t, n, i, "latitudinal", r),
          this._halfBlur(s, e, n, n, i, "longitudinal", r);
      }
      _halfBlur(e, t, n, i, r, s, a) {
        const o = this._renderer,
          l = this._blurMaterial;
        "latitudinal" !== s &&
          "longitudinal" !== s &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const c = new Bt(Mn[i], l),
          h = l.uniforms,
          u = Sn[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
          p = r / d,
          m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
        m > 20 &&
          console.warn(
            `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
          );
        const f = [];
        let g = 0;
        for (let e = 0; e < 20; ++e) {
          const t = e / p,
            n = Math.exp((-t * t) / 2);
          f.push(n), 0 == e ? (g += n) : e < m && (g += 2 * n);
        }
        for (let e = 0; e < f.length; e++) f[e] = f[e] / g;
        (h.envMap.value = e.texture),
          (h.samples.value = m),
          (h.weights.value = f),
          (h.latitudinal.value = "latitudinal" === s),
          a && (h.poleAxis.value = a),
          (h.dTheta.value = d),
          (h.mipInt.value = 8 - n),
          this._setEncoding(h.inputEncoding, e.texture),
          this._setEncoding(h.outputEncoding, e.texture);
        const v = Sn[i];
        On(
          t,
          3 * Math.max(0, _n - 2 * v),
          (0 === i ? 0 : 2 * _n) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
          3 * v,
          2 * v
        ),
          o.setRenderTarget(t),
          o.render(c, wn);
      }
    }
    function In(e) {
      return (
        void 0 !== e &&
        1009 === e.type &&
        (3e3 === e.encoding || 3001 === e.encoding || 3007 === e.encoding)
      );
    }
    function Dn() {
      const e = [],
        t = [],
        n = [];
      let i = 8;
      for (let r = 0; r < yn; r++) {
        const s = Math.pow(2, i);
        t.push(s);
        let a = 1 / s;
        r > 4 ? (a = xn[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);
        const o = 1 / (s - 1),
          l = -o / 2,
          c = 1 + o / 2,
          h = [l, l, c, l, c, c, l, l, c, c, l, c],
          u = 6,
          d = 6,
          p = 3,
          m = 2,
          f = 1,
          g = new Float32Array(p * d * u),
          v = new Float32Array(m * d * u),
          _ = new Float32Array(f * d * u);
        for (let e = 0; e < u; e++) {
          const t = ((e % 3) * 2) / 3 - 1,
            n = e > 2 ? 0 : -1,
            i = [
              t,
              n,
              0,
              t + 2 / 3,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n + 1,
              0,
            ];
          g.set(i, p * d * e), v.set(h, m * d * e);
          const r = [e, e, e, e, e, e];
          _.set(r, f * d * e);
        }
        const x = new yt();
        x.setAttribute("position", new ct(g, p)),
          x.setAttribute("uv", new ct(v, m)),
          x.setAttribute("faceIndex", new ct(_, f)),
          e.push(x),
          i > 4 && i--;
      }
      return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
    }
    function Nn(e) {
      const t = new N(3 * _n, 3 * _n, e);
      return (
        (t.texture.mapping = 306),
        (t.texture.name = "PMREM.cubeUv"),
        (t.scissorTest = !0),
        t
      );
    }
    function On(e, t, n, i, r) {
      e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r);
    }
    function zn() {
      const e = new M(1, 1);
      return new vn({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: { value: null },
          texelSize: { value: e },
          inputEncoding: { value: bn[3e3] },
          outputEncoding: { value: bn[3e3] },
        },
        vertexShader: Bn(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Un()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Fn() {
      return new vn({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: { value: null },
          inputEncoding: { value: bn[3e3] },
          outputEncoding: { value: bn[3e3] },
        },
        vertexShader: Bn(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Un()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function Bn() {
      return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
    }
    function Un() {
      return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
    }
    function Hn(e) {
      let t = new WeakMap(),
        n = null;
      function i(e) {
        const n = e.target;
        n.removeEventListener("dispose", i);
        const r = t.get(n);
        void 0 !== r && (t.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
            const s = r.mapping,
              a = 303 === s || 304 === s,
              o = 301 === s || 302 === s;
            if (a || o) {
              if (t.has(r)) return t.get(r).texture;
              {
                const s = r.image;
                if (
                  (a && s && s.height > 0) ||
                  (o &&
                    s &&
                    (function (e) {
                      let t = 0;
                      for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                      return 6 === t;
                    })(s))
                ) {
                  const s = e.getRenderTarget();
                  null === n && (n = new Pn(e));
                  const o = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                  return (
                    t.set(r, o),
                    e.setRenderTarget(s),
                    r.addEventListener("dispose", i),
                    o.texture
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
        },
      };
    }
    function kn(e) {
      const t = {};
      function n(n) {
        if (void 0 !== t[n]) return t[n];
        let i;
        switch (n) {
          case "WEBGL_depth_texture":
            i =
              e.getExtension("WEBGL_depth_texture") ||
              e.getExtension("MOZ_WEBGL_depth_texture") ||
              e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            i =
              e.getExtension("EXT_texture_filter_anisotropic") ||
              e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            i =
              e.getExtension("WEBGL_compressed_texture_s3tc") ||
              e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            i =
              e.getExtension("WEBGL_compressed_texture_pvrtc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            i = e.getExtension(n);
        }
        return (t[n] = i), i;
      }
      return {
        has: function (e) {
          return null !== n(e);
        },
        init: function (e) {
          e.isWebGL2
            ? n("EXT_color_buffer_float")
            : (n("WEBGL_depth_texture"),
              n("OES_texture_float"),
              n("OES_texture_half_float"),
              n("OES_texture_half_float_linear"),
              n("OES_standard_derivatives"),
              n("OES_element_index_uint"),
              n("OES_vertex_array_object"),
              n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture");
        },
        get: function (e) {
          const t = n(e);
          return (
            null === t &&
              console.warn(
                "THREE.WebGLRenderer: " + e + " extension not supported."
              ),
            t
          );
        },
      };
    }
    function Gn(e, t, n, i) {
      const r = {},
        s = new WeakMap();
      function a(e) {
        const o = e.target;
        null !== o.index && t.remove(o.index);
        for (const e in o.attributes) t.remove(o.attributes[e]);
        o.removeEventListener("dispose", a), delete r[o.id];
        const l = s.get(o);
        l && (t.remove(l), s.delete(o)),
          i.releaseStatesOfGeometry(o),
          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
          n.memory.geometries--;
      }
      function o(e) {
        const n = [],
          i = e.index,
          r = e.attributes.position;
        let a = 0;
        if (null !== i) {
          const e = i.array;
          a = i.version;
          for (let t = 0, i = e.length; t < i; t += 3) {
            const i = e[t + 0],
              r = e[t + 1],
              s = e[t + 2];
            n.push(i, r, r, s, s, i);
          }
        } else {
          const e = r.array;
          a = r.version;
          for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
            const e = t + 0,
              i = t + 1,
              r = t + 2;
            n.push(e, i, i, r, r, e);
          }
        }
        const o = new (T(n) > 65535 ? ut : ht)(n, 1);
        o.version = a;
        const l = s.get(e);
        l && t.remove(l), s.set(e, o);
      }
      return {
        get: function (e, t) {
          return (
            !0 === r[t.id] ||
              (t.addEventListener("dispose", a),
              (r[t.id] = !0),
              n.memory.geometries++),
            t
          );
        },
        update: function (e) {
          const n = e.attributes;
          for (const e in n) t.update(n[e], 34962);
          const i = e.morphAttributes;
          for (const e in i) {
            const n = i[e];
            for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962);
          }
        },
        getWireframeAttribute: function (e) {
          const t = s.get(e);
          if (t) {
            const n = e.index;
            null !== n && t.version < n.version && o(e);
          } else o(e);
          return s.get(e);
        },
      };
    }
    function Vn(e, t, n, i) {
      const r = i.isWebGL2;
      let s, a, o;
      (this.setMode = function (e) {
        s = e;
      }),
        (this.setIndex = function (e) {
          (a = e.type), (o = e.bytesPerElement);
        }),
        (this.render = function (t, i) {
          e.drawElements(s, i, a, t * o), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, l, c) {
          if (0 === c) return;
          let h, u;
          if (r) (h = e), (u = "drawElementsInstanced");
          else if (
            ((h = t.get("ANGLE_instanced_arrays")),
            (u = "drawElementsInstancedANGLE"),
            null === h)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          h[u](s, l, a, i * o, c), n.update(l, s, c);
        });
    }
    function Wn(e) {
      const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function () {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        },
        update: function (e, n, i) {
          switch ((t.calls++, n)) {
            case 4:
              t.triangles += i * (e / 3);
              break;
            case 1:
              t.lines += i * (e / 2);
              break;
            case 3:
              t.lines += i * (e - 1);
              break;
            case 2:
              t.lines += i * e;
              break;
            case 0:
              t.points += i * e;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }
    class jn extends P {
      constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: e, width: t, height: n, depth: i }),
          (this.magFilter = 1003),
          (this.minFilter = 1003),
          (this.wrapR = 1001),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    function qn(e, t) {
      return e[0] - t[0];
    }
    function Xn(e, t) {
      return Math.abs(t[1]) - Math.abs(e[1]);
    }
    function Yn(e, t) {
      let n = 1;
      const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
      i instanceof Int8Array
        ? (n = 127)
        : i instanceof Int16Array
        ? (n = 32767)
        : i instanceof Int32Array
        ? (n = 2147483647)
        : console.error(
            "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
            i
          ),
        e.divideScalar(n);
    }
    function Jn(e, t, n) {
      const i = {},
        r = new Float32Array(8),
        s = new WeakMap(),
        a = new F(),
        o = [];
      for (let e = 0; e < 8; e++) o[e] = [e, 0];
      return {
        update: function (l, c, h, u) {
          const d = l.morphTargetInfluences;
          if (!0 === t.isWebGL2) {
            const i = c.morphAttributes.position.length;
            let r = s.get(c);
            if (void 0 === r || r.count !== i) {
              void 0 !== r && r.texture.dispose();
              const e = void 0 !== c.morphAttributes.normal,
                n = c.morphAttributes.position,
                o = c.morphAttributes.normal || [],
                l = !0 === e ? 2 : 1;
              let h = c.attributes.position.count * l,
                u = 1;
              h > t.maxTextureSize &&
                ((u = Math.ceil(h / t.maxTextureSize)), (h = t.maxTextureSize));
              const d = new Float32Array(h * u * 4 * i),
                p = new jn(d, h, u, i);
              (p.format = 1023), (p.type = 1015);
              const m = 4 * l;
              for (let t = 0; t < i; t++) {
                const i = n[t],
                  r = o[t],
                  s = h * u * 4 * t;
                for (let t = 0; t < i.count; t++) {
                  a.fromBufferAttribute(i, t), !0 === i.normalized && Yn(a, i);
                  const n = t * m;
                  (d[s + n + 0] = a.x),
                    (d[s + n + 1] = a.y),
                    (d[s + n + 2] = a.z),
                    (d[s + n + 3] = 0),
                    !0 === e &&
                      (a.fromBufferAttribute(r, t),
                      !0 === r.normalized && Yn(a, r),
                      (d[s + n + 4] = a.x),
                      (d[s + n + 5] = a.y),
                      (d[s + n + 6] = a.z),
                      (d[s + n + 7] = 0));
                }
              }
              (r = { count: i, texture: p, size: new M(h, u) }), s.set(c, r);
            }
            let o = 0;
            for (let e = 0; e < d.length; e++) o += d[e];
            const l = c.morphTargetsRelative ? 1 : 1 - o;
            u.getUniforms().setValue(e, "morphTargetBaseInfluence", l),
              u.getUniforms().setValue(e, "morphTargetInfluences", d),
              u.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n),
              u.getUniforms().setValue(e, "morphTargetsTextureSize", r.size);
          } else {
            const t = void 0 === d ? 0 : d.length;
            let n = i[c.id];
            if (void 0 === n || n.length !== t) {
              n = [];
              for (let e = 0; e < t; e++) n[e] = [e, 0];
              i[c.id] = n;
            }
            for (let e = 0; e < t; e++) {
              const t = n[e];
              (t[0] = e), (t[1] = d[e]);
            }
            n.sort(Xn);
            for (let e = 0; e < 8; e++)
              e < t && n[e][1]
                ? ((o[e][0] = n[e][0]), (o[e][1] = n[e][1]))
                : ((o[e][0] = Number.MAX_SAFE_INTEGER), (o[e][1] = 0));
            o.sort(qn);
            const s = c.morphAttributes.position,
              a = c.morphAttributes.normal;
            let l = 0;
            for (let e = 0; e < 8; e++) {
              const t = o[e],
                n = t[0],
                i = t[1];
              n !== Number.MAX_SAFE_INTEGER && i
                ? (s &&
                    c.getAttribute("morphTarget" + e) !== s[n] &&
                    c.setAttribute("morphTarget" + e, s[n]),
                  a &&
                    c.getAttribute("morphNormal" + e) !== a[n] &&
                    c.setAttribute("morphNormal" + e, a[n]),
                  (r[e] = i),
                  (l += i))
                : (s &&
                    !0 === c.hasAttribute("morphTarget" + e) &&
                    c.deleteAttribute("morphTarget" + e),
                  a &&
                    !0 === c.hasAttribute("morphNormal" + e) &&
                    c.deleteAttribute("morphNormal" + e),
                  (r[e] = 0));
            }
            const h = c.morphTargetsRelative ? 1 : 1 - l;
            u.getUniforms().setValue(e, "morphTargetBaseInfluence", h),
              u.getUniforms().setValue(e, "morphTargetInfluences", r);
          }
        },
      };
    }
    function Zn(e, t, n, i) {
      let r = new WeakMap();
      function s(e) {
        const t = e.target;
        t.removeEventListener("dispose", s),
          n.remove(t.instanceMatrix),
          null !== t.instanceColor && n.remove(t.instanceColor);
      }
      return {
        update: function (e) {
          const a = i.render.frame,
            o = e.geometry,
            l = t.get(e, o);
          return (
            r.get(l) !== a && (t.update(l), r.set(l, a)),
            e.isInstancedMesh &&
              (!1 === e.hasEventListener("dispose", s) &&
                e.addEventListener("dispose", s),
              n.update(e.instanceMatrix, 34962),
              null !== e.instanceColor && n.update(e.instanceColor, 34962)),
            l
          );
        },
        dispose: function () {
          r = new WeakMap();
        },
      };
    }
    jn.prototype.isDataTexture2DArray = !0;
    class Kn extends P {
      constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
          (this.image = { data: e, width: t, height: n, depth: i }),
          (this.magFilter = 1003),
          (this.minFilter = 1003),
          (this.wrapR = 1001),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    Kn.prototype.isDataTexture3D = !0;
    const Qn = new P(),
      $n = new jn(),
      ei = new Kn(),
      ti = new Yt(),
      ni = [],
      ii = [],
      ri = new Float32Array(16),
      si = new Float32Array(9),
      ai = new Float32Array(4);
    function oi(e, t, n) {
      const i = e[0];
      if (i <= 0 || i > 0) return e;
      const r = t * n;
      let s = ni[r];
      if ((void 0 === s && ((s = new Float32Array(r)), (ni[r] = s)), 0 !== t)) {
        i.toArray(s, 0);
        for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
      }
      return s;
    }
    function li(e, t) {
      if (e.length !== t.length) return !1;
      for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
      return !0;
    }
    function ci(e, t) {
      for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
    }
    function hi(e, t) {
      let n = ii[t];
      void 0 === n && ((n = new Int32Array(t)), (ii[t] = n));
      for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
      return n;
    }
    function ui(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
    }
    function di(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y) ||
          (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
      else {
        if (li(n, t)) return;
        e.uniform2fv(this.addr, t), ci(n, t);
      }
    }
    function pi(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
          (e.uniform3f(this.addr, t.x, t.y, t.z),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z));
      else if (void 0 !== t.r)
        (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
          (e.uniform3f(this.addr, t.r, t.g, t.b),
          (n[0] = t.r),
          (n[1] = t.g),
          (n[2] = t.b));
      else {
        if (li(n, t)) return;
        e.uniform3fv(this.addr, t), ci(n, t);
      }
    }
    function mi(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
          (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z),
          (n[3] = t.w));
      else {
        if (li(n, t)) return;
        e.uniform4fv(this.addr, t), ci(n, t);
      }
    }
    function fi(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (li(n, t)) return;
        e.uniformMatrix2fv(this.addr, !1, t), ci(n, t);
      } else {
        if (li(n, i)) return;
        ai.set(i), e.uniformMatrix2fv(this.addr, !1, ai), ci(n, i);
      }
    }
    function gi(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (li(n, t)) return;
        e.uniformMatrix3fv(this.addr, !1, t), ci(n, t);
      } else {
        if (li(n, i)) return;
        si.set(i), e.uniformMatrix3fv(this.addr, !1, si), ci(n, i);
      }
    }
    function vi(e, t) {
      const n = this.cache,
        i = t.elements;
      if (void 0 === i) {
        if (li(n, t)) return;
        e.uniformMatrix4fv(this.addr, !1, t), ci(n, t);
      } else {
        if (li(n, i)) return;
        ri.set(i), e.uniformMatrix4fv(this.addr, !1, ri), ci(n, i);
      }
    }
    function _i(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
    }
    function xi(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform2iv(this.addr, t), ci(n, t));
    }
    function yi(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform3iv(this.addr, t), ci(n, t));
    }
    function bi(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform4iv(this.addr, t), ci(n, t));
    }
    function wi(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
    }
    function Mi(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform2uiv(this.addr, t), ci(n, t));
    }
    function Si(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform3uiv(this.addr, t), ci(n, t));
    }
    function Ti(e, t) {
      const n = this.cache;
      li(n, t) || (e.uniform4uiv(this.addr, t), ci(n, t));
    }
    function Ei(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTexture2D(t || Qn, r);
    }
    function Ai(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(t || ei, r);
    }
    function Li(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.safeSetTextureCube(t || ti, r);
    }
    function Ri(e, t, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(t || $n, r);
    }
    function Ci(e, t) {
      e.uniform1fv(this.addr, t);
    }
    function Pi(e, t) {
      const n = oi(t, this.size, 2);
      e.uniform2fv(this.addr, n);
    }
    function Ii(e, t) {
      const n = oi(t, this.size, 3);
      e.uniform3fv(this.addr, n);
    }
    function Di(e, t) {
      const n = oi(t, this.size, 4);
      e.uniform4fv(this.addr, n);
    }
    function Ni(e, t) {
      const n = oi(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, n);
    }
    function Oi(e, t) {
      const n = oi(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, n);
    }
    function zi(e, t) {
      const n = oi(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, n);
    }
    function Fi(e, t) {
      e.uniform1iv(this.addr, t);
    }
    function Bi(e, t) {
      e.uniform2iv(this.addr, t);
    }
    function Ui(e, t) {
      e.uniform3iv(this.addr, t);
    }
    function Hi(e, t) {
      e.uniform4iv(this.addr, t);
    }
    function ki(e, t) {
      e.uniform1uiv(this.addr, t);
    }
    function Gi(e, t) {
      e.uniform2uiv(this.addr, t);
    }
    function Vi(e, t) {
      e.uniform3uiv(this.addr, t);
    }
    function Wi(e, t) {
      e.uniform4uiv(this.addr, t);
    }
    function ji(e, t, n) {
      const i = t.length,
        r = hi(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Qn, r[e]);
    }
    function qi(e, t, n) {
      const i = t.length,
        r = hi(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || ei, r[e]);
    }
    function Xi(e, t, n) {
      const i = t.length,
        r = hi(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || ti, r[e]);
    }
    function Yi(e, t, n) {
      const i = t.length,
        r = hi(n, i);
      e.uniform1iv(this.addr, r);
      for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || $n, r[e]);
    }
    function Ji(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return ui;
            case 35664:
              return di;
            case 35665:
              return pi;
            case 35666:
              return mi;
            case 35674:
              return fi;
            case 35675:
              return gi;
            case 35676:
              return vi;
            case 5124:
            case 35670:
              return _i;
            case 35667:
            case 35671:
              return xi;
            case 35668:
            case 35672:
              return yi;
            case 35669:
            case 35673:
              return bi;
            case 5125:
              return wi;
            case 36294:
              return Mi;
            case 36295:
              return Si;
            case 36296:
              return Ti;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Ei;
            case 35679:
            case 36299:
            case 36307:
              return Ai;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Li;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Ri;
          }
        })(t.type));
    }
    function Zi(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.size = t.size),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return Ci;
            case 35664:
              return Pi;
            case 35665:
              return Ii;
            case 35666:
              return Di;
            case 35674:
              return Ni;
            case 35675:
              return Oi;
            case 35676:
              return zi;
            case 5124:
            case 35670:
              return Fi;
            case 35667:
            case 35671:
              return Bi;
            case 35668:
            case 35672:
              return Ui;
            case 35669:
            case 35673:
              return Hi;
            case 5125:
              return ki;
            case 36294:
              return Gi;
            case 36295:
              return Vi;
            case 36296:
              return Wi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return ji;
            case 35679:
            case 36299:
            case 36307:
              return qi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Xi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Yi;
          }
        })(t.type));
    }
    function Ki(e) {
      (this.id = e), (this.seq = []), (this.map = {});
    }
    (Zi.prototype.updateCache = function (e) {
      const t = this.cache;
      e instanceof Float32Array &&
        t.length !== e.length &&
        (this.cache = new Float32Array(e.length)),
        ci(t, e);
    }),
      (Ki.prototype.setValue = function (e, t, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
          const s = i[r];
          s.setValue(e, t[s.id], n);
        }
      });
    const Qi = /(\w+)(\])?(\[|\.)?/g;
    function $i(e, t) {
      e.seq.push(t), (e.map[t.id] = t);
    }
    function er(e, t, n) {
      const i = e.name,
        r = i.length;
      for (Qi.lastIndex = 0; ; ) {
        const s = Qi.exec(i),
          a = Qi.lastIndex;
        let o = s[1];
        const l = "]" === s[2],
          c = s[3];
        if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
          $i(n, void 0 === c ? new Ji(o, e, t) : new Zi(o, e, t));
          break;
        }
        {
          let e = n.map[o];
          void 0 === e && ((e = new Ki(o)), $i(n, e)), (n = e);
        }
      }
    }
    function tr(e, t) {
      (this.seq = []), (this.map = {});
      const n = e.getProgramParameter(t, 35718);
      for (let i = 0; i < n; ++i) {
        const n = e.getActiveUniform(t, i);
        er(n, e.getUniformLocation(t, n.name), this);
      }
    }
    function nr(e, t, n) {
      const i = e.createShader(t);
      return e.shaderSource(i, n), e.compileShader(i), i;
    }
    (tr.prototype.setValue = function (e, t, n, i) {
      const r = this.map[t];
      void 0 !== r && r.setValue(e, n, i);
    }),
      (tr.prototype.setOptional = function (e, t, n) {
        const i = t[n];
        void 0 !== i && this.setValue(e, n, i);
      }),
      (tr.upload = function (e, t, n, i) {
        for (let r = 0, s = t.length; r !== s; ++r) {
          const s = t[r],
            a = n[s.id];
          !1 !== a.needsUpdate && s.setValue(e, a.value, i);
        }
      }),
      (tr.seqWithValue = function (e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
          const r = e[i];
          r.id in t && n.push(r);
        }
        return n;
      });
    let ir = 0;
    function rr(e) {
      switch (e) {
        case 3e3:
          return ["Linear", "( value )"];
        case 3001:
          return ["sRGB", "( value )"];
        case 3002:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case 3007:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
            ["Linear", "( value )"]
          );
      }
    }
    function sr(e, t, n) {
      const i = e.getShaderParameter(t, 35713),
        r = e.getShaderInfoLog(t).trim();
      return i && "" === r
        ? ""
        : n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (e) {
              const t = e.split("\n");
              for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
              return t.join("\n");
            })(e.getShaderSource(t));
    }
    function ar(e, t) {
      const n = rr(t);
      return (
        "vec4 " +
        e +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function or(e, t) {
      const n = rr(t);
      return (
        "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }
    function lr(e, t) {
      let n;
      switch (t) {
        case 1:
          n = "Linear";
          break;
        case 2:
          n = "Reinhard";
          break;
        case 3:
          n = "OptimizedCineon";
          break;
        case 4:
          n = "ACESFilmic";
          break;
        case 5:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
            (n = "Linear");
      }
      return (
        "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function cr(e) {
      return "" !== e;
    }
    function hr(e, t) {
      return e
        .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }
    function ur(e, t) {
      return e
        .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          t.numClippingPlanes - t.numClipIntersection
        );
    }
    const dr = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function pr(e) {
      return e.replace(dr, mr);
    }
    function mr(e, t) {
      const n = on[t];
      if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
      return pr(n);
    }
    const fr =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      gr =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function vr(e) {
      return e.replace(gr, xr).replace(fr, _r);
    }
    function _r(e, t, n, i) {
      return (
        console.warn(
          "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        xr(e, t, n, i)
      );
    }
    function xr(e, t, n, i) {
      let r = "";
      for (let e = parseInt(t); e < parseInt(n); e++)
        r += i
          .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, e);
      return r;
    }
    function yr(e) {
      let t =
        "precision " +
        e.precision +
        " float;\nprecision " +
        e.precision +
        " int;";
      return (
        "highp" === e.precision
          ? (t += "\n#define HIGH_PRECISION")
          : "mediump" === e.precision
          ? (t += "\n#define MEDIUM_PRECISION")
          : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
        t
      );
    }
    function br(e, t, n, i) {
      const r = e.getContext(),
        s = n.defines;
      let a = n.vertexShader,
        o = n.fragmentShader;
      const l = (function (e) {
          let t = "SHADOWMAP_TYPE_BASIC";
          return (
            1 === e.shadowMapType
              ? (t = "SHADOWMAP_TYPE_PCF")
              : 2 === e.shadowMapType
              ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
            t
          );
        })(n),
        c = (function (e) {
          let t = "ENVMAP_TYPE_CUBE";
          if (e.envMap)
            switch (e.envMapMode) {
              case 301:
              case 302:
                t = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
              case 307:
                t = "ENVMAP_TYPE_CUBE_UV";
            }
          return t;
        })(n),
        h = (function (e) {
          let t = "ENVMAP_MODE_REFLECTION";
          if (e.envMap)
            switch (e.envMapMode) {
              case 302:
              case 307:
                t = "ENVMAP_MODE_REFRACTION";
            }
          return t;
        })(n),
        u = (function (e) {
          let t = "ENVMAP_BLENDING_NONE";
          if (e.envMap)
            switch (e.combine) {
              case 0:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                t = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                t = "ENVMAP_BLENDING_ADD";
            }
          return t;
        })(n),
        d = e.gammaFactor > 0 ? e.gammaFactor : 1,
        p = n.isWebGL2
          ? ""
          : (function (e) {
              return [
                e.extensionDerivatives ||
                e.envMapCubeUV ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading ||
                "physical" === e.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                e.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
                e.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(cr)
                .join("\n");
            })(n),
        m = (function (e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            !1 !== i && t.push("#define " + n + " " + i);
          }
          return t.join("\n");
        })(s),
        f = r.createProgram();
      let g,
        v,
        _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial
        ? ((g = [m].filter(cr).join("\n")),
          g.length > 0 && (g += "\n"),
          (v = [p, m].filter(cr).join("\n")),
          v.length > 0 && (v += "\n"))
        : ((g = [
            yr(n),
            "#define SHADER_NAME " + n.shaderName,
            m,
            n.instancing ? "#define USE_INSTANCING" : "",
            n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define GAMMA_FACTOR " + d,
            "#define MAX_BONES " + n.maxBones,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + h : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.displacementMap && n.supportsVertexTextures
              ? "#define USE_DISPLACEMENTMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.skinning ? "#define USE_SKINNING" : "",
            n.useVertexTexture ? "#define BONE_TEXTURE" : "",
            n.morphTargets ? "#define USE_MORPHTARGETS" : "",
            n.morphNormals && !1 === n.flatShading
              ? "#define USE_MORPHNORMALS"
              : "",
            n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
            n.morphTargets && n.isWebGL2
              ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
              : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "\tattribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "\tattribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "\tattribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "\tattribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "\tattribute vec3 color;",
            "#endif",
            "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
            "\tattribute vec3 morphTarget0;",
            "\tattribute vec3 morphTarget1;",
            "\tattribute vec3 morphTarget2;",
            "\tattribute vec3 morphTarget3;",
            "\t#ifdef USE_MORPHNORMALS",
            "\t\tattribute vec3 morphNormal0;",
            "\t\tattribute vec3 morphNormal1;",
            "\t\tattribute vec3 morphNormal2;",
            "\t\tattribute vec3 morphNormal3;",
            "\t#else",
            "\t\tattribute vec3 morphTarget4;",
            "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;",
            "\t\tattribute vec3 morphTarget7;",
            "\t#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "\tattribute vec4 skinIndex;",
            "\tattribute vec4 skinWeight;",
            "#endif",
            "\n",
          ]
            .filter(cr)
            .join("\n")),
          (v = [
            p,
            yr(n),
            "#define SHADER_NAME " + n.shaderName,
            m,
            "#define GAMMA_FACTOR " + d,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.matcap ? "#define USE_MATCAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + c : "",
            n.envMap ? "#define " + h : "",
            n.envMap ? "#define " + u : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoat ? "#define USE_CLEARCOAT" : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.alphaTest ? "#define USE_ALPHATEST" : "",
            n.sheen ? "#define USE_SHEEN" : "",
            n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.gradientMap ? "#define USE_GRADIENTMAP" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            n.physicallyCorrectLights
              ? "#define PHYSICALLY_CORRECT_LIGHTS"
              : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            (n.extensionShaderTextureLOD || n.envMap) &&
            n.rendererExtensionShaderTextureLod
              ? "#define TEXTURE_LOD_EXT"
              : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
            0 !== n.toneMapping ? on.tonemapping_pars_fragment : "",
            0 !== n.toneMapping ? lr("toneMapping", n.toneMapping) : "",
            n.dithering ? "#define DITHERING" : "",
            1022 === n.format ? "#define OPAQUE" : "",
            on.encodings_pars_fragment,
            n.map ? ar("mapTexelToLinear", n.mapEncoding) : "",
            n.matcap ? ar("matcapTexelToLinear", n.matcapEncoding) : "",
            n.envMap ? ar("envMapTexelToLinear", n.envMapEncoding) : "",
            n.emissiveMap
              ? ar("emissiveMapTexelToLinear", n.emissiveMapEncoding)
              : "",
            n.specularColorMap
              ? ar("specularColorMapTexelToLinear", n.specularColorMapEncoding)
              : "",
            n.sheenColorMap
              ? ar("sheenColorMapTexelToLinear", n.sheenColorMapEncoding)
              : "",
            n.lightMap ? ar("lightMapTexelToLinear", n.lightMapEncoding) : "",
            or("linearToOutputTexel", n.outputEncoding),
            n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(cr)
            .join("\n"))),
        (a = pr(a)),
        (a = hr(a, n)),
        (a = ur(a, n)),
        (o = pr(o)),
        (o = hr(o, n)),
        (o = ur(o, n)),
        (a = vr(a)),
        (o = vr(o)),
        n.isWebGL2 &&
          !0 !== n.isRawShaderMaterial &&
          ((_ = "#version 300 es\n"),
          (g =
            [
              "precision mediump sampler2DArray;",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            g),
          (v =
            [
              "#define varying in",
              "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;",
              "300 es" === n.glslVersion
                ? ""
                : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            v));
      const x = _ + v + o,
        y = nr(r, 35633, _ + g + a),
        b = nr(r, 35632, x);
      if (
        (r.attachShader(f, y),
        r.attachShader(f, b),
        void 0 !== n.index0AttributeName
          ? r.bindAttribLocation(f, 0, n.index0AttributeName)
          : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"),
        r.linkProgram(f),
        e.debug.checkShaderErrors)
      ) {
        const e = r.getProgramInfoLog(f).trim(),
          t = r.getShaderInfoLog(y).trim(),
          n = r.getShaderInfoLog(b).trim();
        let i = !0,
          s = !0;
        if (!1 === r.getProgramParameter(f, 35714)) {
          i = !1;
          const t = sr(r, y, "vertex"),
            n = sr(r, b, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(f, 35715) +
              "\n\nProgram Info Log: " +
              e +
              "\n" +
              t +
              "\n" +
              n
          );
        } else
          "" !== e
            ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
            : ("" !== t && "" !== n) || (s = !1);
        s &&
          (this.diagnostics = {
            runnable: i,
            programLog: e,
            vertexShader: { log: t, prefix: g },
            fragmentShader: { log: n, prefix: v },
          });
      }
      let w, M;
      return (
        r.deleteShader(y),
        r.deleteShader(b),
        (this.getUniforms = function () {
          return void 0 === w && (w = new tr(r, f)), w;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === M &&
              (M = (function (e, t) {
                const n = {},
                  i = e.getProgramParameter(t, 35721);
                for (let r = 0; r < i; r++) {
                  const i = e.getActiveAttrib(t, r),
                    s = i.name;
                  let a = 1;
                  35674 === i.type && (a = 2),
                    35675 === i.type && (a = 3),
                    35676 === i.type && (a = 4),
                    (n[s] = {
                      type: i.type,
                      location: e.getAttribLocation(t, s),
                      locationSize: a,
                    });
                }
                return n;
              })(r, f)),
            M
          );
        }),
        (this.destroy = function () {
          i.releaseStatesOfProgram(this),
            r.deleteProgram(f),
            (this.program = void 0);
        }),
        (this.name = n.shaderName),
        (this.id = ir++),
        (this.cacheKey = t),
        (this.usedTimes = 1),
        (this.program = f),
        (this.vertexShader = y),
        (this.fragmentShader = b),
        this
      );
    }
    function wr(e, t, n, i, r, s, a) {
      const o = [],
        l = r.isWebGL2,
        c = r.logarithmicDepthBuffer,
        h = r.floatVertexTextures,
        u = r.maxVertexUniforms,
        d = r.vertexTextures;
      let p = r.precision;
      const m = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        f = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "instancingColor",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoat",
          "clearcoatMap",
          "clearcoatRoughnessMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          ,
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "alphaTest",
          "combine",
          "vertexColors",
          "vertexAlphas",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "morphTargetsCount",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "format",
          "specularIntensityMap",
          "specularColorMap",
          "specularColorMapEncoding",
          "transmission",
          "transmissionMap",
          "thicknessMap",
          "sheen",
          "sheenColorMap",
          "sheenColorMapEncoding",
          "sheenRoughnessMap",
        ];
      function g(e) {
        let t;
        return (
          e && e.isTexture
            ? (t = e.encoding)
            : e && e.isWebGLRenderTarget
            ? (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
              ),
              (t = e.texture.encoding))
            : (t = 3e3),
          t
        );
      }
      return {
        getParameters: function (s, o, f, v, _) {
          const x = v.fog,
            y = s.isMeshStandardMaterial ? v.environment : null,
            b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || y),
            w = m[s.type],
            M = _.isSkinnedMesh
              ? (function (e) {
                  const t = e.skeleton.bones;
                  if (h) return 1024;
                  {
                    const e = u,
                      n = Math.floor((e - 20) / 4),
                      i = Math.min(n, t.length);
                    return i < t.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            t.length +
                            " bones. This GPU supports " +
                            i +
                            "."
                        ),
                        0)
                      : i;
                  }
                })(_)
              : 0;
          let S, T;
          if (
            (null !== s.precision &&
              ((p = r.getMaxPrecision(s.precision)),
              p !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  p,
                  "instead."
                )),
            w)
          ) {
            const e = cn[w];
            (S = e.vertexShader), (T = e.fragmentShader);
          } else (S = s.vertexShader), (T = s.fragmentShader);
          const E = e.getRenderTarget(),
            A = s.alphaTest > 0,
            L = s.clearcoat > 0;
          return {
            isWebGL2: l,
            shaderID: w,
            shaderName: s.type,
            vertexShader: S,
            fragmentShader: T,
            defines: s.defines,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: p,
            instancing: !0 === _.isInstancedMesh,
            instancingColor:
              !0 === _.isInstancedMesh && null !== _.instanceColor,
            supportsVertexTextures: d,
            outputEncoding: null !== E ? g(E.texture) : e.outputEncoding,
            map: !!s.map,
            mapEncoding: g(s.map),
            matcap: !!s.matcap,
            matcapEncoding: g(s.matcap),
            envMap: !!b,
            envMapMode: b && b.mapping,
            envMapEncoding: g(b),
            envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
            lightMap: !!s.lightMap,
            lightMapEncoding: g(s.lightMap),
            aoMap: !!s.aoMap,
            emissiveMap: !!s.emissiveMap,
            emissiveMapEncoding: g(s.emissiveMap),
            bumpMap: !!s.bumpMap,
            normalMap: !!s.normalMap,
            objectSpaceNormalMap: 1 === s.normalMapType,
            tangentSpaceNormalMap: 0 === s.normalMapType,
            clearcoat: L,
            clearcoatMap: L && !!s.clearcoatMap,
            clearcoatRoughnessMap: L && !!s.clearcoatRoughnessMap,
            clearcoatNormalMap: L && !!s.clearcoatNormalMap,
            displacementMap: !!s.displacementMap,
            roughnessMap: !!s.roughnessMap,
            metalnessMap: !!s.metalnessMap,
            specularMap: !!s.specularMap,
            specularIntensityMap: !!s.specularIntensityMap,
            specularColorMap: !!s.specularColorMap,
            specularColorMapEncoding: g(s.specularColorMap),
            alphaMap: !!s.alphaMap,
            alphaTest: A,
            gradientMap: !!s.gradientMap,
            sheen: s.sheen > 0,
            sheenColorMap: !!s.sheenColorMap,
            sheenColorMapEncoding: g(s.sheenColorMap),
            sheenRoughnessMap: !!s.sheenRoughnessMap,
            transmission: s.transmission > 0,
            transmissionMap: !!s.transmissionMap,
            thicknessMap: !!s.thicknessMap,
            combine: s.combine,
            vertexTangents:
              !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
            vertexColors: s.vertexColors,
            vertexAlphas:
              !0 === s.vertexColors &&
              !!_.geometry &&
              !!_.geometry.attributes.color &&
              4 === _.geometry.attributes.color.itemSize,
            vertexUvs:
              !!s.map ||
              !!s.bumpMap ||
              !!s.normalMap ||
              !!s.specularMap ||
              !!s.alphaMap ||
              !!s.emissiveMap ||
              !!s.roughnessMap ||
              !!s.metalnessMap ||
              !!s.clearcoatMap ||
              !!s.clearcoatRoughnessMap ||
              !!s.clearcoatNormalMap ||
              !!s.displacementMap ||
              !!s.transmissionMap ||
              !!s.thicknessMap ||
              !!s.specularIntensityMap ||
              !!s.specularColorMap ||
              !!s.sheenColorMap ||
              s.sheenRoughnessMap,
            uvsVertexOnly: !(
              s.map ||
              s.bumpMap ||
              s.normalMap ||
              s.specularMap ||
              s.alphaMap ||
              s.emissiveMap ||
              s.roughnessMap ||
              s.metalnessMap ||
              s.clearcoatNormalMap ||
              s.transmission > 0 ||
              s.transmissionMap ||
              s.thicknessMap ||
              s.specularIntensityMap ||
              s.specularColorMap ||
              s.sheen > 0 ||
              s.sheenColorMap ||
              s.sheenRoughnessMap ||
              !s.displacementMap
            ),
            fog: !!x,
            useFog: s.fog,
            fogExp2: x && x.isFogExp2,
            flatShading: !!s.flatShading,
            sizeAttenuation: s.sizeAttenuation,
            logarithmicDepthBuffer: c,
            skinning: !0 === _.isSkinnedMesh && M > 0,
            maxBones: M,
            useVertexTexture: h,
            morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
            morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
            morphTargetsCount:
              _.geometry && _.geometry.morphAttributes.position
                ? _.geometry.morphAttributes.position.length
                : 0,
            numDirLights: o.directional.length,
            numPointLights: o.point.length,
            numSpotLights: o.spot.length,
            numRectAreaLights: o.rectArea.length,
            numHemiLights: o.hemi.length,
            numDirLightShadows: o.directionalShadowMap.length,
            numPointLightShadows: o.pointShadowMap.length,
            numSpotLightShadows: o.spotShadowMap.length,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            format: s.format,
            dithering: s.dithering,
            shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: s.toneMapped ? e.toneMapping : 0,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: s.premultipliedAlpha,
            doubleSided: 2 === s.side,
            flipSided: 1 === s.side,
            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: s.extensions && s.extensions.derivatives,
            extensionFragDepth: s.extensions && s.extensions.fragDepth,
            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
            extensionShaderTextureLOD:
              s.extensions && s.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              l || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: s.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (t) {
          const n = [];
          if (
            (t.shaderID
              ? n.push(t.shaderID)
              : (n.push(A(t.fragmentShader)), n.push(A(t.vertexShader))),
            void 0 !== t.defines)
          )
            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
          if (!1 === t.isRawShaderMaterial) {
            for (let e = 0; e < f.length; e++) n.push(t[f[e]]);
            n.push(e.outputEncoding), n.push(e.gammaFactor);
          }
          return n.push(t.customProgramCacheKey), n.join();
        },
        getUniforms: function (e) {
          const t = m[e.type];
          let n;
          if (t) {
            const e = cn[t];
            n = Vt.clone(e.uniforms);
          } else n = e.uniforms;
          return n;
        },
        acquireProgram: function (t, n) {
          let i;
          for (let e = 0, t = o.length; e < t; e++) {
            const t = o[e];
            if (t.cacheKey === n) {
              (i = t), ++i.usedTimes;
              break;
            }
          }
          return void 0 === i && ((i = new br(e, n, t, s)), o.push(i)), i;
        },
        releaseProgram: function (e) {
          if (0 == --e.usedTimes) {
            const t = o.indexOf(e);
            (o[t] = o[o.length - 1]), o.pop(), e.destroy();
          }
        },
        programs: o,
      };
    }
    function Mr() {
      let e = new WeakMap();
      return {
        get: function (t) {
          let n = e.get(t);
          return void 0 === n && ((n = {}), e.set(t, n)), n;
        },
        remove: function (t) {
          e.delete(t);
        },
        update: function (t, n, i) {
          e.get(t)[n] = i;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    function Sr(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.program !== t.program
        ? e.program.id - t.program.id
        : e.material.id !== t.material.id
        ? e.material.id - t.material.id
        : e.z !== t.z
        ? e.z - t.z
        : e.id - t.id;
    }
    function Tr(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.z !== t.z
        ? t.z - e.z
        : e.id - t.id;
    }
    function Er(e) {
      const t = [];
      let n = 0;
      const i = [],
        r = [],
        s = [],
        a = { id: -1 };
      function o(i, r, s, o, l, c) {
        let h = t[n];
        const u = e.get(s);
        return (
          void 0 === h
            ? ((h = {
                id: i.id,
                object: i,
                geometry: r,
                material: s,
                program: u.program || a,
                groupOrder: o,
                renderOrder: i.renderOrder,
                z: l,
                group: c,
              }),
              (t[n] = h))
            : ((h.id = i.id),
              (h.object = i),
              (h.geometry = r),
              (h.material = s),
              (h.program = u.program || a),
              (h.groupOrder = o),
              (h.renderOrder = i.renderOrder),
              (h.z = l),
              (h.group = c)),
          n++,
          h
        );
      }
      return {
        opaque: i,
        transmissive: r,
        transparent: s,
        init: function () {
          (n = 0), (i.length = 0), (r.length = 0), (s.length = 0);
        },
        push: function (e, t, n, a, l, c) {
          const h = o(e, t, n, a, l, c);
          n.transmission > 0
            ? r.push(h)
            : !0 === n.transparent
            ? s.push(h)
            : i.push(h);
        },
        unshift: function (e, t, n, a, l, c) {
          const h = o(e, t, n, a, l, c);
          n.transmission > 0
            ? r.unshift(h)
            : !0 === n.transparent
            ? s.unshift(h)
            : i.unshift(h);
        },
        finish: function () {
          for (let e = n, i = t.length; e < i; e++) {
            const n = t[e];
            if (null === n.id) break;
            (n.id = null),
              (n.object = null),
              (n.geometry = null),
              (n.material = null),
              (n.program = null),
              (n.group = null);
          }
        },
        sort: function (e, t) {
          i.length > 1 && i.sort(e || Sr),
            r.length > 1 && r.sort(t || Tr),
            s.length > 1 && s.sort(t || Tr);
        },
      };
    }
    function Ar(e) {
      let t = new WeakMap();
      return {
        get: function (n, i) {
          let r;
          return (
            !1 === t.has(n)
              ? ((r = new Er(e)), t.set(n, [r]))
              : i >= t.get(n).length
              ? ((r = new Er(e)), t.get(n).push(r))
              : (r = t.get(n)[i]),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Lr() {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let n;
          switch (t.type) {
            case "DirectionalLight":
              n = { direction: new F(), color: new st() };
              break;
            case "SpotLight":
              n = {
                position: new F(),
                direction: new F(),
                color: new st(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = { position: new F(), color: new st(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              n = {
                direction: new F(),
                skyColor: new st(),
                groundColor: new st(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new st(),
                position: new F(),
                halfWidth: new F(),
                halfHeight: new F(),
              };
          }
          return (e[t.id] = n), n;
        },
      };
    }
    let Rr = 0;
    function Cr(e, t) {
      return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
    }
    function Pr(e, t) {
      const n = new Lr(),
        i = (function () {
          const e = {};
          return {
            get: function (t) {
              if (void 0 !== e[t.id]) return e[t.id];
              let n;
              switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new M(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new M(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (e[t.id] = n), n;
            },
          };
        })(),
        r = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let e = 0; e < 9; e++) r.probe.push(new F());
      const s = new F(),
        a = new me(),
        o = new me();
      return {
        setup: function (s, a) {
          let o = 0,
            l = 0,
            c = 0;
          for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
          let h = 0,
            u = 0,
            d = 0,
            p = 0,
            m = 0,
            f = 0,
            g = 0,
            v = 0;
          s.sort(Cr);
          const _ = !0 !== a ? Math.PI : 1;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e],
              a = t.color,
              x = t.intensity,
              y = t.distance,
              b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
            if (t.isAmbientLight)
              (o += a.r * x * _), (l += a.g * x * _), (c += a.b * x * _);
            else if (t.isLightProbe)
              for (let e = 0; e < 9; e++)
                r.probe[e].addScaledVector(t.sh.coefficients[e], x);
            else if (t.isDirectionalLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (r.directionalShadow[h] = n),
                  (r.directionalShadowMap[h] = b),
                  (r.directionalShadowMatrix[h] = t.shadow.matrix),
                  f++;
              }
              (r.directional[h] = e), h++;
            } else if (t.isSpotLight) {
              const e = n.get(t);
              if (
                (e.position.setFromMatrixPosition(t.matrixWorld),
                e.color.copy(a).multiplyScalar(x * _),
                (e.distance = y),
                (e.coneCos = Math.cos(t.angle)),
                (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (r.spotShadow[d] = n),
                  (r.spotShadowMap[d] = b),
                  (r.spotShadowMatrix[d] = t.shadow.matrix),
                  v++;
              }
              (r.spot[d] = e), d++;
            } else if (t.isRectAreaLight) {
              const e = n.get(t);
              e.color.copy(a).multiplyScalar(x),
                e.halfWidth.set(0.5 * t.width, 0, 0),
                e.halfHeight.set(0, 0.5 * t.height, 0),
                (r.rectArea[p] = e),
                p++;
            } else if (t.isPointLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                (e.distance = t.distance),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = i.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (n.shadowCameraNear = e.camera.near),
                  (n.shadowCameraFar = e.camera.far),
                  (r.pointShadow[u] = n),
                  (r.pointShadowMap[u] = b),
                  (r.pointShadowMatrix[u] = t.shadow.matrix),
                  g++;
              }
              (r.point[u] = e), u++;
            } else if (t.isHemisphereLight) {
              const e = n.get(t);
              e.skyColor.copy(t.color).multiplyScalar(x * _),
                e.groundColor.copy(t.groundColor).multiplyScalar(x * _),
                (r.hemi[m] = e),
                m++;
            }
          }
          p > 0 &&
            (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = ln.LTC_FLOAT_1),
                (r.rectAreaLTC2 = ln.LTC_FLOAT_2))
              : !0 === e.has("OES_texture_half_float_linear")
              ? ((r.rectAreaLTC1 = ln.LTC_HALF_1),
                (r.rectAreaLTC2 = ln.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (r.ambient[0] = o),
            (r.ambient[1] = l),
            (r.ambient[2] = c);
          const x = r.hash;
          (x.directionalLength === h &&
            x.pointLength === u &&
            x.spotLength === d &&
            x.rectAreaLength === p &&
            x.hemiLength === m &&
            x.numDirectionalShadows === f &&
            x.numPointShadows === g &&
            x.numSpotShadows === v) ||
            ((r.directional.length = h),
            (r.spot.length = d),
            (r.rectArea.length = p),
            (r.point.length = u),
            (r.hemi.length = m),
            (r.directionalShadow.length = f),
            (r.directionalShadowMap.length = f),
            (r.pointShadow.length = g),
            (r.pointShadowMap.length = g),
            (r.spotShadow.length = v),
            (r.spotShadowMap.length = v),
            (r.directionalShadowMatrix.length = f),
            (r.pointShadowMatrix.length = g),
            (r.spotShadowMatrix.length = v),
            (x.directionalLength = h),
            (x.pointLength = u),
            (x.spotLength = d),
            (x.rectAreaLength = p),
            (x.hemiLength = m),
            (x.numDirectionalShadows = f),
            (x.numPointShadows = g),
            (x.numSpotShadows = v),
            (r.version = Rr++));
        },
        setupView: function (e, t) {
          let n = 0,
            i = 0,
            l = 0,
            c = 0,
            h = 0;
          const u = t.matrixWorldInverse;
          for (let t = 0, d = e.length; t < d; t++) {
            const d = e[t];
            if (d.isDirectionalLight) {
              const e = r.directional[n];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(s),
                e.direction.transformDirection(u),
                n++;
            } else if (d.isSpotLight) {
              const e = r.spot[l];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                e.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(s),
                e.direction.transformDirection(u),
                l++;
            } else if (d.isRectAreaLight) {
              const e = r.rectArea[c];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                o.identity(),
                a.copy(d.matrixWorld),
                a.premultiply(u),
                o.extractRotation(a),
                e.halfWidth.set(0.5 * d.width, 0, 0),
                e.halfHeight.set(0, 0.5 * d.height, 0),
                e.halfWidth.applyMatrix4(o),
                e.halfHeight.applyMatrix4(o),
                c++;
            } else if (d.isPointLight) {
              const e = r.point[i];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(u),
                i++;
            } else if (d.isHemisphereLight) {
              const e = r.hemi[h];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                e.direction.transformDirection(u),
                e.direction.normalize(),
                h++;
            }
          }
        },
        state: r,
      };
    }
    function Ir(e, t) {
      const n = new Pr(e, t),
        i = [],
        r = [];
      return {
        init: function () {
          (i.length = 0), (r.length = 0);
        },
        state: { lightsArray: i, shadowsArray: r, lights: n },
        setupLights: function (e) {
          n.setup(i, e);
        },
        setupLightsView: function (e) {
          n.setupView(i, e);
        },
        pushLight: function (e) {
          i.push(e);
        },
        pushShadow: function (e) {
          r.push(e);
        },
      };
    }
    function Dr(e, t) {
      let n = new WeakMap();
      return {
        get: function (i, r = 0) {
          let s;
          return (
            !1 === n.has(i)
              ? ((s = new Ir(e, t)), n.set(i, [s]))
              : r >= n.get(i).length
              ? ((s = new Ir(e, t)), n.get(i).push(s))
              : (s = n.get(i)[r]),
            s
          );
        },
        dispose: function () {
          n = new WeakMap();
        },
      };
    }
    class Nr extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = 3200),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.depthPacking = e.depthPacking),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          this
        );
      }
    }
    Nr.prototype.isMeshDepthMaterial = !0;
    class Or extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new F()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.referencePosition.copy(e.referencePosition),
          (this.nearDistance = e.nearDistance),
          (this.farDistance = e.farDistance),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          this
        );
      }
    }
    Or.prototype.isMeshDistanceMaterial = !0;
    function zr(e, t, n) {
      let i = new nn();
      const r = new M(),
        s = new M(),
        a = new D(),
        o = new Nr({ depthPacking: 3201 }),
        l = new Or(),
        c = {},
        h = n.maxTextureSize,
        u = { 0: 1, 1: 0, 2: 2 },
        d = new Wt({
          defines: { VSM_SAMPLES: 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new M() },
            radius: { value: 4 },
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        }),
        p = d.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const m = new yt();
      m.setAttribute(
        "position",
        new ct(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const f = new Bt(m, d),
        g = this;
      function v(n, i) {
        const r = t.update(f);
        d.defines.VSM_SAMPLES !== n.blurSamples &&
          ((d.defines.VSM_SAMPLES = n.blurSamples),
          (p.defines.VSM_SAMPLES = n.blurSamples),
          (d.needsUpdate = !0),
          (p.needsUpdate = !0)),
          (d.uniforms.shadow_pass.value = n.map.texture),
          (d.uniforms.resolution.value = n.mapSize),
          (d.uniforms.radius.value = n.radius),
          e.setRenderTarget(n.mapPass),
          e.clear(),
          e.renderBufferDirect(i, null, r, d, f, null),
          (p.uniforms.shadow_pass.value = n.mapPass.texture),
          (p.uniforms.resolution.value = n.mapSize),
          (p.uniforms.radius.value = n.radius),
          e.setRenderTarget(n.map),
          e.clear(),
          e.renderBufferDirect(i, null, r, p, f, null);
      }
      function _(t, n, i, r, s, a, h) {
        let d = null;
        const p =
          !0 === r.isPointLight
            ? t.customDistanceMaterial
            : t.customDepthMaterial;
        if (
          ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o),
          (e.localClippingEnabled &&
            !0 === i.clipShadows &&
            0 !== i.clippingPlanes.length) ||
            (i.displacementMap && 0 !== i.displacementScale) ||
            (i.alphaMap && i.alphaTest > 0))
        ) {
          const e = d.uuid,
            t = i.uuid;
          let n = c[e];
          void 0 === n && ((n = {}), (c[e] = n));
          let r = n[t];
          void 0 === r && ((r = d.clone()), (n[t] = r)), (d = r);
        }
        return (
          (d.visible = i.visible),
          (d.wireframe = i.wireframe),
          (d.side =
            3 === h
              ? null !== i.shadowSide
                ? i.shadowSide
                : i.side
              : null !== i.shadowSide
              ? i.shadowSide
              : u[i.side]),
          (d.alphaMap = i.alphaMap),
          (d.alphaTest = i.alphaTest),
          (d.clipShadows = i.clipShadows),
          (d.clippingPlanes = i.clippingPlanes),
          (d.clipIntersection = i.clipIntersection),
          (d.displacementMap = i.displacementMap),
          (d.displacementScale = i.displacementScale),
          (d.displacementBias = i.displacementBias),
          (d.wireframeLinewidth = i.wireframeLinewidth),
          (d.linewidth = i.linewidth),
          !0 === r.isPointLight &&
            !0 === d.isMeshDistanceMaterial &&
            (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
            (d.nearDistance = s),
            (d.farDistance = a)),
          d
        );
      }
      function x(n, r, s, a, o) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && 3 === o)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            s.matrixWorldInverse,
            n.matrixWorld
          );
          const i = t.update(n),
            r = n.material;
          if (Array.isArray(r)) {
            const t = i.groups;
            for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l],
                h = r[c.materialIndex];
              if (h && h.visible) {
                const t = _(n, 0, h, a, s.near, s.far, o);
                e.renderBufferDirect(s, null, i, t, n, c);
              }
            }
          } else if (r.visible) {
            const t = _(n, 0, r, a, s.near, s.far, o);
            e.renderBufferDirect(s, null, i, t, n, null);
          }
        }
        const l = n.children;
        for (let e = 0, t = l.length; e < t; e++) x(l[e], r, s, a, o);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1),
        (this.render = function (t, n, o) {
          if (!1 === g.enabled) return;
          if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
          if (0 === t.length) return;
          const l = e.getRenderTarget(),
            c = e.getActiveCubeFace(),
            u = e.getActiveMipmapLevel(),
            d = e.state;
          d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
          for (let l = 0, c = t.length; l < c; l++) {
            const c = t[l],
              u = c.shadow;
            if (void 0 === u) {
              console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
              continue;
            }
            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
            r.copy(u.mapSize);
            const p = u.getFrameExtents();
            if (
              (r.multiply(p),
              s.copy(u.mapSize),
              (r.x > h || r.y > h) &&
                (r.x > h &&
                  ((s.x = Math.floor(h / p.x)),
                  (r.x = s.x * p.x),
                  (u.mapSize.x = s.x)),
                r.y > h &&
                  ((s.y = Math.floor(h / p.y)),
                  (r.y = s.y * p.y),
                  (u.mapSize.y = s.y))),
              null === u.map && !u.isPointLightShadow && 3 === this.type)
            ) {
              const e = { minFilter: 1006, magFilter: 1006, format: 1023 };
              (u.map = new N(r.x, r.y, e)),
                (u.map.texture.name = c.name + ".shadowMap"),
                (u.mapPass = new N(r.x, r.y, e)),
                u.camera.updateProjectionMatrix();
            }
            if (null === u.map) {
              const e = { minFilter: 1003, magFilter: 1003, format: 1023 };
              (u.map = new N(r.x, r.y, e)),
                (u.map.texture.name = c.name + ".shadowMap"),
                u.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(u.map), e.clear();
            const m = u.getViewportCount();
            for (let e = 0; e < m; e++) {
              const t = u.getViewport(e);
              a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                d.viewport(a),
                u.updateMatrices(c, e),
                (i = u.getFrustum()),
                x(n, o, u.camera, c, this.type);
            }
            u.isPointLightShadow || 3 !== this.type || v(u, o),
              (u.needsUpdate = !1);
          }
          (g.needsUpdate = !1), e.setRenderTarget(l, c, u);
        });
    }
    function Fr(e, t, n) {
      const i = n.isWebGL2;
      const r = new (function () {
          let t = !1;
          const n = new D();
          let i = null;
          const r = new D(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || t || (e.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t, i, s, a, o) {
              !0 === o && ((t *= a), (i *= a), (s *= a)),
                n.set(t, i, s, a),
                !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
            },
            reset: function () {
              (t = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        })(),
        s = new (function () {
          let t = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (e) {
              e ? F(2929) : B(2929);
            },
            setMask: function (i) {
              n === i || t || (e.depthMask(i), (n = i));
            },
            setFunc: function (t) {
              if (i !== t) {
                if (t)
                  switch (t) {
                    case 0:
                      e.depthFunc(512);
                      break;
                    case 1:
                      e.depthFunc(519);
                      break;
                    case 2:
                      e.depthFunc(513);
                      break;
                    case 3:
                      e.depthFunc(515);
                      break;
                    case 4:
                      e.depthFunc(514);
                      break;
                    case 5:
                      e.depthFunc(518);
                      break;
                    case 6:
                      e.depthFunc(516);
                      break;
                    case 7:
                      e.depthFunc(517);
                      break;
                    default:
                      e.depthFunc(515);
                  }
                else e.depthFunc(515);
                i = t;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              r !== t && (e.clearDepth(t), (r = t));
            },
            reset: function () {
              (t = !1), (n = null), (i = null), (r = null);
            },
          };
        })(),
        a = new (function () {
          let t = !1,
            n = null,
            i = null,
            r = null,
            s = null,
            a = null,
            o = null,
            l = null,
            c = null;
          return {
            setTest: function (e) {
              t || (e ? F(2960) : B(2960));
            },
            setMask: function (i) {
              n === i || t || (e.stencilMask(i), (n = i));
            },
            setFunc: function (t, n, a) {
              (i === t && r === n && s === a) ||
                (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
            },
            setOp: function (t, n, i) {
              (a === t && o === n && l === i) ||
                (e.stencilOp(t, n, i), (a = t), (o = n), (l = i));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              c !== t && (e.clearStencil(t), (c = t));
            },
            reset: function () {
              (t = !1),
                (n = null),
                (i = null),
                (r = null),
                (s = null),
                (a = null),
                (o = null),
                (l = null),
                (c = null);
            },
          };
        })();
      let o = {},
        l = {},
        c = null,
        h = !1,
        u = null,
        d = null,
        p = null,
        m = null,
        f = null,
        g = null,
        v = null,
        _ = !1,
        x = null,
        y = null,
        b = null,
        w = null,
        M = null;
      const S = e.getParameter(35661);
      let T = !1,
        E = 0;
      const A = e.getParameter(7938);
      -1 !== A.indexOf("WebGL")
        ? ((E = parseFloat(/^WebGL (\d)/.exec(A)[1])), (T = E >= 1))
        : -1 !== A.indexOf("OpenGL ES") &&
          ((E = parseFloat(/^OpenGL ES (\d)/.exec(A)[1])), (T = E >= 2));
      let L = null,
        R = {};
      const C = e.getParameter(3088),
        P = e.getParameter(2978),
        I = new D().fromArray(C),
        N = new D().fromArray(P);
      function O(t, n, i) {
        const r = new Uint8Array(4),
          s = e.createTexture();
        e.bindTexture(t, s),
          e.texParameteri(t, 10241, 9728),
          e.texParameteri(t, 10240, 9728);
        for (let t = 0; t < i; t++)
          e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return s;
      }
      const z = {};
      function F(t) {
        !0 !== o[t] && (e.enable(t), (o[t] = !0));
      }
      function B(t) {
        !1 !== o[t] && (e.disable(t), (o[t] = !1));
      }
      (z[3553] = O(3553, 3553, 1)),
        (z[34067] = O(34067, 34069, 6)),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        a.setClear(0),
        F(2929),
        s.setFunc(3),
        G(!1),
        V(1),
        F(2884),
        k(0);
      const U = { 100: 32774, 101: 32778, 102: 32779 };
      if (i) (U[103] = 32775), (U[104] = 32776);
      else {
        const e = t.get("EXT_blend_minmax");
        null !== e && ((U[103] = e.MIN_EXT), (U[104] = e.MAX_EXT));
      }
      const H = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773,
      };
      function k(t, n, i, r, s, a, o, l) {
        if (0 !== t) {
          if ((!1 === h && (F(3042), (h = !0)), 5 === t))
            (s = s || n),
              (a = a || i),
              (o = o || r),
              (n === d && s === f) ||
                (e.blendEquationSeparate(U[n], U[s]), (d = n), (f = s)),
              (i === p && r === m && a === g && o === v) ||
                (e.blendFuncSeparate(H[i], H[r], H[a], H[o]),
                (p = i),
                (m = r),
                (g = a),
                (v = o)),
              (u = t),
              (_ = null);
          else if (t !== u || l !== _) {
            if (
              ((100 === d && 100 === f) ||
                (e.blendEquation(32774), (d = 100), (f = 100)),
              l)
            )
              switch (t) {
                case 1:
                  e.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(1, 1);
                  break;
                case 3:
                  e.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  e.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            else
              switch (t) {
                case 1:
                  e.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  e.blendFunc(770, 1);
                  break;
                case 3:
                  e.blendFunc(0, 769);
                  break;
                case 4:
                  e.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            (p = null), (m = null), (g = null), (v = null), (u = t), (_ = l);
          }
        } else !0 === h && (B(3042), (h = !1));
      }
      function G(t) {
        x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (x = t));
      }
      function V(t) {
        0 !== t
          ? (F(2884),
            t !== y &&
              (1 === t
                ? e.cullFace(1029)
                : 2 === t
                ? e.cullFace(1028)
                : e.cullFace(1032)))
          : B(2884),
          (y = t);
      }
      function W(t, n, i) {
        t
          ? (F(32823),
            (w === n && M === i) || (e.polygonOffset(n, i), (w = n), (M = i)))
          : B(32823);
      }
      function j(t) {
        void 0 === t && (t = 33984 + S - 1),
          L !== t && (e.activeTexture(t), (L = t));
      }
      return {
        buffers: { color: r, depth: s, stencil: a },
        enable: F,
        disable: B,
        bindFramebuffer: function (t, n) {
          return (
            l[t] !== n &&
            (e.bindFramebuffer(t, n),
            (l[t] = n),
            i && (36009 === t && (l[36160] = n), 36160 === t && (l[36009] = n)),
            !0)
          );
        },
        useProgram: function (t) {
          return c !== t && (e.useProgram(t), (c = t), !0);
        },
        setBlending: k,
        setMaterial: function (e, t) {
          2 === e.side ? B(2884) : F(2884);
          let n = 1 === e.side;
          t && (n = !n),
            G(n),
            1 === e.blending && !1 === e.transparent
              ? k(0)
              : k(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            s.setFunc(e.depthFunc),
            s.setTest(e.depthTest),
            s.setMask(e.depthWrite),
            r.setMask(e.colorWrite);
          const i = e.stencilWrite;
          a.setTest(i),
            i &&
              (a.setMask(e.stencilWriteMask),
              a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? F(32926) : B(32926);
        },
        setFlipSided: G,
        setCullFace: V,
        setLineWidth: function (t) {
          t !== b && (T && e.lineWidth(t), (b = t));
        },
        setPolygonOffset: W,
        setScissorTest: function (e) {
          e ? F(3089) : B(3089);
        },
        activeTexture: j,
        bindTexture: function (t, n) {
          null === L && j();
          let i = R[L];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (R[L] = i)),
            (i.type === t && i.texture === n) ||
              (e.bindTexture(t, n || z[t]), (i.type = t), (i.texture = n));
        },
        unbindTexture: function () {
          const t = R[L];
          void 0 !== t &&
            void 0 !== t.type &&
            (e.bindTexture(t.type, null),
            (t.type = void 0),
            (t.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage2D: function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage3D: function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texStorage2D: function () {
          try {
            e.texStorage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texSubImage2D: function () {
          try {
            e.texSubImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        scissor: function (t) {
          !1 === I.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), I.copy(t));
        },
        viewport: function (t) {
          !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), N.copy(t));
        },
        reset: function () {
          e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === i &&
              (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            (o = {}),
            (L = null),
            (R = {}),
            (l = {}),
            (c = null),
            (h = !1),
            (u = null),
            (d = null),
            (p = null),
            (m = null),
            (f = null),
            (g = null),
            (v = null),
            (_ = !1),
            (x = null),
            (y = null),
            (b = null),
            (w = null),
            (M = null),
            I.set(0, 0, e.canvas.width, e.canvas.height),
            N.set(0, 0, e.canvas.width, e.canvas.height),
            r.reset(),
            s.reset(),
            a.reset();
        },
      };
    }
    function Br(e, t, n, i, r, s, a) {
      const o = r.isWebGL2,
        l = r.maxTextures,
        c = r.maxCubemapSize,
        h = r.maxTextureSize,
        u = r.maxSamples,
        d = t.has("WEBGL_multisampled_render_to_texture")
          ? t.get("WEBGL_multisampled_render_to_texture")
          : void 0,
        p = new WeakMap();
      let m,
        f = !1;
      try {
        f =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (e) {}
      function g(e, t) {
        return f ? new OffscreenCanvas(e, t) : E("canvas");
      }
      function v(e, t, n, i) {
        let r = 1;
        if (
          ((e.width > i || e.height > i) &&
            (r = i / Math.max(e.width, e.height)),
          r < 1 || !0 === t)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const i = t ? b : Math.floor,
              s = i(r * e.width),
              a = i(r * e.height);
            void 0 === m && (m = g(s, a));
            const o = n ? g(s, a) : m;
            (o.width = s), (o.height = a);
            return (
              o.getContext("2d").drawImage(e, 0, 0, s, a),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  e.width +
                  "x" +
                  e.height +
                  ") to (" +
                  s +
                  "x" +
                  a +
                  ")."
              ),
              o
            );
          }
          return (
            "data" in e &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  e.width +
                  "x" +
                  e.height +
                  ")."
              ),
            e
          );
        }
        return e;
      }
      function _(e) {
        return x(e.width) && x(e.height);
      }
      function y(e, t) {
        return (
          e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        );
      }
      function w(t) {
        e.generateMipmap(t);
      }
      function M(n, i, r) {
        if (!1 === o) return i;
        if (null !== n) {
          if (void 0 !== e[n]) return e[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let s = i;
        return (
          6403 === i &&
            (5126 === r && (s = 33326),
            5131 === r && (s = 33325),
            5121 === r && (s = 33321)),
          6407 === i &&
            (5126 === r && (s = 34837),
            5131 === r && (s = 34843),
            5121 === r && (s = 32849)),
          6408 === i &&
            (5126 === r && (s = 34836),
            5131 === r && (s = 34842),
            5121 === r && (s = 32856)),
          (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) ||
            t.get("EXT_color_buffer_float"),
          s
        );
      }
      function S(e) {
        return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729;
      }
      function T(t) {
        const n = t.target;
        n.removeEventListener("dispose", T),
          (function (t) {
            const n = i.get(t);
            if (void 0 === n.__webglInit) return;
            e.deleteTexture(n.__webglTexture), i.remove(t);
          })(n),
          n.isVideoTexture && p.delete(n),
          a.memory.textures--;
      }
      function A(t) {
        const n = t.target;
        n.removeEventListener("dispose", A),
          (function (t) {
            const n = t.texture,
              r = i.get(t),
              s = i.get(n);
            if (!t) return;
            void 0 !== s.__webglTexture &&
              (e.deleteTexture(s.__webglTexture), a.memory.textures--);
            t.depthTexture && t.depthTexture.dispose();
            if (t.isWebGLCubeRenderTarget)
              for (let t = 0; t < 6; t++)
                e.deleteFramebuffer(r.__webglFramebuffer[t]),
                  r.__webglDepthbuffer &&
                    e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
            else
              e.deleteFramebuffer(r.__webglFramebuffer),
                r.__webglDepthbuffer &&
                  e.deleteRenderbuffer(r.__webglDepthbuffer),
                r.__webglMultisampledFramebuffer &&
                  e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                r.__webglColorRenderbuffer &&
                  e.deleteRenderbuffer(r.__webglColorRenderbuffer),
                r.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
            if (t.isWebGLMultipleRenderTargets)
              for (let t = 0, r = n.length; t < r; t++) {
                const r = i.get(n[t]);
                r.__webglTexture &&
                  (e.deleteTexture(r.__webglTexture), a.memory.textures--),
                  i.remove(n[t]);
              }
            i.remove(n), i.remove(t);
          })(n);
      }
      let L = 0;
      function R(e, t) {
        const r = i.get(e);
        if (
          (e.isVideoTexture &&
            (function (e) {
              const t = a.render.frame;
              p.get(e) !== t && (p.set(e, t), e.update());
            })(e),
          e.version > 0 && r.__version !== e.version)
        ) {
          const n = e.image;
          if (void 0 === n)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== n.complete) return void O(r, e, t);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture);
      }
      function C(t, r) {
        const a = i.get(t);
        t.version > 0 && a.__version !== t.version
          ? (function (t, i, r) {
              if (6 !== i.image.length) return;
              N(t, i),
                n.activeTexture(33984 + r),
                n.bindTexture(34067, t.__webglTexture),
                e.pixelStorei(37440, i.flipY),
                e.pixelStorei(37441, i.premultiplyAlpha),
                e.pixelStorei(3317, i.unpackAlignment),
                e.pixelStorei(37443, 0);
              const a =
                  i &&
                  (i.isCompressedTexture || i.image[0].isCompressedTexture),
                l = i.image[0] && i.image[0].isDataTexture,
                h = [];
              for (let e = 0; e < 6; e++)
                h[e] =
                  a || l
                    ? l
                      ? i.image[e].image
                      : i.image[e]
                    : v(i.image[e], !1, !0, c);
              const u = _(h[0]) || o,
                d = s.convert(i.format),
                p = s.convert(i.type),
                m = M(i.internalFormat, d, p, i.encoding);
              let f;
              if ((D(34067, i, u), a))
                for (let e = 0; e < 6; e++) {
                  f = h[e].mipmaps;
                  for (let t = 0; t < f.length; t++) {
                    const r = f[t];
                    1023 !== i.format && 1022 !== i.format
                      ? null !== d
                        ? n.compressedTexImage2D(
                            34069 + e,
                            t,
                            m,
                            r.width,
                            r.height,
                            0,
                            r.data
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : n.texImage2D(
                          34069 + e,
                          t,
                          m,
                          r.width,
                          r.height,
                          0,
                          d,
                          p,
                          r.data
                        );
                  }
                }
              else {
                f = i.mipmaps;
                for (let e = 0; e < 6; e++)
                  if (l) {
                    n.texImage2D(
                      34069 + e,
                      0,
                      m,
                      h[e].width,
                      h[e].height,
                      0,
                      d,
                      p,
                      h[e].data
                    );
                    for (let t = 0; t < f.length; t++) {
                      const i = f[t].image[e].image;
                      n.texImage2D(
                        34069 + e,
                        t + 1,
                        m,
                        i.width,
                        i.height,
                        0,
                        d,
                        p,
                        i.data
                      );
                    }
                  } else {
                    n.texImage2D(34069 + e, 0, m, d, p, h[e]);
                    for (let t = 0; t < f.length; t++) {
                      const i = f[t];
                      n.texImage2D(34069 + e, t + 1, m, d, p, i.image[e]);
                    }
                  }
              }
              y(i, u) && w(34067);
              (t.__version = i.version), i.onUpdate && i.onUpdate(i);
            })(a, t, r)
          : (n.activeTexture(33984 + r),
            n.bindTexture(34067, a.__webglTexture));
      }
      const P = { 1e3: 10497, 1001: 33071, 1002: 33648 },
        I = {
          1003: 9728,
          1004: 9984,
          1005: 9986,
          1006: 9729,
          1007: 9985,
          1008: 9987,
        };
      function D(n, s, a) {
        if (
          (a
            ? (e.texParameteri(n, 10242, P[s.wrapS]),
              e.texParameteri(n, 10243, P[s.wrapT]),
              (32879 !== n && 35866 !== n) ||
                e.texParameteri(n, 32882, P[s.wrapR]),
              e.texParameteri(n, 10240, I[s.magFilter]),
              e.texParameteri(n, 10241, I[s.minFilter]))
            : (e.texParameteri(n, 10242, 33071),
              e.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
              (1001 === s.wrapS && 1001 === s.wrapT) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              e.texParameteri(n, 10240, S(s.magFilter)),
              e.texParameteri(n, 10241, S(s.minFilter)),
              1003 !== s.minFilter &&
                1006 !== s.minFilter &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          !0 === t.has("EXT_texture_filter_anisotropic"))
        ) {
          const a = t.get("EXT_texture_filter_anisotropic");
          if (1015 === s.type && !1 === t.has("OES_texture_float_linear"))
            return;
          if (
            !1 === o &&
            1016 === s.type &&
            !1 === t.has("OES_texture_half_float_linear")
          )
            return;
          (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
            (e.texParameterf(
              n,
              a.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(s.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(s).__currentAnisotropy = s.anisotropy));
        }
      }
      function N(t, n) {
        void 0 === t.__webglInit &&
          ((t.__webglInit = !0),
          n.addEventListener("dispose", T),
          (t.__webglTexture = e.createTexture()),
          a.memory.textures++);
      }
      function O(t, i, r) {
        let a = 3553;
        i.isDataTexture2DArray && (a = 35866),
          i.isDataTexture3D && (a = 32879),
          N(t, i),
          n.activeTexture(33984 + r),
          n.bindTexture(a, t.__webglTexture),
          e.pixelStorei(37440, i.flipY),
          e.pixelStorei(37441, i.premultiplyAlpha),
          e.pixelStorei(3317, i.unpackAlignment),
          e.pixelStorei(37443, 0);
        const l =
            (function (e) {
              return (
                !o &&
                (1001 !== e.wrapS ||
                  1001 !== e.wrapT ||
                  (1003 !== e.minFilter && 1006 !== e.minFilter))
              );
            })(i) && !1 === _(i.image),
          c = v(i.image, l, !1, h),
          u = _(c) || o,
          d = s.convert(i.format);
        let p,
          m = s.convert(i.type),
          f = M(i.internalFormat, d, m, i.encoding);
        D(a, i, u);
        const g = i.mipmaps;
        if (i.isDepthTexture)
          (f = 6402),
            o
              ? (f =
                  1015 === i.type
                    ? 36012
                    : 1014 === i.type
                    ? 33190
                    : 1020 === i.type
                    ? 35056
                    : 33189)
              : 1015 === i.type &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            1026 === i.format &&
              6402 === f &&
              1012 !== i.type &&
              1014 !== i.type &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (i.type = 1012),
              (m = s.convert(i.type))),
            1027 === i.format &&
              6402 === f &&
              ((f = 34041),
              1020 !== i.type &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (i.type = 1020),
                (m = s.convert(i.type)))),
            n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
        else if (i.isDataTexture)
          if (g.length > 0 && u) {
            for (let e = 0, t = g.length; e < t; e++)
              (p = g[e]),
                n.texImage2D(3553, e, f, p.width, p.height, 0, d, m, p.data);
            i.generateMipmaps = !1;
          } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data);
        else if (i.isCompressedTexture)
          for (let e = 0, t = g.length; e < t; e++)
            (p = g[e]),
              1023 !== i.format && 1022 !== i.format
                ? null !== d
                  ? n.compressedTexImage2D(
                      3553,
                      e,
                      f,
                      p.width,
                      p.height,
                      0,
                      p.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, e, f, p.width, p.height, 0, d, m, p.data);
        else if (i.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            f,
            c.width,
            c.height,
            c.depth,
            0,
            d,
            m,
            c.data
          );
        else if (i.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            f,
            c.width,
            c.height,
            c.depth,
            0,
            d,
            m,
            c.data
          );
        else {
          const e = (function (e, t, n) {
              return !0 === y(e, n)
                ? Math.log2(Math.max(t.width, t.height)) + 1
                : e.mipmaps.length > 0
                ? e.mipmaps.length
                : 1;
            })(i, c, u),
            r = o && !0 !== i.isVideoTexture,
            s = void 0 === t.__version;
          if (g.length > 0 && u) {
            r && s && n.texStorage2D(3553, e, f, g[0].width, g[0].height);
            for (let e = 0, t = g.length; e < t; e++)
              (p = g[e]),
                r
                  ? n.texSubImage2D(3553, e, 0, 0, d, m, p)
                  : n.texImage2D(3553, e, f, d, m, p);
            i.generateMipmaps = !1;
          } else
            r
              ? (s && n.texStorage2D(3553, e, f, c.width, c.height),
                n.texSubImage2D(3553, 0, 0, 0, d, m, c))
              : n.texImage2D(3553, 0, f, d, m, c);
        }
        y(i, u) && w(a), (t.__version = i.version), i.onUpdate && i.onUpdate(i);
      }
      function z(t, r, a, o, l) {
        const c = s.convert(a.format),
          h = s.convert(a.type),
          u = M(a.internalFormat, c, h, a.encoding);
        i.get(r).__hasExternalTextures ||
          (32879 === l || 35866 === l
            ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null)
            : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)),
          n.bindFramebuffer(36160, t),
          r.useRenderToTexture
            ? d.framebufferTexture2DMultisampleEXT(
                36160,
                o,
                l,
                i.get(a).__webglTexture,
                0,
                U(r)
              )
            : e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),
          n.bindFramebuffer(36160, null);
      }
      function F(t, n, i) {
        if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
          let r = 33189;
          if (i || n.useRenderToTexture) {
            const t = n.depthTexture;
            t &&
              t.isDepthTexture &&
              (1015 === t.type ? (r = 36012) : 1014 === t.type && (r = 33190));
            const i = U(n);
            n.useRenderToTexture
              ? d.renderbufferStorageMultisampleEXT(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height
                )
              : e.renderbufferStorageMultisample(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height
                );
          } else e.renderbufferStorage(36161, r, n.width, n.height);
          e.framebufferRenderbuffer(36160, 36096, 36161, t);
        } else if (n.depthBuffer && n.stencilBuffer) {
          const r = U(n);
          i && n.useRenderbuffer
            ? e.renderbufferStorageMultisample(
                36161,
                r,
                35056,
                n.width,
                n.height
              )
            : n.useRenderToTexture
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                r,
                35056,
                n.width,
                n.height
              )
            : e.renderbufferStorage(36161, 34041, n.width, n.height),
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
        } else {
          const t =
              !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
            r = s.convert(t.format),
            a = s.convert(t.type),
            o = M(t.internalFormat, r, a, t.encoding),
            l = U(n);
          i && n.useRenderbuffer
            ? e.renderbufferStorageMultisample(36161, l, o, n.width, n.height)
            : n.useRenderToTexture
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                l,
                o,
                n.width,
                n.height
              )
            : e.renderbufferStorage(36161, o, n.width, n.height);
        }
        e.bindRenderbuffer(36161, null);
      }
      function B(t) {
        const r = i.get(t),
          s = !0 === t.isWebGLCubeRenderTarget;
        if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
          if (s)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (t, r) {
            if (r && r.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (n.bindFramebuffer(36160, t),
              !r.depthTexture || !r.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (i.get(r.depthTexture).__webglTexture &&
              r.depthTexture.image.width === r.width &&
              r.depthTexture.image.height === r.height) ||
              ((r.depthTexture.image.width = r.width),
              (r.depthTexture.image.height = r.height),
              (r.depthTexture.needsUpdate = !0)),
              R(r.depthTexture, 0);
            const s = i.get(r.depthTexture).__webglTexture,
              a = U(r);
            if (1026 === r.depthTexture.format)
              r.useRenderToTexture
                ? d.framebufferTexture2DMultisampleEXT(
                    36160,
                    36096,
                    3553,
                    s,
                    0,
                    a
                  )
                : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
            else {
              if (1027 !== r.depthTexture.format)
                throw new Error("Unknown depthTexture format");
              r.useRenderToTexture
                ? d.framebufferTexture2DMultisampleEXT(
                    36160,
                    33306,
                    3553,
                    s,
                    0,
                    a
                  )
                : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
            }
          })(r.__webglFramebuffer, t);
        } else if (s) {
          r.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++)
            n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
              (r.__webglDepthbuffer[i] = e.createRenderbuffer()),
              F(r.__webglDepthbuffer[i], t, !1);
        } else
          n.bindFramebuffer(36160, r.__webglFramebuffer),
            (r.__webglDepthbuffer = e.createRenderbuffer()),
            F(r.__webglDepthbuffer, t, !1);
        n.bindFramebuffer(36160, null);
      }
      function U(e) {
        return o && (e.useRenderbuffer || e.useRenderToTexture)
          ? Math.min(u, e.samples)
          : 0;
      }
      let H = !1,
        k = !1;
      (this.allocateTextureUnit = function () {
        const e = L;
        return (
          e >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                e +
                " texture units while this GPU supports only " +
                l
            ),
          (L += 1),
          e
        );
      }),
        (this.resetTextureUnits = function () {
          L = 0;
        }),
        (this.setTexture2D = R),
        (this.setTexture2DArray = function (e, t) {
          const r = i.get(e);
          e.version > 0 && r.__version !== e.version
            ? O(r, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(35866, r.__webglTexture));
        }),
        (this.setTexture3D = function (e, t) {
          const r = i.get(e);
          e.version > 0 && r.__version !== e.version
            ? O(r, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(32879, r.__webglTexture));
        }),
        (this.setTextureCube = C),
        (this.rebindTextures = function (e, t, n) {
          const r = i.get(e);
          void 0 !== t && z(r.__webglFramebuffer, e, e.texture, 36064, 3553),
            void 0 !== n && B(e);
        }),
        (this.setupRenderTarget = function (t) {
          const l = t.texture,
            c = i.get(t),
            h = i.get(l);
          t.addEventListener("dispose", A),
            !0 !== t.isWebGLMultipleRenderTargets &&
              (void 0 === h.__webglTexture &&
                (h.__webglTexture = e.createTexture()),
              (h.__version = l.version),
              a.memory.textures++);
          const u = !0 === t.isWebGLCubeRenderTarget,
            d = !0 === t.isWebGLMultipleRenderTargets,
            p = l.isDataTexture3D || l.isDataTexture2DArray,
            m = _(t) || o;
          if (
            (!o ||
              1022 !== l.format ||
              (1015 !== l.type && 1016 !== l.type) ||
              ((l.format = 1023),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            u)
          ) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++)
              c.__webglFramebuffer[t] = e.createFramebuffer();
          } else if (((c.__webglFramebuffer = e.createFramebuffer()), d))
            if (r.drawBuffers) {
              const n = t.texture;
              for (let t = 0, r = n.length; t < r; t++) {
                const r = i.get(n[t]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = e.createTexture()), a.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (t.useRenderbuffer)
            if (o) {
              (c.__webglMultisampledFramebuffer = e.createFramebuffer()),
                (c.__webglColorRenderbuffer = e.createRenderbuffer()),
                e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
              const i = s.convert(l.format),
                r = s.convert(l.type),
                a = M(l.internalFormat, i, r, l.encoding),
                o = U(t);
              e.renderbufferStorageMultisample(36161, o, a, t.width, t.height),
                n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                e.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  c.__webglColorRenderbuffer
                ),
                e.bindRenderbuffer(36161, null),
                t.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = e.createRenderbuffer()),
                  F(c.__webglDepthRenderbuffer, t, !0)),
                n.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (u) {
            n.bindTexture(34067, h.__webglTexture), D(34067, l, m);
            for (let e = 0; e < 6; e++)
              z(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            y(l, m) && w(34067), n.unbindTexture();
          } else if (d) {
            const e = t.texture;
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r],
                a = i.get(s);
              n.bindTexture(3553, a.__webglTexture),
                D(3553, s, m),
                z(c.__webglFramebuffer, t, s, 36064 + r, 3553),
                y(s, m) && w(3553);
            }
            n.unbindTexture();
          } else {
            let e = 3553;
            if (p)
              if (o) {
                e = l.isDataTexture3D ? 32879 : 35866;
              } else
                console.warn(
                  "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                );
            n.bindTexture(e, h.__webglTexture),
              D(e, l, m),
              z(c.__webglFramebuffer, t, l, 36064, e),
              y(l, m) && w(e),
              n.unbindTexture();
          }
          t.depthBuffer && B(t);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const t = _(e) || o,
            r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
          for (let s = 0, a = r.length; s < a; s++) {
            const a = r[s];
            if (y(a, t)) {
              const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                r = i.get(a).__webglTexture;
              n.bindTexture(t, r), w(t), n.unbindTexture();
            }
          }
        }),
        (this.updateMultisampleRenderTarget = function (t) {
          if (t.useRenderbuffer)
            if (o) {
              const r = t.width,
                s = t.height;
              let a = 16384;
              const o = [36064],
                l = t.stencilBuffer ? 33306 : 36096;
              t.depthBuffer && o.push(l),
                t.ignoreDepthForMultisampleCopy ||
                  (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024));
              const c = i.get(t);
              n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, c.__webglFramebuffer),
                t.ignoreDepthForMultisampleCopy &&
                  (e.invalidateFramebuffer(36008, [l]),
                  e.invalidateFramebuffer(36009, [l])),
                e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                e.invalidateFramebuffer(36008, o),
                n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.setupDepthRenderbuffer = B),
        (this.setupFrameBufferTexture = z),
        (this.safeSetTexture2D = function (e, t) {
          e &&
            e.isWebGLRenderTarget &&
            (!1 === H &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (H = !0)),
            (e = e.texture)),
            R(e, t);
        }),
        (this.safeSetTextureCube = function (e, t) {
          e &&
            e.isWebGLCubeRenderTarget &&
            (!1 === k &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (k = !0)),
            (e = e.texture)),
            C(e, t);
        });
    }
    function Ur(e, t, n) {
      const i = n.isWebGL2;
      return {
        convert: function (e) {
          let n;
          if (1009 === e) return 5121;
          if (1017 === e) return 32819;
          if (1018 === e) return 32820;
          if (1019 === e) return 33635;
          if (1010 === e) return 5120;
          if (1011 === e) return 5122;
          if (1012 === e) return 5123;
          if (1013 === e) return 5124;
          if (1014 === e) return 5125;
          if (1015 === e) return 5126;
          if (1016 === e)
            return i
              ? 5131
              : ((n = t.get("OES_texture_half_float")),
                null !== n ? n.HALF_FLOAT_OES : null);
          if (1021 === e) return 6406;
          if (1022 === e) return 6407;
          if (1023 === e) return 6408;
          if (1024 === e) return 6409;
          if (1025 === e) return 6410;
          if (1026 === e) return 6402;
          if (1027 === e) return 34041;
          if (1028 === e) return 6403;
          if (1029 === e) return 36244;
          if (1030 === e) return 33319;
          if (1031 === e) return 33320;
          if (1032 === e) return 36248;
          if (1033 === e) return 36249;
          if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
            if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
              return null;
            if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
            if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
              return null;
            if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === e)
            return (
              (n = t.get("WEBGL_compressed_texture_etc1")),
              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (37492 === e || 37496 === e) &&
            ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
          ) {
            if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
            if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return 37808 === e ||
            37809 === e ||
            37810 === e ||
            37811 === e ||
            37812 === e ||
            37813 === e ||
            37814 === e ||
            37815 === e ||
            37816 === e ||
            37817 === e ||
            37818 === e ||
            37819 === e ||
            37820 === e ||
            37821 === e ||
            37840 === e ||
            37841 === e ||
            37842 === e ||
            37843 === e ||
            37844 === e ||
            37845 === e ||
            37846 === e ||
            37847 === e ||
            37848 === e ||
            37849 === e ||
            37850 === e ||
            37851 === e ||
            37852 === e ||
            37853 === e
            ? ((n = t.get("WEBGL_compressed_texture_astc")),
              null !== n ? e : null)
            : 36492 === e
            ? ((n = t.get("EXT_texture_compression_bptc")),
              null !== n ? e : null)
            : 1020 === e
            ? i
              ? 34042
              : ((n = t.get("WEBGL_depth_texture")),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        },
      };
    }
    class Hr extends qt {
      constructor(e = []) {
        super(), (this.cameras = e);
      }
    }
    Hr.prototype.isArrayCamera = !0;
    class kr extends Ue {
      constructor() {
        super(), (this.type = "Group");
      }
    }
    kr.prototype.isGroup = !0;
    const Gr = { type: "move" };
    class Vr {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new kr()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = { pinching: !1 })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new kr()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new F()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new F())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new kr()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new F()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new F())),
          this._grip
        );
      }
      dispatchEvent(e) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
        );
      }
      disconnect(e) {
        return (
          this.dispatchEvent({ type: "disconnected", data: e }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(e, t, n) {
        let i = null,
          r = null,
          s = null;
        const a = this._targetRay,
          o = this._grip,
          l = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState)
          if (
            (null !== a &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null !== i &&
                (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                i.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(i.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(i.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(Gr))),
            l && e.hand)
          ) {
            s = !0;
            for (const i of e.hand.values()) {
              const e = t.getJointPose(i, n);
              if (void 0 === l.joints[i.jointName]) {
                const e = new kr();
                (e.matrixAutoUpdate = !1),
                  (e.visible = !1),
                  (l.joints[i.jointName] = e),
                  l.add(e);
              }
              const r = l.joints[i.jointName];
              null !== e &&
                (r.matrix.fromArray(e.transform.matrix),
                r.matrix.decompose(r.position, r.rotation, r.scale),
                (r.jointRadius = e.radius)),
                (r.visible = null !== e);
            }
            const i = l.joints["index-finger-tip"],
              r = l.joints["thumb-tip"],
              a = i.position.distanceTo(r.position),
              o = 0.02,
              c = 0.005;
            l.inputState.pinching && a > o + c
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this,
                }))
              : !l.inputState.pinching &&
                a <= o - c &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this,
                }));
          } else
            null !== o &&
              e.gripSpace &&
              ((r = t.getPose(e.gripSpace, n)),
              null !== r &&
                (o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                r.linearVelocity
                  ? ((o.hasLinearVelocity = !0),
                    o.linearVelocity.copy(r.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((o.hasAngularVelocity = !0),
                    o.angularVelocity.copy(r.angularVelocity))
                  : (o.hasAngularVelocity = !1)));
        return (
          null !== a && (a.visible = null !== i),
          null !== o && (o.visible = null !== r),
          null !== l && (l.visible = null !== s),
          this
        );
      }
    }
    class Wr extends P {
      constructor(e, t, n, i, r, s, a, o, l, c) {
        if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && 1026 === c && (n = 1012),
          void 0 === n && 1027 === c && (n = 1020),
          super(null, i, r, s, a, o, c, n, l),
          (this.image = { width: e, height: t }),
          (this.magFilter = void 0 !== a ? a : 1003),
          (this.minFilter = void 0 !== o ? o : 1003),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    Wr.prototype.isDepthTexture = !0;
    class jr extends h {
      constructor(e, t) {
        super();
        const n = this;
        let i = null,
          r = 1,
          s = null,
          a = "local-floor";
        const o = e.extensions.has("WEBGL_multisampled_render_to_texture");
        let l = null,
          c = null,
          h = null,
          u = null,
          d = !1,
          p = null;
        const m = t.getContextAttributes();
        let f = null,
          g = null;
        const v = [],
          _ = new Map(),
          x = new qt();
        x.layers.enable(1), (x.viewport = new D());
        const y = new qt();
        y.layers.enable(2), (y.viewport = new D());
        const b = [x, y],
          w = new Hr();
        w.layers.enable(1), w.layers.enable(2);
        let M = null,
          S = null;
        function T(e) {
          const t = _.get(e.inputSource);
          t && t.dispatchEvent({ type: e.type, data: e.inputSource });
        }
        function E() {
          _.forEach(function (e, t) {
            e.disconnect(t);
          }),
            _.clear(),
            (M = null),
            (S = null),
            e.setRenderTarget(f),
            (u = null),
            (h = null),
            (c = null),
            (i = null),
            (g = null),
            I.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({ type: "sessionend" });
        }
        function A(e) {
          const t = i.inputSources;
          for (let e = 0; e < v.length; e++) _.set(t[e], v[e]);
          for (let t = 0; t < e.removed.length; t++) {
            const n = e.removed[t],
              i = _.get(n);
            i &&
              (i.dispatchEvent({ type: "disconnected", data: n }), _.delete(n));
          }
          for (let t = 0; t < e.added.length; t++) {
            const n = e.added[t],
              i = _.get(n);
            i && i.dispatchEvent({ type: "connected", data: n });
          }
        }
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            let t = v[e];
            return (
              void 0 === t && ((t = new Vr()), (v[e] = t)),
              t.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (e) {
            let t = v[e];
            return (
              void 0 === t && ((t = new Vr()), (v[e] = t)), t.getGripSpace()
            );
          }),
          (this.getHand = function (e) {
            let t = v[e];
            return (
              void 0 === t && ((t = new Vr()), (v[e] = t)), t.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (r = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (e) {
            (a = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return s;
          }),
          (this.getBaseLayer = function () {
            return null !== h ? h : u;
          }),
          (this.getBinding = function () {
            return c;
          }),
          (this.getFrame = function () {
            return p;
          }),
          (this.getSession = function () {
            return i;
          }),
          (this.setSession = async function (l) {
            if (((i = l), null !== i)) {
              if (
                ((f = e.getRenderTarget()),
                i.addEventListener("select", T),
                i.addEventListener("selectstart", T),
                i.addEventListener("selectend", T),
                i.addEventListener("squeeze", T),
                i.addEventListener("squeezestart", T),
                i.addEventListener("squeezeend", T),
                i.addEventListener("end", E),
                i.addEventListener("inputsourceschange", A),
                !0 !== m.xrCompatible && (await t.makeXRCompatible()),
                void 0 === i.renderState.layers ||
                  !1 === e.capabilities.isWebGL2)
              ) {
                const e = {
                  antialias: void 0 !== i.renderState.layers || m.antialias,
                  alpha: m.alpha,
                  depth: m.depth,
                  stencil: m.stencil,
                  framebufferScaleFactor: r,
                };
                (u = new XRWebGLLayer(i, t, e)),
                  i.updateRenderState({ baseLayer: u }),
                  (g = new N(u.framebufferWidth, u.framebufferHeight));
              } else {
                d = m.antialias;
                let e = null,
                  n = null,
                  s = null;
                m.depth &&
                  ((s = m.stencil ? 35056 : 33189),
                  (e = m.stencil ? 1027 : 1026),
                  (n = m.stencil ? 1020 : 1012));
                const a = {
                  colorFormat: m.alpha || d ? 32856 : 32849,
                  depthFormat: s,
                  scaleFactor: r,
                };
                (c = new XRWebGLBinding(i, t)),
                  (h = c.createProjectionLayer(a)),
                  i.updateRenderState({ layers: [h] }),
                  (g = d
                    ? new O(h.textureWidth, h.textureHeight, {
                        format: 1023,
                        type: 1009,
                        depthTexture: new Wr(
                          h.textureWidth,
                          h.textureHeight,
                          n,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          e
                        ),
                        stencilBuffer: m.stencil,
                        ignoreDepth: h.ignoreDepthValues,
                        useRenderToTexture: o,
                      })
                    : new N(h.textureWidth, h.textureHeight, {
                        format: m.alpha ? 1023 : 1022,
                        type: 1009,
                        depthTexture: new Wr(
                          h.textureWidth,
                          h.textureHeight,
                          n,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          e
                        ),
                        stencilBuffer: m.stencil,
                        ignoreDepth: h.ignoreDepthValues,
                      }));
              }
              this.setFoveation(0),
                (s = await i.requestReferenceSpace(a)),
                I.setContext(i),
                I.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({ type: "sessionstart" });
            }
          });
        const L = new F(),
          R = new F();
        function C(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }
        (this.updateCamera = function (e) {
          if (null === i) return;
          (w.near = y.near = x.near = e.near),
            (w.far = y.far = x.far = e.far),
            (M === w.near && S === w.far) ||
              (i.updateRenderState({ depthNear: w.near, depthFar: w.far }),
              (M = w.near),
              (S = w.far));
          const t = e.parent,
            n = w.cameras;
          C(w, t);
          for (let e = 0; e < n.length; e++) C(n[e], t);
          w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
            e.position.copy(w.position),
            e.quaternion.copy(w.quaternion),
            e.scale.copy(w.scale),
            e.matrix.copy(w.matrix),
            e.matrixWorld.copy(w.matrixWorld);
          const r = e.children;
          for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
          2 === n.length
            ? (function (e, t, n) {
                L.setFromMatrixPosition(t.matrixWorld),
                  R.setFromMatrixPosition(n.matrixWorld);
                const i = L.distanceTo(R),
                  r = t.projectionMatrix.elements,
                  s = n.projectionMatrix.elements,
                  a = r[14] / (r[10] - 1),
                  o = r[14] / (r[10] + 1),
                  l = (r[9] + 1) / r[5],
                  c = (r[9] - 1) / r[5],
                  h = (r[8] - 1) / r[0],
                  u = (s[8] + 1) / s[0],
                  d = a * h,
                  p = a * u,
                  m = i / (-h + u),
                  f = m * -h;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(f),
                  e.translateZ(m),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + m,
                  v = o + m,
                  _ = d - f,
                  x = p + (i - f),
                  y = ((l * o) / v) * g,
                  b = ((c * o) / v) * g;
                e.projectionMatrix.makePerspective(_, x, y, b, g, v);
              })(w, x, y)
            : w.projectionMatrix.copy(x.projectionMatrix);
        }),
          (this.getCamera = function () {
            return w;
          }),
          (this.getFoveation = function () {
            return null !== h
              ? h.fixedFoveation
              : null !== u
              ? u.fixedFoveation
              : void 0;
          }),
          (this.setFoveation = function (e) {
            null !== h && (h.fixedFoveation = e),
              null !== u &&
                void 0 !== u.fixedFoveation &&
                (u.fixedFoveation = e);
          });
        let P = null;
        const I = new rn();
        I.setAnimationLoop(function (t, n) {
          if (((l = n.getViewerPose(s)), (p = n), null !== l)) {
            const t = l.views;
            null !== u &&
              (e.setRenderTargetFramebuffer(g, u.framebuffer),
              e.setRenderTarget(g));
            let n = !1;
            t.length !== w.cameras.length && ((w.cameras.length = 0), (n = !0));
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              let s = null;
              if (null !== u) s = u.getViewport(r);
              else {
                const t = c.getViewSubImage(h, r);
                (s = t.viewport),
                  0 === i &&
                    (e.setRenderTargetTextures(
                      g,
                      t.colorTexture,
                      h.ignoreDepthValues ? void 0 : t.depthStencilTexture
                    ),
                    e.setRenderTarget(g));
              }
              const a = b[i];
              a.matrix.fromArray(r.transform.matrix),
                a.projectionMatrix.fromArray(r.projectionMatrix),
                a.viewport.set(s.x, s.y, s.width, s.height),
                0 === i && w.matrix.copy(a.matrix),
                !0 === n && w.cameras.push(a);
            }
          }
          const r = i.inputSources;
          for (let e = 0; e < v.length; e++) {
            const t = v[e],
              i = r[e];
            t.update(i, n, s);
          }
          P && P(t, n), (p = null);
        }),
          (this.setAnimationLoop = function (e) {
            P = e;
          }),
          (this.dispose = function () {});
      }
    }
    function qr(e) {
      function t(t, n) {
        (t.opacity.value = n.opacity),
          n.color && t.diffuse.value.copy(n.color),
          n.emissive &&
            t.emissive.value
              .copy(n.emissive)
              .multiplyScalar(n.emissiveIntensity),
          n.map && (t.map.value = n.map),
          n.alphaMap && (t.alphaMap.value = n.alphaMap),
          n.specularMap && (t.specularMap.value = n.specularMap),
          n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
        const i = e.get(n).envMap;
        let r, s;
        i &&
          ((t.envMap.value = i),
          (t.flipEnvMap.value =
            i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
          (t.reflectivity.value = n.reflectivity),
          (t.ior.value = n.ior),
          (t.refractionRatio.value = n.refractionRatio)),
          n.lightMap &&
            ((t.lightMap.value = n.lightMap),
            (t.lightMapIntensity.value = n.lightMapIntensity)),
          n.aoMap &&
            ((t.aoMap.value = n.aoMap),
            (t.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (r = n.map)
            : n.specularMap
            ? (r = n.specularMap)
            : n.displacementMap
            ? (r = n.displacementMap)
            : n.normalMap
            ? (r = n.normalMap)
            : n.bumpMap
            ? (r = n.bumpMap)
            : n.roughnessMap
            ? (r = n.roughnessMap)
            : n.metalnessMap
            ? (r = n.metalnessMap)
            : n.alphaMap
            ? (r = n.alphaMap)
            : n.emissiveMap
            ? (r = n.emissiveMap)
            : n.clearcoatMap
            ? (r = n.clearcoatMap)
            : n.clearcoatNormalMap
            ? (r = n.clearcoatNormalMap)
            : n.clearcoatRoughnessMap
            ? (r = n.clearcoatRoughnessMap)
            : n.specularIntensityMap
            ? (r = n.specularIntensityMap)
            : n.specularColorMap
            ? (r = n.specularColorMap)
            : n.transmissionMap
            ? (r = n.transmissionMap)
            : n.thicknessMap
            ? (r = n.thicknessMap)
            : n.sheenColorMap
            ? (r = n.sheenColorMap)
            : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
          void 0 !== r &&
            (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            t.uvTransform.value.copy(r.matrix)),
          n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
          void 0 !== s &&
            (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            t.uv2Transform.value.copy(s.matrix));
      }
      function n(t, n) {
        (t.roughness.value = n.roughness),
          (t.metalness.value = n.metalness),
          n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
          n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
          n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
          n.bumpMap &&
            ((t.bumpMap.value = n.bumpMap),
            (t.bumpScale.value = n.bumpScale),
            1 === n.side && (t.bumpScale.value *= -1)),
          n.normalMap &&
            ((t.normalMap.value = n.normalMap),
            t.normalScale.value.copy(n.normalScale),
            1 === n.side && t.normalScale.value.negate()),
          n.displacementMap &&
            ((t.displacementMap.value = n.displacementMap),
            (t.displacementScale.value = n.displacementScale),
            (t.displacementBias.value = n.displacementBias));
        e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (e, t) {
          e.fogColor.value.copy(t.color),
            t.isFog
              ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
              : t.isFogExp2 && (e.fogDensity.value = t.density);
        },
        refreshMaterialUniforms: function (e, i, r, s, a) {
          i.isMeshBasicMaterial
            ? t(e, i)
            : i.isMeshLambertMaterial
            ? (t(e, i),
              (function (e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
              })(e, i))
            : i.isMeshToonMaterial
            ? (t(e, i),
              (function (e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap);
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshPhongMaterial
            ? (t(e, i),
              (function (e, t) {
                e.specular.value.copy(t.specular),
                  (e.shininess.value = Math.max(t.shininess, 1e-4)),
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshStandardMaterial
            ? (t(e, i),
              i.isMeshPhysicalMaterial
                ? (function (e, t, i) {
                    n(e, t),
                      (e.ior.value = t.ior),
                      t.sheen > 0 &&
                        (e.sheenColor.value
                          .copy(t.sheenColor)
                          .multiplyScalar(t.sheen),
                        (e.sheenRoughness.value = t.sheenRoughness),
                        t.sheenColorMap &&
                          (e.sheenColorMap.value = t.sheenColorMap),
                        t.sheenRoughnessMap &&
                          (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
                    t.clearcoat > 0 &&
                      ((e.clearcoat.value = t.clearcoat),
                      (e.clearcoatRoughness.value = t.clearcoatRoughness),
                      t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                      t.clearcoatRoughnessMap &&
                        (e.clearcoatRoughnessMap.value =
                          t.clearcoatRoughnessMap),
                      t.clearcoatNormalMap &&
                        (e.clearcoatNormalScale.value.copy(
                          t.clearcoatNormalScale
                        ),
                        (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                        1 === t.side && e.clearcoatNormalScale.value.negate()));
                    t.transmission > 0 &&
                      ((e.transmission.value = t.transmission),
                      (e.transmissionSamplerMap.value = i.texture),
                      e.transmissionSamplerSize.value.set(i.width, i.height),
                      t.transmissionMap &&
                        (e.transmissionMap.value = t.transmissionMap),
                      (e.thickness.value = t.thickness),
                      t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                      (e.attenuationDistance.value = t.attenuationDistance),
                      e.attenuationColor.value.copy(t.attenuationColor));
                    (e.specularIntensity.value = t.specularIntensity),
                      e.specularColor.value.copy(t.specularColor),
                      t.specularIntensityMap &&
                        (e.specularIntensityMap.value = t.specularIntensityMap);
                    t.specularColorMap &&
                      (e.specularColorMap.value = t.specularColorMap);
                  })(e, i, a)
                : n(e, i))
            : i.isMeshMatcapMaterial
            ? (t(e, i),
              (function (e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshDepthMaterial
            ? (t(e, i),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isMeshDistanceMaterial
            ? (t(e, i),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
                e.referencePosition.value.copy(t.referencePosition),
                  (e.nearDistance.value = t.nearDistance),
                  (e.farDistance.value = t.farDistance);
              })(e, i))
            : i.isMeshNormalMaterial
            ? (t(e, i),
              (function (e, t) {
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, i))
            : i.isLineBasicMaterial
            ? ((function (e, t) {
                e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
              })(e, i),
              i.isLineDashedMaterial &&
                (function (e, t) {
                  (e.dashSize.value = t.dashSize),
                    (e.totalSize.value = t.dashSize + t.gapSize),
                    (e.scale.value = t.scale);
                })(e, i))
            : i.isPointsMaterial
            ? (function (e, t, n, i) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.size.value = t.size * n),
                  (e.scale.value = 0.5 * i),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let r;
                t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap);
                void 0 !== r &&
                  (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                  e.uvTransform.value.copy(r.matrix));
              })(e, i, r, s)
            : i.isSpriteMaterial
            ? (function (e, t) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.rotation.value = t.rotation),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let n;
                t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  e.uvTransform.value.copy(n.matrix));
              })(e, i)
            : i.isShadowMaterial
            ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
        },
      };
    }
    function Xr(e = {}) {
      const t =
          void 0 !== e.canvas
            ? e.canvas
            : (function () {
                const e = E("canvas");
                return (e.style.display = "block"), e;
              })(),
        n = void 0 !== e.context ? e.context : null,
        i = void 0 !== e.alpha && e.alpha,
        r = void 0 === e.depth || e.depth,
        s = void 0 === e.stencil || e.stencil,
        a = void 0 !== e.antialias && e.antialias,
        o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
        l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
        c = void 0 !== e.powerPreference ? e.powerPreference : "default",
        h =
          void 0 !== e.failIfMajorPerformanceCaveat &&
          e.failIfMajorPerformanceCaveat;
      let u = null,
        d = null;
      const p = [],
        m = [];
      (this.domElement = t),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = 3e3),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1);
      const f = this;
      let g = !1,
        v = 0,
        _ = 0,
        x = null,
        y = -1,
        b = null;
      const w = new D(),
        M = new D();
      let S = null,
        T = t.width,
        A = t.height,
        L = 1,
        R = null,
        C = null;
      const P = new D(0, 0, T, A),
        I = new D(0, 0, T, A);
      let z = !1;
      const B = [],
        U = new nn();
      let H = !1,
        k = !1,
        G = null;
      const V = new me(),
        W = new F(),
        j = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function q() {
        return null === x ? L : 1;
      }
      let X,
        Y,
        J,
        Z,
        K,
        Q,
        $,
        ee,
        te,
        ne,
        ie,
        re,
        se,
        ae,
        oe,
        le,
        ce,
        he,
        ue,
        de,
        pe,
        fe,
        ge,
        ve = n;
      function _e(e, n) {
        for (let i = 0; i < e.length; i++) {
          const r = e[i],
            s = t.getContext(r, n);
          if (null !== s) return s;
        }
        return null;
      }
      try {
        const e = {
          alpha: i,
          depth: r,
          stencil: s,
          antialias: a,
          premultipliedAlpha: o,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          ("setAttribute" in t &&
            t.setAttribute("data-engine", "three.js r135"),
          t.addEventListener("webglcontextlost", be, !1),
          t.addEventListener("webglcontextrestored", we, !1),
          null === ve)
        ) {
          const t = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === f.isWebGL1Renderer && t.shift(),
            (ve = _e(t, e)),
            null === ve)
          )
            throw _e(t)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === ve.getShaderPrecisionFormat &&
          (ve.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (e) {
        throw (console.error("THREE.WebGLRenderer: " + e.message), e);
      }
      function xe() {
        (X = new kn(ve)),
          (Y = new pn(ve, X, e)),
          X.init(Y),
          (fe = new Ur(ve, X, Y)),
          (J = new Fr(ve, X, Y)),
          (B[0] = 1029),
          (Z = new Wn(ve)),
          (K = new Mr()),
          (Q = new Br(ve, X, J, K, Y, fe, Z)),
          ($ = new fn(f)),
          (ee = new Hn(f)),
          (te = new sn(ve, Y)),
          (ge = new un(ve, X, te, Y)),
          (ne = new Gn(ve, te, Z, ge)),
          (ie = new Zn(ve, ne, te, Z)),
          (ue = new Jn(ve, Y, Q)),
          (le = new mn(K)),
          (re = new wr(f, $, ee, X, Y, ge, le)),
          (se = new qr(K)),
          (ae = new Ar(K)),
          (oe = new Dr(X, Y)),
          (he = new hn(f, $, J, ie, o)),
          (ce = new zr(f, ie, Y)),
          (de = new dn(ve, X, Z, Y)),
          (pe = new Vn(ve, X, Z, Y)),
          (Z.programs = re.programs),
          (f.capabilities = Y),
          (f.extensions = X),
          (f.properties = K),
          (f.renderLists = ae),
          (f.shadowMap = ce),
          (f.state = J),
          (f.info = Z);
      }
      xe();
      const ye = new jr(f, ve);
      function be(e) {
        e.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (g = !0);
      }
      function we() {
        console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
        const e = Z.autoReset,
          t = ce.enabled,
          n = ce.autoUpdate,
          i = ce.needsUpdate,
          r = ce.type;
        xe(),
          (Z.autoReset = e),
          (ce.enabled = t),
          (ce.autoUpdate = n),
          (ce.needsUpdate = i),
          (ce.type = r);
      }
      function Me(e) {
        const t = e.target;
        t.removeEventListener("dispose", Me),
          (function (e) {
            (function (e) {
              const t = K.get(e).programs;
              void 0 !== t &&
                t.forEach(function (e) {
                  re.releaseProgram(e);
                });
            })(e),
              K.remove(e);
          })(t);
      }
      (this.xr = ye),
        (this.getContext = function () {
          return ve;
        }),
        (this.getContextAttributes = function () {
          return ve.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const e = X.get("WEBGL_lose_context");
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          const e = X.get("WEBGL_lose_context");
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return L;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((L = e), this.setSize(T, A, !1));
        }),
        (this.getSize = function (e) {
          return e.set(T, A);
        }),
        (this.setSize = function (e, n, i) {
          ye.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((T = e),
              (A = n),
              (t.width = Math.floor(e * L)),
              (t.height = Math.floor(n * L)),
              !1 !== i &&
                ((t.style.width = e + "px"), (t.style.height = n + "px")),
              this.setViewport(0, 0, e, n));
        }),
        (this.getDrawingBufferSize = function (e) {
          return e.set(T * L, A * L).floor();
        }),
        (this.setDrawingBufferSize = function (e, n, i) {
          (T = e),
            (A = n),
            (L = i),
            (t.width = Math.floor(e * i)),
            (t.height = Math.floor(n * i)),
            this.setViewport(0, 0, e, n);
        }),
        (this.getCurrentViewport = function (e) {
          return e.copy(w);
        }),
        (this.getViewport = function (e) {
          return e.copy(P);
        }),
        (this.setViewport = function (e, t, n, i) {
          e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, i),
            J.viewport(w.copy(P).multiplyScalar(L).floor());
        }),
        (this.getScissor = function (e) {
          return e.copy(I);
        }),
        (this.setScissor = function (e, t, n, i) {
          e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, i),
            J.scissor(M.copy(I).multiplyScalar(L).floor());
        }),
        (this.getScissorTest = function () {
          return z;
        }),
        (this.setScissorTest = function (e) {
          J.setScissorTest((z = e));
        }),
        (this.setOpaqueSort = function (e) {
          R = e;
        }),
        (this.setTransparentSort = function (e) {
          C = e;
        }),
        (this.getClearColor = function (e) {
          return e.copy(he.getClearColor());
        }),
        (this.setClearColor = function () {
          he.setClearColor.apply(he, arguments);
        }),
        (this.getClearAlpha = function () {
          return he.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          he.setClearAlpha.apply(he, arguments);
        }),
        (this.clear = function (e, t, n) {
          let i = 0;
          (void 0 === e || e) && (i |= 16384),
            (void 0 === t || t) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            ve.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          t.removeEventListener("webglcontextlost", be, !1),
            t.removeEventListener("webglcontextrestored", we, !1),
            ae.dispose(),
            oe.dispose(),
            K.dispose(),
            $.dispose(),
            ee.dispose(),
            ie.dispose(),
            ge.dispose(),
            ye.dispose(),
            ye.removeEventListener("sessionstart", Te),
            ye.removeEventListener("sessionend", Ee),
            G && (G.dispose(), (G = null)),
            Ae.stop();
        }),
        (this.renderBufferDirect = function (e, t, n, i, r, s) {
          null === t && (t = j);
          const a = r.isMesh && r.matrixWorld.determinant() < 0,
            o = (function (e, t, n, i, r) {
              !0 !== t.isScene && (t = j);
              Q.resetTextureUnits();
              const s = t.fog,
                a = i.isMeshStandardMaterial ? t.environment : null,
                o = null === x ? f.outputEncoding : x.texture.encoding,
                l = (i.isMeshStandardMaterial ? ee : $).get(i.envMap || a),
                c =
                  !0 === i.vertexColors &&
                  !!n.attributes.color &&
                  4 === n.attributes.color.itemSize,
                h = !!i.normalMap && !!n.attributes.tangent,
                u = !!n.morphAttributes.position,
                p = !!n.morphAttributes.normal,
                m = n.morphAttributes.position
                  ? n.morphAttributes.position.length
                  : 0,
                g = K.get(i),
                v = d.state.lights;
              if (!0 === H && (!0 === k || e !== b)) {
                const t = e === b && i.id === y;
                le.setState(i, e, t);
              }
              let _ = !1;
              i.version === g.__version
                ? (g.needsLights && g.lightsStateVersion !== v.state.version) ||
                  g.outputEncoding !== o ||
                  (r.isInstancedMesh && !1 === g.instancing)
                  ? (_ = !0)
                  : r.isInstancedMesh || !0 !== g.instancing
                  ? r.isSkinnedMesh && !1 === g.skinning
                    ? (_ = !0)
                    : r.isSkinnedMesh || !0 !== g.skinning
                    ? g.envMap !== l || (i.fog && g.fog !== s)
                      ? (_ = !0)
                      : void 0 === g.numClippingPlanes ||
                        (g.numClippingPlanes === le.numPlanes &&
                          g.numIntersection === le.numIntersection)
                      ? (g.vertexAlphas !== c ||
                          g.vertexTangents !== h ||
                          g.morphTargets !== u ||
                          g.morphNormals !== p ||
                          (!0 === Y.isWebGL2 && g.morphTargetsCount !== m)) &&
                        (_ = !0)
                      : (_ = !0)
                    : (_ = !0)
                  : (_ = !0)
                : ((_ = !0), (g.__version = i.version));
              let w = g.currentProgram;
              !0 === _ && (w = Pe(i, t, r));
              let M = !1,
                S = !1,
                T = !1;
              const E = w.getUniforms(),
                R = g.uniforms;
              J.useProgram(w.program) && ((M = !0), (S = !0), (T = !0));
              i.id !== y && ((y = i.id), (S = !0));
              if (M || b !== e) {
                if (
                  (E.setValue(ve, "projectionMatrix", e.projectionMatrix),
                  Y.logarithmicDepthBuffer &&
                    E.setValue(
                      ve,
                      "logDepthBufFC",
                      2 / (Math.log(e.far + 1) / Math.LN2)
                    ),
                  b !== e && ((b = e), (S = !0), (T = !0)),
                  i.isShaderMaterial ||
                    i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshStandardMaterial ||
                    i.envMap)
                ) {
                  const t = E.map.cameraPosition;
                  void 0 !== t &&
                    t.setValue(ve, W.setFromMatrixPosition(e.matrixWorld));
                }
                (i.isMeshPhongMaterial ||
                  i.isMeshToonMaterial ||
                  i.isMeshLambertMaterial ||
                  i.isMeshBasicMaterial ||
                  i.isMeshStandardMaterial ||
                  i.isShaderMaterial) &&
                  E.setValue(
                    ve,
                    "isOrthographic",
                    !0 === e.isOrthographicCamera
                  ),
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial ||
                    i.isShadowMaterial ||
                    r.isSkinnedMesh) &&
                    E.setValue(ve, "viewMatrix", e.matrixWorldInverse);
              }
              if (r.isSkinnedMesh) {
                E.setOptional(ve, r, "bindMatrix"),
                  E.setOptional(ve, r, "bindMatrixInverse");
                const e = r.skeleton;
                e &&
                  (Y.floatVertexTextures
                    ? (null === e.boneTexture && e.computeBoneTexture(),
                      E.setValue(ve, "boneTexture", e.boneTexture, Q),
                      E.setValue(ve, "boneTextureSize", e.boneTextureSize))
                    : E.setOptional(ve, e, "boneMatrices"));
              }
              !n ||
                (void 0 === n.morphAttributes.position &&
                  void 0 === n.morphAttributes.normal) ||
                ue.update(r, n, i, w);
              (S || g.receiveShadow !== r.receiveShadow) &&
                ((g.receiveShadow = r.receiveShadow),
                E.setValue(ve, "receiveShadow", r.receiveShadow));
              S &&
                (E.setValue(ve, "toneMappingExposure", f.toneMappingExposure),
                g.needsLights &&
                  ((P = T),
                  ((C = R).ambientLightColor.needsUpdate = P),
                  (C.lightProbe.needsUpdate = P),
                  (C.directionalLights.needsUpdate = P),
                  (C.directionalLightShadows.needsUpdate = P),
                  (C.pointLights.needsUpdate = P),
                  (C.pointLightShadows.needsUpdate = P),
                  (C.spotLights.needsUpdate = P),
                  (C.spotLightShadows.needsUpdate = P),
                  (C.rectAreaLights.needsUpdate = P),
                  (C.hemisphereLights.needsUpdate = P)),
                s && i.fog && se.refreshFogUniforms(R, s),
                se.refreshMaterialUniforms(R, i, L, A, G),
                tr.upload(ve, g.uniformsList, R, Q));
              var C, P;
              i.isShaderMaterial &&
                !0 === i.uniformsNeedUpdate &&
                (tr.upload(ve, g.uniformsList, R, Q),
                (i.uniformsNeedUpdate = !1));
              i.isSpriteMaterial && E.setValue(ve, "center", r.center);
              return (
                E.setValue(ve, "modelViewMatrix", r.modelViewMatrix),
                E.setValue(ve, "normalMatrix", r.normalMatrix),
                E.setValue(ve, "modelMatrix", r.matrixWorld),
                w
              );
            })(e, t, n, i, r);
          J.setMaterial(i, a);
          let l = n.index;
          const c = n.attributes.position;
          if (null === l) {
            if (void 0 === c || 0 === c.count) return;
          } else if (0 === l.count) return;
          let h,
            u = 1;
          !0 === i.wireframe && ((l = ne.getWireframeAttribute(n)), (u = 2)),
            ge.setup(r, i, o, n, l);
          let p = de;
          null !== l && ((h = te.get(l)), (p = pe), p.setIndex(h));
          const m = null !== l ? l.count : c.count,
            g = n.drawRange.start * u,
            v = n.drawRange.count * u,
            _ = null !== s ? s.start * u : 0,
            w = null !== s ? s.count * u : 1 / 0,
            M = Math.max(g, _),
            S = Math.min(m, g + v, _ + w) - 1,
            T = Math.max(0, S - M + 1);
          if (0 !== T) {
            if (r.isMesh)
              !0 === i.wireframe
                ? (J.setLineWidth(i.wireframeLinewidth * q()), p.setMode(1))
                : p.setMode(4);
            else if (r.isLine) {
              let e = i.linewidth;
              void 0 === e && (e = 1),
                J.setLineWidth(e * q()),
                r.isLineSegments
                  ? p.setMode(1)
                  : r.isLineLoop
                  ? p.setMode(2)
                  : p.setMode(3);
            } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
            if (r.isInstancedMesh) p.renderInstances(M, T, r.count);
            else if (n.isInstancedBufferGeometry) {
              const e = Math.min(n.instanceCount, n._maxInstanceCount);
              p.renderInstances(M, T, e);
            } else p.render(M, T);
          }
        }),
        (this.compile = function (e, t) {
          (d = oe.get(e)),
            d.init(),
            m.push(d),
            e.traverseVisible(function (e) {
              e.isLight &&
                e.layers.test(t.layers) &&
                (d.pushLight(e), e.castShadow && d.pushShadow(e));
            }),
            d.setupLights(f.physicallyCorrectLights),
            e.traverse(function (t) {
              const n = t.material;
              if (n)
                if (Array.isArray(n))
                  for (let i = 0; i < n.length; i++) {
                    Pe(n[i], e, t);
                  }
                else Pe(n, e, t);
            }),
            m.pop(),
            (d = null);
        });
      let Se = null;
      function Te() {
        Ae.stop();
      }
      function Ee() {
        Ae.start();
      }
      const Ae = new rn();
      function Le(e, t, n, i) {
        const r = e.opaque,
          s = e.transmissive,
          o = e.transparent;
        d.setupLightsView(n),
          s.length > 0 &&
            (function (e, t, n) {
              if (null === G) {
                const e = !0 === a && !0 === Y.isWebGL2;
                G = new (e ? O : N)(1024, 1024, {
                  generateMipmaps: !0,
                  type: null !== fe.convert(1016) ? 1016 : 1009,
                  minFilter: 1008,
                  magFilter: 1003,
                  wrapS: 1001,
                  wrapT: 1001,
                  useRenderToTexture: X.has(
                    "WEBGL_multisampled_render_to_texture"
                  ),
                });
              }
              const i = f.getRenderTarget();
              f.setRenderTarget(G), f.clear();
              const r = f.toneMapping;
              (f.toneMapping = 0),
                Re(e, t, n),
                (f.toneMapping = r),
                Q.updateMultisampleRenderTarget(G),
                Q.updateRenderTargetMipmap(G),
                f.setRenderTarget(i);
            })(r, t, n),
          i && J.viewport(w.copy(i)),
          r.length > 0 && Re(r, t, n),
          s.length > 0 && Re(s, t, n),
          o.length > 0 && Re(o, t, n);
      }
      function Re(e, t, n) {
        const i = !0 === t.isScene ? t.overrideMaterial : null;
        for (let r = 0, s = e.length; r < s; r++) {
          const s = e[r],
            a = s.object,
            o = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          a.layers.test(n.layers) && Ce(a, t, n, o, l, c);
        }
      }
      function Ce(e, t, n, i, r, s) {
        e.onBeforeRender(f, t, n, i, r, s),
          e.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            e.matrixWorld
          ),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          r.onBeforeRender(f, t, n, i, e, s),
          !0 === r.transparent && 2 === r.side
            ? ((r.side = 1),
              (r.needsUpdate = !0),
              f.renderBufferDirect(n, t, i, r, e, s),
              (r.side = 0),
              (r.needsUpdate = !0),
              f.renderBufferDirect(n, t, i, r, e, s),
              (r.side = 2))
            : f.renderBufferDirect(n, t, i, r, e, s),
          e.onAfterRender(f, t, n, i, r, s);
      }
      function Pe(e, t, n) {
        !0 !== t.isScene && (t = j);
        const i = K.get(e),
          r = d.state.lights,
          s = d.state.shadowsArray,
          a = r.state.version,
          o = re.getParameters(e, r.state, s, t, n),
          l = re.getProgramCacheKey(o);
        let c = i.programs;
        (i.environment = e.isMeshStandardMaterial ? t.environment : null),
          (i.fog = t.fog),
          (i.envMap = (e.isMeshStandardMaterial ? ee : $).get(
            e.envMap || i.environment
          )),
          void 0 === c &&
            (e.addEventListener("dispose", Me),
            (c = new Map()),
            (i.programs = c));
        let h = c.get(l);
        if (void 0 !== h) {
          if (i.currentProgram === h && i.lightsStateVersion === a)
            return Ie(e, o), h;
        } else
          (o.uniforms = re.getUniforms(e)),
            e.onBuild(n, o, f),
            e.onBeforeCompile(o, f),
            (h = re.acquireProgram(o, l)),
            c.set(l, h),
            (i.uniforms = o.uniforms);
        const u = i.uniforms;
        ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
          (u.clippingPlanes = le.uniform),
          Ie(e, o),
          (i.needsLights = (function (e) {
            return (
              e.isMeshLambertMaterial ||
              e.isMeshToonMaterial ||
              e.isMeshPhongMaterial ||
              e.isMeshStandardMaterial ||
              e.isShadowMaterial ||
              (e.isShaderMaterial && !0 === e.lights)
            );
          })(e)),
          (i.lightsStateVersion = a),
          i.needsLights &&
            ((u.ambientLightColor.value = r.state.ambient),
            (u.lightProbe.value = r.state.probe),
            (u.directionalLights.value = r.state.directional),
            (u.directionalLightShadows.value = r.state.directionalShadow),
            (u.spotLights.value = r.state.spot),
            (u.spotLightShadows.value = r.state.spotShadow),
            (u.rectAreaLights.value = r.state.rectArea),
            (u.ltc_1.value = r.state.rectAreaLTC1),
            (u.ltc_2.value = r.state.rectAreaLTC2),
            (u.pointLights.value = r.state.point),
            (u.pointLightShadows.value = r.state.pointShadow),
            (u.hemisphereLights.value = r.state.hemi),
            (u.directionalShadowMap.value = r.state.directionalShadowMap),
            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (u.spotShadowMap.value = r.state.spotShadowMap),
            (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
            (u.pointShadowMap.value = r.state.pointShadowMap),
            (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
        const p = h.getUniforms(),
          m = tr.seqWithValue(p.seq, u);
        return (i.currentProgram = h), (i.uniformsList = m), h;
      }
      function Ie(e, t) {
        const n = K.get(e);
        (n.outputEncoding = t.outputEncoding),
          (n.instancing = t.instancing),
          (n.skinning = t.skinning),
          (n.morphTargets = t.morphTargets),
          (n.morphNormals = t.morphNormals),
          (n.morphTargetsCount = t.morphTargetsCount),
          (n.numClippingPlanes = t.numClippingPlanes),
          (n.numIntersection = t.numClipIntersection),
          (n.vertexAlphas = t.vertexAlphas),
          (n.vertexTangents = t.vertexTangents);
      }
      Ae.setAnimationLoop(function (e) {
        Se && Se(e);
      }),
        "undefined" != typeof window && Ae.setContext(window),
        (this.setAnimationLoop = function (e) {
          (Se = e), ye.setAnimationLoop(e), null === e ? Ae.stop() : Ae.start();
        }),
        ye.addEventListener("sessionstart", Te),
        ye.addEventListener("sessionend", Ee),
        (this.render = function (e, t) {
          if (void 0 !== t && !0 !== t.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === g) return;
          !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            !0 === ye.enabled &&
              !0 === ye.isPresenting &&
              (!0 === ye.cameraAutoUpdate && ye.updateCamera(t),
              (t = ye.getCamera())),
            !0 === e.isScene && e.onBeforeRender(f, e, t, x),
            (d = oe.get(e, m.length)),
            d.init(),
            m.push(d),
            V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            U.setFromProjectionMatrix(V),
            (k = this.localClippingEnabled),
            (H = le.init(this.clippingPlanes, k, t)),
            (u = ae.get(e, p.length)),
            u.init(),
            p.push(u),
            (function e(t, n, i, r) {
              if (!1 === t.visible) return;
              if (t.layers.test(n.layers))
                if (t.isGroup) i = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                else if (t.isLight)
                  d.pushLight(t), t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                  if (!t.frustumCulled || U.intersectsSprite(t)) {
                    r && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                    const e = ie.update(t),
                      n = t.material;
                    n.visible && u.push(t, e, n, i, W.z, null);
                  }
                } else if (
                  (t.isMesh || t.isLine || t.isPoints) &&
                  (t.isSkinnedMesh &&
                    t.skeleton.frame !== Z.render.frame &&
                    (t.skeleton.update(), (t.skeleton.frame = Z.render.frame)),
                  !t.frustumCulled || U.intersectsObject(t))
                ) {
                  r && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                  const e = ie.update(t),
                    n = t.material;
                  if (Array.isArray(n)) {
                    const r = e.groups;
                    for (let s = 0, a = r.length; s < a; s++) {
                      const a = r[s],
                        o = n[a.materialIndex];
                      o && o.visible && u.push(t, e, o, i, W.z, a);
                    }
                  } else n.visible && u.push(t, e, n, i, W.z, null);
                }
              const s = t.children;
              for (let t = 0, a = s.length; t < a; t++) e(s[t], n, i, r);
            })(e, t, 0, f.sortObjects),
            u.finish(),
            !0 === f.sortObjects && u.sort(R, C),
            !0 === H && le.beginShadows();
          const n = d.state.shadowsArray;
          if (
            (ce.render(n, e, t),
            !0 === H && le.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            he.render(u, e),
            d.setupLights(f.physicallyCorrectLights),
            t.isArrayCamera)
          ) {
            const n = t.cameras;
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              Le(u, e, i, i.viewport);
            }
          } else Le(u, e, t);
          null !== x &&
            (Q.updateMultisampleRenderTarget(x), Q.updateRenderTargetMipmap(x)),
            !0 === e.isScene && e.onAfterRender(f, e, t),
            J.buffers.depth.setTest(!0),
            J.buffers.depth.setMask(!0),
            J.buffers.color.setMask(!0),
            J.setPolygonOffset(!1),
            ge.resetDefaultState(),
            (y = -1),
            (b = null),
            m.pop(),
            (d = m.length > 0 ? m[m.length - 1] : null),
            p.pop(),
            (u = p.length > 0 ? p[p.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return v;
        }),
        (this.getActiveMipmapLevel = function () {
          return _;
        }),
        (this.getRenderTarget = function () {
          return x;
        }),
        (this.setRenderTargetTextures = function (e, t, n) {
          (K.get(e.texture).__webglTexture = t),
            (K.get(e.depthTexture).__webglTexture = n);
          const i = K.get(e);
          (i.__hasExternalTextures = !0),
            i.__hasExternalTextures &&
              ((i.__autoAllocateDepthBuffer = void 0 === n),
              i.__autoAllocateDepthBuffer ||
                (e.useRenderToTexture &&
                  (console.warn(
                    "render-to-texture extension was disabled because an external texture was provided"
                  ),
                  (e.useRenderToTexture = !1),
                  (e.useRenderbuffer = !0))));
        }),
        (this.setRenderTargetFramebuffer = function (e, t) {
          const n = K.get(e);
          (n.__webglFramebuffer = t),
            (n.__useDefaultFramebuffer = void 0 === t);
        }),
        (this.setRenderTarget = function (e, t = 0, n = 0) {
          (x = e), (v = t), (_ = n);
          let i = !0;
          if (e) {
            const t = K.get(e);
            void 0 !== t.__useDefaultFramebuffer
              ? (J.bindFramebuffer(36160, null), (i = !1))
              : void 0 === t.__webglFramebuffer
              ? Q.setupRenderTarget(e)
              : t.__hasExternalTextures &&
                Q.rebindTextures(
                  e,
                  K.get(e.texture).__webglTexture,
                  K.get(e.depthTexture).__webglTexture
                );
          }
          let r = null,
            s = !1,
            a = !1;
          if (e) {
            const n = e.texture;
            (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
            const i = K.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((r = i[t]), (s = !0))
              : (r = e.useRenderbuffer
                  ? K.get(e).__webglMultisampledFramebuffer
                  : i),
              w.copy(e.viewport),
              M.copy(e.scissor),
              (S = e.scissorTest);
          } else
            w.copy(P).multiplyScalar(L).floor(),
              M.copy(I).multiplyScalar(L).floor(),
              (S = z);
          if (J.bindFramebuffer(36160, r) && Y.drawBuffers && i) {
            let t = !1;
            if (e)
              if (e.isWebGLMultipleRenderTargets) {
                const n = e.texture;
                if (B.length !== n.length || 36064 !== B[0]) {
                  for (let e = 0, t = n.length; e < t; e++) B[e] = 36064 + e;
                  (B.length = n.length), (t = !0);
                }
              } else
                (1 === B.length && 36064 === B[0]) ||
                  ((B[0] = 36064), (B.length = 1), (t = !0));
            else
              (1 === B.length && 1029 === B[0]) ||
                ((B[0] = 1029), (B.length = 1), (t = !0));
            t &&
              (Y.isWebGL2
                ? ve.drawBuffers(B)
                : X.get("WEBGL_draw_buffers").drawBuffersWEBGL(B));
          }
          if ((J.viewport(w), J.scissor(M), J.setScissorTest(S), s)) {
            const i = K.get(e.texture);
            ve.framebufferTexture2D(
              36160,
              36064,
              34069 + t,
              i.__webglTexture,
              n
            );
          } else if (a) {
            const i = K.get(e.texture),
              r = t || 0;
            ve.framebufferTextureLayer(
              36160,
              36064,
              i.__webglTexture,
              n || 0,
              r
            );
          }
          y = -1;
        }),
        (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
          if (!e || !e.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let o = K.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            J.bindFramebuffer(36160, o);
            try {
              const a = e.texture,
                o = a.format,
                l = a.type;
              if (1023 !== o && fe.convert(o) !== ve.getParameter(35739))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                1016 === l &&
                (X.has("EXT_color_buffer_half_float") ||
                  (Y.isWebGL2 && X.has("EXT_color_buffer_float")));
              if (
                !(
                  1009 === l ||
                  fe.convert(l) === ve.getParameter(35738) ||
                  (1015 === l &&
                    (Y.isWebGL2 ||
                      X.has("OES_texture_float") ||
                      X.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              36053 === ve.checkFramebufferStatus(36160)
                ? t >= 0 &&
                  t <= e.width - i &&
                  n >= 0 &&
                  n <= e.height - r &&
                  ve.readPixels(t, n, i, r, fe.convert(o), fe.convert(l), s)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  );
            } finally {
              const e = null !== x ? K.get(x).__webglFramebuffer : null;
              J.bindFramebuffer(36160, e);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (e, t, n = 0) {
          const i = Math.pow(2, -n),
            r = Math.floor(t.image.width * i),
            s = Math.floor(t.image.height * i);
          let a = fe.convert(t.format);
          Y.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),
            Q.setTexture2D(t, 0),
            ve.copyTexImage2D(3553, n, a, e.x, e.y, r, s, 0),
            J.unbindTexture();
        }),
        (this.copyTextureToTexture = function (e, t, n, i = 0) {
          const r = t.image.width,
            s = t.image.height,
            a = fe.convert(n.format),
            o = fe.convert(n.type);
          Q.setTexture2D(n, 0),
            ve.pixelStorei(37440, n.flipY),
            ve.pixelStorei(37441, n.premultiplyAlpha),
            ve.pixelStorei(3317, n.unpackAlignment),
            t.isDataTexture
              ? ve.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data)
              : t.isCompressedTexture
              ? ve.compressedTexSubImage2D(
                  3553,
                  i,
                  e.x,
                  e.y,
                  t.mipmaps[0].width,
                  t.mipmaps[0].height,
                  a,
                  t.mipmaps[0].data
                )
              : ve.texSubImage2D(3553, i, e.x, e.y, a, o, t.image),
            0 === i && n.generateMipmaps && ve.generateMipmap(3553),
            J.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
          if (f.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const s = e.max.x - e.min.x + 1,
            a = e.max.y - e.min.y + 1,
            o = e.max.z - e.min.z + 1,
            l = fe.convert(i.format),
            c = fe.convert(i.type);
          let h;
          if (i.isDataTexture3D) Q.setTexture3D(i, 0), (h = 32879);
          else {
            if (!i.isDataTexture2DArray)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            Q.setTexture2DArray(i, 0), (h = 35866);
          }
          ve.pixelStorei(37440, i.flipY),
            ve.pixelStorei(37441, i.premultiplyAlpha),
            ve.pixelStorei(3317, i.unpackAlignment);
          const u = ve.getParameter(3314),
            d = ve.getParameter(32878),
            p = ve.getParameter(3316),
            m = ve.getParameter(3315),
            g = ve.getParameter(32877),
            v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
          ve.pixelStorei(3314, v.width),
            ve.pixelStorei(32878, v.height),
            ve.pixelStorei(3316, e.min.x),
            ve.pixelStorei(3315, e.min.y),
            ve.pixelStorei(32877, e.min.z),
            n.isDataTexture || n.isDataTexture3D
              ? ve.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v.data)
              : n.isCompressedTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                ve.compressedTexSubImage3D(
                  h,
                  r,
                  t.x,
                  t.y,
                  t.z,
                  s,
                  a,
                  o,
                  l,
                  v.data
                ))
              : ve.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v),
            ve.pixelStorei(3314, u),
            ve.pixelStorei(32878, d),
            ve.pixelStorei(3316, p),
            ve.pixelStorei(3315, m),
            ve.pixelStorei(32877, g),
            0 === r && i.generateMipmaps && ve.generateMipmap(h),
            J.unbindTexture();
        }),
        (this.initTexture = function (e) {
          Q.setTexture2D(e, 0), J.unbindTexture();
        }),
        (this.resetState = function () {
          (v = 0), (_ = 0), (x = null), J.reset(), ge.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    Xr.prototype.isWebGLRenderer = !0;
    (class extends Xr {}.prototype.isWebGL1Renderer = !0);
    class Yr {
      constructor(e, t = 25e-5) {
        (this.name = ""), (this.color = new st(e)), (this.density = t);
      }
      clone() {
        return new Yr(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density,
        };
      }
    }
    Yr.prototype.isFogExp2 = !0;
    class Jr {
      constructor(e, t = 1, n = 1e3) {
        (this.name = ""),
          (this.color = new st(e)),
          (this.near = t),
          (this.far = n);
      }
      clone() {
        return new Jr(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      }
    }
    Jr.prototype.isFog = !0;
    class Zr extends Ue {
      constructor() {
        super(),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          null !== e.background && (this.background = e.background.clone()),
          null !== e.environment && (this.environment = e.environment.clone()),
          null !== e.fog && (this.fog = e.fog.clone()),
          null !== e.overrideMaterial &&
            (this.overrideMaterial = e.overrideMaterial.clone()),
          (this.autoUpdate = e.autoUpdate),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
      }
    }
    Zr.prototype.isScene = !0;
    class Kr {
      constructor(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = 35044),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = f());
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let i = 0, r = this.stride; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = f()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        const t = new this.array.constructor(
            e.arrayBuffers[this.array.buffer._uuid]
          ),
          n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n;
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      toJSON(e) {
        return (
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = f()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      }
    }
    Kr.prototype.isInterleavedBuffer = !0;
    const Qr = new F();
    class $r {
      constructor(e, t, n, i = !1) {
        (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = n),
          (this.normalized = !0 === i);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
          (Qr.x = this.getX(t)),
            (Qr.y = this.getY(t)),
            (Qr.z = this.getZ(t)),
            Qr.applyMatrix4(e),
            this.setXYZ(t, Qr.x, Qr.y, Qr.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Qr.x = this.getX(t)),
            (Qr.y = this.getY(t)),
            (Qr.z = this.getZ(t)),
            Qr.applyNormalMatrix(e),
            this.setXYZ(t, Qr.x, Qr.y, Qr.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Qr.x = this.getX(t)),
            (Qr.y = this.getY(t)),
            (Qr.z = this.getZ(t)),
            Qr.transformDirection(e),
            this.setXYZ(t, Qr.x, Qr.y, Qr.z);
        return this;
      }
      setX(e, t) {
        return (this.data.array[e * this.data.stride + this.offset] = t), this;
      }
      setY(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 1] = t), this
        );
      }
      setZ(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 2] = t), this
        );
      }
      setW(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 3] = t), this
        );
      }
      getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
      }
      getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      }
      getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      }
      getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      }
      setXY(e, t, n) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, i) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          this
        );
      }
      setXYZW(e, t, n, i, r) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          (this.data.array[e + 3] = r),
          this
        );
      }
      clone(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return new ct(
            new this.array.constructor(e),
            this.itemSize,
            this.normalized
          );
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new $r(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
      }
      toJSON(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: e,
            normalized: this.normalized,
          };
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      }
    }
    $r.prototype.isInterleavedBufferAttribute = !0;
    class es extends Qe {
      constructor(e) {
        super(),
          (this.type = "SpriteMaterial"),
          (this.color = new st(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.rotation = e.rotation),
          (this.sizeAttenuation = e.sizeAttenuation),
          this
        );
      }
    }
    let ts;
    es.prototype.isSpriteMaterial = !0;
    const ns = new F(),
      is = new F(),
      rs = new F(),
      ss = new M(),
      as = new M(),
      os = new me(),
      ls = new F(),
      cs = new F(),
      hs = new F(),
      us = new M(),
      ds = new M(),
      ps = new M();
    class ms extends Ue {
      constructor(e) {
        if ((super(), (this.type = "Sprite"), void 0 === ts)) {
          ts = new yt();
          const e = new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
              0.5, 0, 0, 1,
            ]),
            t = new Kr(e, 5);
          ts.setIndex([0, 1, 2, 0, 2, 3]),
            ts.setAttribute("position", new $r(t, 3, 0, !1)),
            ts.setAttribute("uv", new $r(t, 2, 3, !1));
        }
        (this.geometry = ts),
          (this.material = void 0 !== e ? e : new es()),
          (this.center = new M(0.5, 0.5));
      }
      raycast(e, t) {
        null === e.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          is.setFromMatrixScale(this.matrixWorld),
          os.copy(e.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            e.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          rs.setFromMatrixPosition(this.modelViewMatrix),
          e.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            is.multiplyScalar(-rs.z);
        const n = this.material.rotation;
        let i, r;
        0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
        const s = this.center;
        fs(ls.set(-0.5, -0.5, 0), rs, s, is, i, r),
          fs(cs.set(0.5, -0.5, 0), rs, s, is, i, r),
          fs(hs.set(0.5, 0.5, 0), rs, s, is, i, r),
          us.set(0, 0),
          ds.set(1, 0),
          ps.set(1, 1);
        let a = e.ray.intersectTriangle(ls, cs, hs, !1, ns);
        if (
          null === a &&
          (fs(cs.set(-0.5, 0.5, 0), rs, s, is, i, r),
          ds.set(0, 1),
          (a = e.ray.intersectTriangle(ls, hs, cs, !1, ns)),
          null === a)
        )
          return;
        const o = e.ray.origin.distanceTo(ns);
        o < e.near ||
          o > e.far ||
          t.push({
            distance: o,
            point: ns.clone(),
            uv: Ze.getUV(ns, ls, cs, hs, us, ds, ps, new M()),
            face: null,
            object: this,
          });
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.center && this.center.copy(e.center),
          (this.material = e.material),
          this
        );
      }
    }
    function fs(e, t, n, i, r, s) {
      ss.subVectors(e, n).addScalar(0.5).multiply(i),
        void 0 !== r
          ? ((as.x = s * ss.x - r * ss.y), (as.y = r * ss.x + s * ss.y))
          : as.copy(ss),
        e.copy(t),
        (e.x += as.x),
        (e.y += as.y),
        e.applyMatrix4(os);
    }
    ms.prototype.isSprite = !0;
    const gs = new F(),
      vs = new D(),
      _s = new D(),
      xs = new F(),
      ys = new me();
    class bs extends Bt {
      constructor(e, t) {
        super(e, t),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new me()),
          (this.bindMatrixInverse = new me());
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bindMode = e.bindMode),
          this.bindMatrix.copy(e.bindMatrix),
          this.bindMatrixInverse.copy(e.bindMatrixInverse),
          (this.skeleton = e.skeleton),
          this
        );
      }
      bind(e, t) {
        (this.skeleton = e),
          void 0 === t &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const e = new D(),
          t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
          (e.x = t.getX(n)),
            (e.y = t.getY(n)),
            (e.z = t.getZ(n)),
            (e.w = t.getW(n));
          const i = 1 / e.manhattanLength();
          i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          "attached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : "detached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
            : console.warn(
                "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
              );
      }
      boneTransform(e, t) {
        const n = this.skeleton,
          i = this.geometry;
        vs.fromBufferAttribute(i.attributes.skinIndex, e),
          _s.fromBufferAttribute(i.attributes.skinWeight, e),
          gs.copy(t).applyMatrix4(this.bindMatrix),
          t.set(0, 0, 0);
        for (let e = 0; e < 4; e++) {
          const i = _s.getComponent(e);
          if (0 !== i) {
            const r = vs.getComponent(e);
            ys.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
              t.addScaledVector(xs.copy(gs).applyMatrix4(ys), i);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    }
    bs.prototype.isSkinnedMesh = !0;
    class ws extends Ue {
      constructor() {
        super(), (this.type = "Bone");
      }
    }
    ws.prototype.isBone = !0;
    class Ms extends P {
      constructor(
        e = null,
        t = 1,
        n = 1,
        i,
        r,
        s,
        a,
        o,
        l = 1003,
        c = 1003,
        h,
        u
      ) {
        super(null, s, a, o, l, c, i, r, h, u),
          (this.image = { data: e, width: t, height: n }),
          (this.magFilter = l),
          (this.minFilter = c),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    Ms.prototype.isDataTexture = !0;
    const Ss = new me(),
      Ts = new me();
    class Es {
      constructor(e = [], t = []) {
        (this.uuid = f()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      init() {
        const e = this.bones,
          t = this.boneInverses;
        if (
          ((this.boneMatrices = new Float32Array(16 * e.length)),
          0 === t.length)
        )
          this.calculateInverses();
        else if (e.length !== t.length) {
          console.warn(
            "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
          ),
            (this.boneInverses = []);
          for (let e = 0, t = this.bones.length; e < t; e++)
            this.boneInverses.push(new me());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = new me();
          this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(t);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && t.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t &&
            (t.parent && t.parent.isBone
              ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
        }
      }
      update() {
        const e = this.bones,
          t = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture;
        for (let i = 0, r = e.length; i < r; i++) {
          const r = e[i] ? e[i].matrixWorld : Ts;
          Ss.multiplyMatrices(r, t[i]), Ss.toArray(n, 16 * i);
        }
        null !== i && (i.needsUpdate = !0);
      }
      clone() {
        return new Es(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let e = Math.sqrt(4 * this.bones.length);
        (e = y(e)), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Ms(t, e, e, 1023, 1015);
        return (
          (this.boneMatrices = t),
          (this.boneTexture = n),
          (this.boneTextureSize = e),
          this
        );
      }
      getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
          const n = this.bones[t];
          if (n.name === e) return n;
        }
      }
      dispose() {
        null !== this.boneTexture &&
          (this.boneTexture.dispose(), (this.boneTexture = null));
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
          const i = e.bones[n];
          let r = t[i];
          void 0 === r &&
            (console.warn("THREE.Skeleton: No bone found with UUID:", i),
            (r = new ws())),
            this.bones.push(r),
            this.boneInverses.push(new me().fromArray(e.boneInverses[n]));
        }
        return this.init(), this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON",
          },
          bones: [],
          boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
          n = this.boneInverses;
        for (let i = 0, r = t.length; i < r; i++) {
          const r = t[i];
          e.bones.push(r.uuid);
          const s = n[i];
          e.boneInverses.push(s.toArray());
        }
        return e;
      }
    }
    class As extends ct {
      constructor(e, t, n, i = 1) {
        "number" == typeof n &&
          ((i = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          super(e, t, n),
          (this.meshPerAttribute = i);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.meshPerAttribute = this.meshPerAttribute),
          (e.isInstancedBufferAttribute = !0),
          e
        );
      }
    }
    As.prototype.isInstancedBufferAttribute = !0;
    const Ls = new me(),
      Rs = new me(),
      Cs = [],
      Ps = new Bt();
    class Is extends Bt {
      constructor(e, t, n) {
        super(e, t),
          (this.instanceMatrix = new As(new Float32Array(16 * n), 16)),
          (this.instanceColor = null),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      copy(e) {
        return (
          super.copy(e),
          this.instanceMatrix.copy(e.instanceMatrix),
          null !== e.instanceColor &&
            (this.instanceColor = e.instanceColor.clone()),
          (this.count = e.count),
          this
        );
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e);
      }
      raycast(e, t) {
        const n = this.matrixWorld,
          i = this.count;
        if (
          ((Ps.geometry = this.geometry),
          (Ps.material = this.material),
          void 0 !== Ps.material)
        )
          for (let r = 0; r < i; r++) {
            this.getMatrixAt(r, Ls),
              Rs.multiplyMatrices(n, Ls),
              (Ps.matrixWorld = Rs),
              Ps.raycast(e, Cs);
            for (let e = 0, n = Cs.length; e < n; e++) {
              const n = Cs[e];
              (n.instanceId = r), (n.object = this), t.push(n);
            }
            Cs.length = 0;
          }
      }
      setColorAt(e, t) {
        null === this.instanceColor &&
          (this.instanceColor = new As(
            new Float32Array(3 * this.instanceMatrix.count),
            3
          )),
          t.toArray(this.instanceColor.array, 3 * e);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
    Is.prototype.isInstancedMesh = !0;
    class Ds extends Qe {
      constructor(e) {
        super(),
          (this.type = "LineBasicMaterial"),
          (this.color = new st(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.linewidth = e.linewidth),
          (this.linecap = e.linecap),
          (this.linejoin = e.linejoin),
          this
        );
      }
    }
    Ds.prototype.isLineBasicMaterial = !0;
    const Ns = new F(),
      Os = new F(),
      zs = new me(),
      Fs = new pe(),
      Bs = new se();
    class Us extends Ue {
      constructor(e = new yt(), t = new Ds()) {
        super(),
          (this.type = "Line"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [0];
            for (let e = 1, i = t.count; e < i; e++)
              Ns.fromBufferAttribute(t, e - 1),
                Os.fromBufferAttribute(t, e),
                (n[e] = n[e - 1]),
                (n[e] += Ns.distanceTo(Os));
            e.setAttribute("lineDistance", new dt(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = e.params.Line.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Bs.copy(n.boundingSphere),
          Bs.applyMatrix4(i),
          (Bs.radius += r),
          !1 === e.ray.intersectsSphere(Bs))
        )
          return;
        zs.copy(i).invert(), Fs.copy(e.ray).applyMatrix4(zs);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a,
          l = new F(),
          c = new F(),
          h = new F(),
          u = new F(),
          d = this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const i = n.index,
            r = n.attributes.position;
          if (null !== i) {
            for (
              let n = Math.max(0, s.start),
                a = Math.min(i.count, s.start + s.count) - 1;
              n < a;
              n += d
            ) {
              const s = i.getX(n),
                a = i.getX(n + 1);
              l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);
              if (Fs.distanceSqToSegment(l, c, u, h) > o) continue;
              u.applyMatrix4(this.matrixWorld);
              const d = e.ray.origin.distanceTo(u);
              d < e.near ||
                d > e.far ||
                t.push({
                  distance: d,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                i = Math.min(r.count, s.start + s.count) - 1;
              n < i;
              n += d
            ) {
              l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
              if (Fs.distanceSqToSegment(l, c, u, h) > o) continue;
              u.applyMatrix4(this.matrixWorld);
              const i = e.ray.origin.distanceTo(u);
              i < e.near ||
                i > e.far ||
                t.push({
                  distance: i,
                  point: h.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    Us.prototype.isLine = !0;
    const Hs = new F(),
      ks = new F();
    class Gs extends Us {
      constructor(e, t) {
        super(e, t), (this.type = "LineSegments");
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [];
            for (let e = 0, i = t.count; e < i; e += 2)
              Hs.fromBufferAttribute(t, e),
                ks.fromBufferAttribute(t, e + 1),
                (n[e] = 0 === e ? 0 : n[e - 1]),
                (n[e + 1] = n[e] + Hs.distanceTo(ks));
            e.setAttribute("lineDistance", new dt(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
    }
    Gs.prototype.isLineSegments = !0;
    class Vs extends Us {
      constructor(e, t) {
        super(e, t), (this.type = "LineLoop");
      }
    }
    Vs.prototype.isLineLoop = !0;
    class Ws extends Qe {
      constructor(e) {
        super(),
          (this.type = "PointsMaterial"),
          (this.color = new st(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.size = e.size),
          (this.sizeAttenuation = e.sizeAttenuation),
          this
        );
      }
    }
    Ws.prototype.isPointsMaterial = !0;
    const js = new me(),
      qs = new pe(),
      Xs = new se(),
      Ys = new F();
    class Js extends Ue {
      constructor(e = new yt(), t = new Ws()) {
        super(),
          (this.type = "Points"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      raycast(e, t) {
        const n = this.geometry,
          i = this.matrixWorld,
          r = e.params.Points.threshold,
          s = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Xs.copy(n.boundingSphere),
          Xs.applyMatrix4(i),
          (Xs.radius += r),
          !1 === e.ray.intersectsSphere(Xs))
        )
          return;
        js.copy(i).invert(), qs.copy(e.ray).applyMatrix4(js);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          o = a * a;
        if (n.isBufferGeometry) {
          const r = n.index,
            a = n.attributes.position;
          if (null !== r) {
            for (
              let n = Math.max(0, s.start),
                l = Math.min(r.count, s.start + s.count);
              n < l;
              n++
            ) {
              const s = r.getX(n);
              Ys.fromBufferAttribute(a, s), Zs(Ys, s, o, i, e, t, this);
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(a.count, s.start + s.count);
              n < r;
              n++
            )
              Ys.fromBufferAttribute(a, n), Zs(Ys, n, o, i, e, t, this);
          }
        } else
          console.error(
            "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    function Zs(e, t, n, i, r, s, a) {
      const o = qs.distanceSqToPoint(e);
      if (o < n) {
        const n = new F();
        qs.closestPointToPoint(e, n), n.applyMatrix4(i);
        const l = r.ray.origin.distanceTo(n);
        if (l < r.near || l > r.far) return;
        s.push({
          distance: l,
          distanceToRay: Math.sqrt(o),
          point: n,
          index: t,
          face: null,
          object: a,
        });
      }
    }
    Js.prototype.isPoints = !0;
    (class extends P {
      constructor(e, t, n, i, r, s, a, o, l) {
        super(e, t, n, i, r, s, a, o, l),
          (this.format = void 0 !== a ? a : 1022),
          (this.minFilter = void 0 !== s ? s : 1006),
          (this.magFilter = void 0 !== r ? r : 1006),
          (this.generateMipmaps = !1);
        const c = this;
        "requestVideoFrameCallback" in e &&
          e.requestVideoFrameCallback(function t() {
            (c.needsUpdate = !0), e.requestVideoFrameCallback(t);
          });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const e = this.image;
        !1 === "requestVideoFrameCallback" in e &&
          e.readyState >= e.HAVE_CURRENT_DATA &&
          (this.needsUpdate = !0);
      }
    }.prototype.isVideoTexture = !0);
    class Ks extends P {
      constructor(e, t, n, i, r, s, a, o, l, c, h, u) {
        super(null, s, a, o, l, c, i, r, h, u),
          (this.image = { width: t, height: n }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    Ks.prototype.isCompressedTexture = !0;
    (class extends P {
      constructor(e, t, n, i, r, s, a, o, l) {
        super(e, t, n, i, r, s, a, o, l), (this.needsUpdate = !0);
      }
    }.prototype.isCanvasTexture = !0);
    new F(), new F(), new F(), new Ze();
    class Qs {
      constructor() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
      }
      getPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t;
      }
      getSpacedPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t;
      }
      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }
      getLengths(e = this.arcLengthDivisions) {
        if (
          this.cacheArcLengths &&
          this.cacheArcLengths.length === e + 1 &&
          !this.needsUpdate
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
          i = this.getPoint(0),
          r = 0;
        t.push(0);
        for (let s = 1; s <= e; s++)
          (n = this.getPoint(s / e)),
            (r += n.distanceTo(i)),
            t.push(r),
            (i = n);
        return (this.cacheArcLengths = t), t;
      }
      updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
      }
      getUtoTmapping(e, t) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let s;
        s = t || e * n[r - 1];
        let a,
          o = 0,
          l = r - 1;
        for (; o <= l; )
          if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))
            o = i + 1;
          else {
            if (!(a > 0)) {
              l = i;
              break;
            }
            l = i - 1;
          }
        if (((i = l), n[i] === s)) return i / (r - 1);
        const c = n[i];
        return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
      }
      getTangent(e, t) {
        let n = e - 1e-4,
          i = e + 1e-4;
        n < 0 && (n = 0), i > 1 && (i = 1);
        const r = this.getPoint(n),
          s = this.getPoint(i),
          a = t || (r.isVector2 ? new M() : new F());
        return a.copy(s).sub(r).normalize(), a;
      }
      getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
      }
      computeFrenetFrames(e, t) {
        const n = new F(),
          i = [],
          r = [],
          s = [],
          a = new F(),
          o = new me();
        for (let t = 0; t <= e; t++) {
          const n = t / e;
          i[t] = this.getTangentAt(n, new F());
        }
        (r[0] = new F()), (s[0] = new F());
        let l = Number.MAX_VALUE;
        const c = Math.abs(i[0].x),
          h = Math.abs(i[0].y),
          u = Math.abs(i[0].z);
        c <= l && ((l = c), n.set(1, 0, 0)),
          h <= l && ((l = h), n.set(0, 1, 0)),
          u <= l && n.set(0, 0, 1),
          a.crossVectors(i[0], n).normalize(),
          r[0].crossVectors(i[0], a),
          s[0].crossVectors(i[0], r[0]);
        for (let t = 1; t <= e; t++) {
          if (
            ((r[t] = r[t - 1].clone()),
            (s[t] = s[t - 1].clone()),
            a.crossVectors(i[t - 1], i[t]),
            a.length() > Number.EPSILON)
          ) {
            a.normalize();
            const e = Math.acos(g(i[t - 1].dot(i[t]), -1, 1));
            r[t].applyMatrix4(o.makeRotationAxis(a, e));
          }
          s[t].crossVectors(i[t], r[t]);
        }
        if (!0 === t) {
          let t = Math.acos(g(r[0].dot(r[e]), -1, 1));
          (t /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
          for (let n = 1; n <= e; n++)
            r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
              s[n].crossVectors(i[n], r[n]);
        }
        return { tangents: i, normals: r, binormals: s };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
      toJSON() {
        const e = {
          metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
        };
        return (
          (e.arcLengthDivisions = this.arcLengthDivisions),
          (e.type = this.type),
          e
        );
      }
      fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
    }
    class $s extends Qs {
      constructor(
        e = 0,
        t = 0,
        n = 1,
        i = 1,
        r = 0,
        s = 2 * Math.PI,
        a = !1,
        o = 0
      ) {
        super(),
          (this.type = "EllipseCurve"),
          (this.aX = e),
          (this.aY = t),
          (this.xRadius = n),
          (this.yRadius = i),
          (this.aStartAngle = r),
          (this.aEndAngle = s),
          (this.aClockwise = a),
          (this.aRotation = o);
      }
      getPoint(e, t) {
        const n = t || new M(),
          i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(r) < Number.EPSILON;
        for (; r < 0; ) r += i;
        for (; r > i; ) r -= i;
        r < Number.EPSILON && (r = s ? 0 : i),
          !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
        const a = this.aStartAngle + e * r;
        let o = this.aX + this.xRadius * Math.cos(a),
          l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
          const e = Math.cos(this.aRotation),
            t = Math.sin(this.aRotation),
            n = o - this.aX,
            i = l - this.aY;
          (o = n * e - i * t + this.aX), (l = n * t + i * e + this.aY);
        }
        return n.set(o, l);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.aX = this.aX),
          (e.aY = this.aY),
          (e.xRadius = this.xRadius),
          (e.yRadius = this.yRadius),
          (e.aStartAngle = this.aStartAngle),
          (e.aEndAngle = this.aEndAngle),
          (e.aClockwise = this.aClockwise),
          (e.aRotation = this.aRotation),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
    }
    $s.prototype.isEllipseCurve = !0;
    class ea extends $s {
      constructor(e, t, n, i, r, s) {
        super(e, t, n, n, i, r, s), (this.type = "ArcCurve");
      }
    }
    function ta() {
      let e = 0,
        t = 0,
        n = 0,
        i = 0;
      function r(r, s, a, o) {
        (e = r),
          (t = a),
          (n = -3 * r + 3 * s - 2 * a - o),
          (i = 2 * r - 2 * s + a + o);
      }
      return {
        initCatmullRom: function (e, t, n, i, s) {
          r(t, n, s * (n - e), s * (i - t));
        },
        initNonuniformCatmullRom: function (e, t, n, i, s, a, o) {
          let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
            c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
          (l *= a), (c *= a), r(t, n, l, c);
        },
        calc: function (r) {
          const s = r * r;
          return e + t * r + n * s + i * (s * r);
        },
      };
    }
    ea.prototype.isArcCurve = !0;
    const na = new F(),
      ia = new ta(),
      ra = new ta(),
      sa = new ta();
    class aa extends Qs {
      constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
        super(),
          (this.type = "CatmullRomCurve3"),
          (this.points = e),
          (this.closed = t),
          (this.curveType = n),
          (this.tension = i);
      }
      getPoint(e, t = new F()) {
        const n = t,
          i = this.points,
          r = i.length,
          s = (r - (this.closed ? 0 : 1)) * e;
        let a,
          o,
          l = Math.floor(s),
          c = s - l;
        this.closed
          ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
          : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
          this.closed || l > 0
            ? (a = i[(l - 1) % r])
            : (na.subVectors(i[0], i[1]).add(i[0]), (a = na));
        const h = i[l % r],
          u = i[(l + 1) % r];
        if (
          (this.closed || l + 2 < r
            ? (o = i[(l + 2) % r])
            : (na.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = na)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          const e = "chordal" === this.curveType ? 0.5 : 0.25;
          let t = Math.pow(a.distanceToSquared(h), e),
            n = Math.pow(h.distanceToSquared(u), e),
            i = Math.pow(u.distanceToSquared(o), e);
          n < 1e-4 && (n = 1),
            t < 1e-4 && (t = n),
            i < 1e-4 && (i = n),
            ia.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, t, n, i),
            ra.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, t, n, i),
            sa.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, t, n, i);
        } else
          "catmullrom" === this.curveType &&
            (ia.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
            ra.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
            sa.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
        return n.set(ia.calc(c), ra.calc(c), sa.calc(c)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return (
          (e.closed = this.closed),
          (e.curveType = this.curveType),
          (e.tension = this.tension),
          e
        );
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new F().fromArray(n));
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
    }
    function oa(e, t, n, i, r) {
      const s = 0.5 * (i - t),
        a = 0.5 * (r - n),
        o = e * e;
      return (
        (2 * n - 2 * i + s + a) * (e * o) +
        (-3 * n + 3 * i - 2 * s - a) * o +
        s * e +
        n
      );
    }
    function la(e, t, n, i) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * t;
        })(e, t) +
        (function (e, t) {
          return 2 * (1 - e) * e * t;
        })(e, n) +
        (function (e, t) {
          return e * e * t;
        })(e, i)
      );
    }
    function ca(e, t, n, i, r) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * n * t;
        })(e, t) +
        (function (e, t) {
          const n = 1 - e;
          return 3 * n * n * e * t;
        })(e, n) +
        (function (e, t) {
          return 3 * (1 - e) * e * e * t;
        })(e, i) +
        (function (e, t) {
          return e * e * e * t;
        })(e, r)
      );
    }
    aa.prototype.isCatmullRomCurve3 = !0;
    class ha extends Qs {
      constructor(e = new M(), t = new M(), n = new M(), i = new M()) {
        super(),
          (this.type = "CubicBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(e, t = new M()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          a = this.v3;
        return n.set(ca(e, i.x, r.x, s.x, a.x), ca(e, i.y, r.y, s.y, a.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    ha.prototype.isCubicBezierCurve = !0;
    class ua extends Qs {
      constructor(e = new F(), t = new F(), n = new F(), i = new F()) {
        super(),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = i);
      }
      getPoint(e, t = new F()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2,
          a = this.v3;
        return (
          n.set(
            ca(e, i.x, r.x, s.x, a.x),
            ca(e, i.y, r.y, s.y, a.y),
            ca(e, i.z, r.z, s.z, a.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    ua.prototype.isCubicBezierCurve3 = !0;
    class da extends Qs {
      constructor(e = new M(), t = new M()) {
        super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
      }
      getPoint(e, t = new M()) {
        const n = t;
        return (
          1 === e
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
          n
        );
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t) {
        const n = t || new M();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    da.prototype.isLineCurve = !0;
    class pa extends Qs {
      constructor(e = new F(), t = new F()) {
        super(),
          (this.type = "LineCurve3"),
          (this.isLineCurve3 = !0),
          (this.v1 = e),
          (this.v2 = t);
      }
      getPoint(e, t = new F()) {
        const n = t;
        return (
          1 === e
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
          n
        );
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    class ma extends Qs {
      constructor(e = new M(), t = new M(), n = new M()) {
        super(),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new M()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return n.set(la(e, i.x, r.x, s.x), la(e, i.y, r.y, s.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    ma.prototype.isQuadraticBezierCurve = !0;
    class fa extends Qs {
      constructor(e = new F(), t = new F(), n = new F()) {
        super(),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new F()) {
        const n = t,
          i = this.v0,
          r = this.v1,
          s = this.v2;
        return (
          n.set(
            la(e, i.x, r.x, s.x),
            la(e, i.y, r.y, s.y),
            la(e, i.z, r.z, s.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    fa.prototype.isQuadraticBezierCurve3 = !0;
    class ga extends Qs {
      constructor(e = []) {
        super(), (this.type = "SplineCurve"), (this.points = e);
      }
      getPoint(e, t = new M()) {
        const n = t,
          i = this.points,
          r = (i.length - 1) * e,
          s = Math.floor(r),
          a = r - s,
          o = i[0 === s ? s : s - 1],
          l = i[s],
          c = i[s > i.length - 2 ? i.length - 1 : s + 1],
          h = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return n.set(oa(a, o.x, l.x, c.x, h.x), oa(a, o.y, l.y, c.y, h.y)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new M().fromArray(n));
        }
        return this;
      }
    }
    ga.prototype.isSplineCurve = !0;
    var va = Object.freeze({
      __proto__: null,
      ArcCurve: ea,
      CatmullRomCurve3: aa,
      CubicBezierCurve: ha,
      CubicBezierCurve3: ua,
      EllipseCurve: $s,
      LineCurve: da,
      LineCurve3: pa,
      QuadraticBezierCurve: ma,
      QuadraticBezierCurve3: fa,
      SplineCurve: ga,
    });
    class _a extends Qs {
      constructor() {
        super(),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      add(e) {
        this.curves.push(e);
      }
      closePath() {
        const e = this.curves[0].getPoint(0),
          t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new da(t, e));
      }
      getPoint(e, t) {
        const n = e * this.getLength(),
          i = this.getCurveLengths();
        let r = 0;
        for (; r < i.length; ) {
          if (i[r] >= n) {
            const e = i[r] - n,
              s = this.curves[r],
              a = s.getLength(),
              o = 0 === a ? 0 : 1 - e / a;
            return s.getPointAt(o, t);
          }
          r++;
        }
        return null;
      }
      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }
      updateArcLengths() {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      }
      getCurveLengths() {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
          (t += this.curves[n].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
      }
      getSpacedPoints(e = 40) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]), t;
      }
      getPoints(e = 12) {
        const t = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
          const s = r[i],
            a =
              s && s.isEllipseCurve
                ? 2 * e
                : s && (s.isLineCurve || s.isLineCurve3)
                ? 1
                : s && s.isSplineCurve
                ? e * s.points.length
                : e,
            o = s.getPoints(a);
          for (let e = 0; e < o.length; e++) {
            const i = o[e];
            (n && n.equals(i)) || (t.push(i), (n = i));
          }
        }
        return (
          this.autoClose &&
            t.length > 1 &&
            !t[t.length - 1].equals(t[0]) &&
            t.push(t[0]),
          t
        );
      }
      copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(n.clone());
        }
        return (this.autoClose = e.autoClose), this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, n = this.curves.length; t < n; t++) {
          const n = this.curves[t];
          e.curves.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(new va[n.type]().fromJSON(n));
        }
        return this;
      }
    }
    class xa extends _a {
      constructor(e) {
        super(),
          (this.type = "Path"),
          (this.currentPoint = new M()),
          e && this.setFromPoints(e);
      }
      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      }
      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }
      lineTo(e, t) {
        const n = new da(this.currentPoint.clone(), new M(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
      }
      quadraticCurveTo(e, t, n, i) {
        const r = new ma(this.currentPoint.clone(), new M(e, t), new M(n, i));
        return this.curves.push(r), this.currentPoint.set(n, i), this;
      }
      bezierCurveTo(e, t, n, i, r, s) {
        const a = new ha(
          this.currentPoint.clone(),
          new M(e, t),
          new M(n, i),
          new M(r, s)
        );
        return this.curves.push(a), this.currentPoint.set(r, s), this;
      }
      splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
          n = new ga(t);
        return (
          this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
        );
      }
      arc(e, t, n, i, r, s) {
        const a = this.currentPoint.x,
          o = this.currentPoint.y;
        return this.absarc(e + a, t + o, n, i, r, s), this;
      }
      absarc(e, t, n, i, r, s) {
        return this.absellipse(e, t, n, n, i, r, s), this;
      }
      ellipse(e, t, n, i, r, s, a, o) {
        const l = this.currentPoint.x,
          c = this.currentPoint.y;
        return this.absellipse(e + l, t + c, n, i, r, s, a, o), this;
      }
      absellipse(e, t, n, i, r, s, a, o) {
        const l = new $s(e, t, n, i, r, s, a, o);
        if (this.curves.length > 0) {
          const e = l.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
        );
      }
    }
    class ya extends xa {
      constructor(e) {
        super(e), (this.uuid = f()), (this.type = "Shape"), (this.holes = []);
      }
      getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
          t[n] = this.holes[n].getPoints(e);
        return t;
      }
      extractPoints(e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
      }
      copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, n = this.holes.length; t < n; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(new xa().fromJSON(n));
        }
        return this;
      }
    }
    const ba = function (e, t, n = 2) {
      const i = t && t.length,
        r = i ? t[0] * n : e.length;
      let s = wa(e, 0, r, n, !0);
      const a = [];
      if (!s || s.next === s.prev) return a;
      let o, l, c, h, u, d, p;
      if (
        (i &&
          (s = (function (e, t, n, i) {
            const r = [];
            let s, a, o, l, c;
            for (s = 0, a = t.length; s < a; s++)
              (o = t[s] * i),
                (l = s < a - 1 ? t[s + 1] * i : e.length),
                (c = wa(e, o, l, i, !1)),
                c === c.next && (c.steiner = !0),
                r.push(Da(c));
            for (r.sort(Ra), s = 0; s < r.length; s++)
              Ca(r[s], n), (n = Ma(n, n.next));
            return n;
          })(e, t, s, n)),
        e.length > 80 * n)
      ) {
        (o = c = e[0]), (l = h = e[1]);
        for (let t = n; t < r; t += n)
          (u = e[t]),
            (d = e[t + 1]),
            u < o && (o = u),
            d < l && (l = d),
            u > c && (c = u),
            d > h && (h = d);
        (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);
      }
      return Sa(s, a, n, o, l, p), a;
    };
    function wa(e, t, n, i, r) {
      let s, a;
      if (
        r ===
        (function (e, t, n, i) {
          let r = 0;
          for (let s = t, a = n - i; s < n; s += i)
            (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
          return r;
        })(e, t, n, i) >
          0
      )
        for (s = t; s < n; s += i) a = Va(s, e[s], e[s + 1], a);
      else for (s = n - i; s >= t; s -= i) a = Va(s, e[s], e[s + 1], a);
      return a && Fa(a, a.next) && (Wa(a), (a = a.next)), a;
    }
    function Ma(e, t) {
      if (!e) return e;
      t || (t = e);
      let n,
        i = e;
      do {
        if (
          ((n = !1),
          i.steiner || (!Fa(i, i.next) && 0 !== za(i.prev, i, i.next)))
        )
          i = i.next;
        else {
          if ((Wa(i), (i = t = i.prev), i === i.next)) break;
          n = !0;
        }
      } while (n || i !== t);
      return t;
    }
    function Sa(e, t, n, i, r, s, a) {
      if (!e) return;
      !a &&
        s &&
        (function (e, t, n, i) {
          let r = e;
          do {
            null === r.z && (r.z = Ia(r.x, r.y, t, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== e);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (e) {
              let t,
                n,
                i,
                r,
                s,
                a,
                o,
                l,
                c = 1;
              do {
                for (n = e, e = null, s = null, a = 0; n; ) {
                  for (
                    a++, i = n, o = 0, t = 0;
                    t < c && (o++, (i = i.nextZ), i);
                    t++
                  );
                  for (l = c; o > 0 || (l > 0 && i); )
                    0 !== o && (0 === l || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), o--)
                      : ((r = i), (i = i.nextZ), l--),
                      s ? (s.nextZ = r) : (e = r),
                      (r.prevZ = s),
                      (s = r);
                  n = i;
                }
                (s.nextZ = null), (c *= 2);
              } while (a > 1);
            })(r);
        })(e, i, r, s);
      let o,
        l,
        c = e;
      for (; e.prev !== e.next; )
        if (((o = e.prev), (l = e.next), s ? Ea(e, i, r, s) : Ta(e)))
          t.push(o.i / n),
            t.push(e.i / n),
            t.push(l.i / n),
            Wa(e),
            (e = l.next),
            (c = l.next);
        else if ((e = l) === c) {
          a
            ? 1 === a
              ? Sa((e = Aa(Ma(e), t, n)), t, n, i, r, s, 2)
              : 2 === a && La(e, t, n, i, r, s)
            : Sa(Ma(e), t, n, i, r, s, 1);
          break;
        }
    }
    function Ta(e) {
      const t = e.prev,
        n = e,
        i = e.next;
      if (za(t, n, i) >= 0) return !1;
      let r = e.next.next;
      for (; r !== e.prev; ) {
        if (
          Na(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
          za(r.prev, r, r.next) >= 0
        )
          return !1;
        r = r.next;
      }
      return !0;
    }
    function Ea(e, t, n, i) {
      const r = e.prev,
        s = e,
        a = e.next;
      if (za(r, s, a) >= 0) return !1;
      const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,
        l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,
        c = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,
        h = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,
        u = Ia(o, l, t, n, i),
        d = Ia(c, h, t, n, i);
      let p = e.prevZ,
        m = e.nextZ;
      for (; p && p.z >= u && m && m.z <= d; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Na(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
          za(p.prev, p, p.next) >= 0
        )
          return !1;
        if (
          ((p = p.prevZ),
          m !== e.prev &&
            m !== e.next &&
            Na(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
            za(m.prev, m, m.next) >= 0)
        )
          return !1;
        m = m.nextZ;
      }
      for (; p && p.z >= u; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Na(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
          za(p.prev, p, p.next) >= 0
        )
          return !1;
        p = p.prevZ;
      }
      for (; m && m.z <= d; ) {
        if (
          m !== e.prev &&
          m !== e.next &&
          Na(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
          za(m.prev, m, m.next) >= 0
        )
          return !1;
        m = m.nextZ;
      }
      return !0;
    }
    function Aa(e, t, n) {
      let i = e;
      do {
        const r = i.prev,
          s = i.next.next;
        !Fa(r, s) &&
          Ba(r, i, i.next, s) &&
          ka(r, s) &&
          ka(s, r) &&
          (t.push(r.i / n),
          t.push(i.i / n),
          t.push(s.i / n),
          Wa(i),
          Wa(i.next),
          (i = e = s)),
          (i = i.next);
      } while (i !== e);
      return Ma(i);
    }
    function La(e, t, n, i, r, s) {
      let a = e;
      do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
          if (a.i !== e.i && Oa(a, e)) {
            let o = Ga(a, e);
            return (
              (a = Ma(a, a.next)),
              (o = Ma(o, o.next)),
              Sa(a, t, n, i, r, s),
              void Sa(o, t, n, i, r, s)
            );
          }
          e = e.next;
        }
        a = a.next;
      } while (a !== e);
    }
    function Ra(e, t) {
      return e.x - t.x;
    }
    function Ca(e, t) {
      if (
        (t = (function (e, t) {
          let n = t;
          const i = e.x,
            r = e.y;
          let s,
            a = -1 / 0;
          do {
            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
              const e = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
              if (e <= i && e > a) {
                if (((a = e), e === i)) {
                  if (r === n.y) return n;
                  if (r === n.next.y) return n.next;
                }
                s = n.x < n.next.x ? n : n.next;
              }
            }
            n = n.next;
          } while (n !== t);
          if (!s) return null;
          if (i === a) return s;
          const o = s,
            l = s.x,
            c = s.y;
          let h,
            u = 1 / 0;
          n = s;
          do {
            i >= n.x &&
              n.x >= l &&
              i !== n.x &&
              Na(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) &&
              ((h = Math.abs(r - n.y) / (i - n.x)),
              ka(n, e) &&
                (h < u ||
                  (h === u && (n.x > s.x || (n.x === s.x && Pa(s, n))))) &&
                ((s = n), (u = h))),
              (n = n.next);
          } while (n !== o);
          return s;
        })(e, t))
      ) {
        const n = Ga(t, e);
        Ma(t, t.next), Ma(n, n.next);
      }
    }
    function Pa(e, t) {
      return za(e.prev, e, t.prev) < 0 && za(t.next, e, e.next) < 0;
    }
    function Ia(e, t, n, i, r) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) <<
          1)
      );
    }
    function Da(e) {
      let t = e,
        n = e;
      do {
        (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
      } while (t !== e);
      return n;
    }
    function Na(e, t, n, i, r, s, a, o) {
      return (
        (r - a) * (t - o) - (e - a) * (s - o) >= 0 &&
        (e - a) * (i - o) - (n - a) * (t - o) >= 0 &&
        (n - a) * (s - o) - (r - a) * (i - o) >= 0
      );
    }
    function Oa(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          let n = e;
          do {
            if (
              n.i !== e.i &&
              n.next.i !== e.i &&
              n.i !== t.i &&
              n.next.i !== t.i &&
              Ba(n, n.next, e, t)
            )
              return !0;
            n = n.next;
          } while (n !== e);
          return !1;
        })(e, t) &&
        ((ka(e, t) &&
          ka(t, e) &&
          (function (e, t) {
            let n = e,
              i = !1;
            const r = (e.x + t.x) / 2,
              s = (e.y + t.y) / 2;
            do {
              n.y > s != n.next.y > s &&
                n.next.y !== n.y &&
                r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                (i = !i),
                (n = n.next);
            } while (n !== e);
            return i;
          })(e, t) &&
          (za(e.prev, e, t.prev) || za(e, t.prev, t))) ||
          (Fa(e, t) && za(e.prev, e, e.next) > 0 && za(t.prev, t, t.next) > 0))
      );
    }
    function za(e, t, n) {
      return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
    }
    function Fa(e, t) {
      return e.x === t.x && e.y === t.y;
    }
    function Ba(e, t, n, i) {
      const r = Ha(za(e, t, n)),
        s = Ha(za(e, t, i)),
        a = Ha(za(n, i, e)),
        o = Ha(za(n, i, t));
      return (
        (r !== s && a !== o) ||
        !(0 !== r || !Ua(e, n, t)) ||
        !(0 !== s || !Ua(e, i, t)) ||
        !(0 !== a || !Ua(n, e, i)) ||
        !(0 !== o || !Ua(n, t, i))
      );
    }
    function Ua(e, t, n) {
      return (
        t.x <= Math.max(e.x, n.x) &&
        t.x >= Math.min(e.x, n.x) &&
        t.y <= Math.max(e.y, n.y) &&
        t.y >= Math.min(e.y, n.y)
      );
    }
    function Ha(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    function ka(e, t) {
      return za(e.prev, e, e.next) < 0
        ? za(e, t, e.next) >= 0 && za(e, e.prev, t) >= 0
        : za(e, t, e.prev) < 0 || za(e, e.next, t) < 0;
    }
    function Ga(e, t) {
      const n = new ja(e.i, e.x, e.y),
        i = new ja(t.i, t.x, t.y),
        r = e.next,
        s = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (n.next = r),
        (r.prev = n),
        (i.next = n),
        (n.prev = i),
        (s.next = i),
        (i.prev = s),
        i
      );
    }
    function Va(e, t, n, i) {
      const r = new ja(e, t, n);
      return (
        i
          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
          : ((r.prev = r), (r.next = r)),
        r
      );
    }
    function Wa(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }
    function ja(e, t, n) {
      (this.i = e),
        (this.x = t),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    class qa {
      static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, r = 0; r < t; i = r++)
          n += e[i].x * e[r].y - e[r].x * e[i].y;
        return 0.5 * n;
      }
      static isClockWise(e) {
        return qa.area(e) < 0;
      }
      static triangulateShape(e, t) {
        const n = [],
          i = [],
          r = [];
        Xa(e), Ya(n, e);
        let s = e.length;
        t.forEach(Xa);
        for (let e = 0; e < t.length; e++)
          i.push(s), (s += t[e].length), Ya(n, t[e]);
        const a = ba(n, i);
        for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
        return r;
      }
    }
    function Xa(e) {
      const t = e.length;
      t > 2 && e[t - 1].equals(e[0]) && e.pop();
    }
    function Ya(e, t) {
      for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
    }
    class Ja extends yt {
      constructor(
        e = new ya([
          new M(0.5, 0.5),
          new M(-0.5, 0.5),
          new M(-0.5, -0.5),
          new M(0.5, -0.5),
        ]),
        t = {}
      ) {
        super(),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = { shapes: e, options: t }),
          (e = Array.isArray(e) ? e : [e]);
        const n = this,
          i = [],
          r = [];
        for (let t = 0, n = e.length; t < n; t++) {
          s(e[t]);
        }
        function s(e) {
          const s = [],
            a = void 0 !== t.curveSegments ? t.curveSegments : 12,
            o = void 0 !== t.steps ? t.steps : 1;
          let l = void 0 !== t.depth ? t.depth : 1,
            c = void 0 === t.bevelEnabled || t.bevelEnabled,
            h = void 0 !== t.bevelThickness ? t.bevelThickness : 0.2,
            u = void 0 !== t.bevelSize ? t.bevelSize : h - 0.1,
            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
          const m = t.extrudePath,
            f = void 0 !== t.UVGenerator ? t.UVGenerator : Za;
          void 0 !== t.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (l = t.amount));
          let g,
            v,
            _,
            x,
            y,
            b = !1;
          m &&
            ((g = m.getSpacedPoints(o)),
            (b = !0),
            (c = !1),
            (v = m.computeFrenetFrames(o, !1)),
            (_ = new F()),
            (x = new F()),
            (y = new F())),
            c || ((p = 0), (h = 0), (u = 0), (d = 0));
          const w = e.extractPoints(a);
          let S = w.shape;
          const T = w.holes;
          if (!qa.isClockWise(S)) {
            S = S.reverse();
            for (let e = 0, t = T.length; e < t; e++) {
              const t = T[e];
              qa.isClockWise(t) && (T[e] = t.reverse());
            }
          }
          const E = qa.triangulateShape(S, T),
            A = S;
          for (let e = 0, t = T.length; e < t; e++) {
            const t = T[e];
            S = S.concat(t);
          }
          function L(e, t, n) {
            return (
              t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              t.clone().multiplyScalar(n).add(e)
            );
          }
          const R = S.length,
            C = E.length;
          function P(e, t, n) {
            let i, r, s;
            const a = e.x - t.x,
              o = e.y - t.y,
              l = n.x - e.x,
              c = n.y - e.y,
              h = a * a + o * o,
              u = a * c - o * l;
            if (Math.abs(u) > Number.EPSILON) {
              const u = Math.sqrt(h),
                d = Math.sqrt(l * l + c * c),
                p = t.x - o / u,
                m = t.y + a / u,
                f =
                  ((n.x - c / d - p) * c - (n.y + l / d - m) * l) /
                  (a * c - o * l);
              (i = p + a * f - e.x), (r = m + o * f - e.y);
              const g = i * i + r * r;
              if (g <= 2) return new M(i, r);
              s = Math.sqrt(g / 2);
            } else {
              let e = !1;
              a > Number.EPSILON
                ? l > Number.EPSILON && (e = !0)
                : a < -Number.EPSILON
                ? l < -Number.EPSILON && (e = !0)
                : Math.sign(o) === Math.sign(c) && (e = !0),
                e
                  ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                  : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
            }
            return new M(i / s, r / s);
          }
          const I = [];
          for (
            let e = 0, t = A.length, n = t - 1, i = e + 1;
            e < t;
            e++, n++, i++
          )
            n === t && (n = 0),
              i === t && (i = 0),
              (I[e] = P(A[e], A[n], A[i]));
          const D = [];
          let N,
            O = I.concat();
          for (let e = 0, t = T.length; e < t; e++) {
            const t = T[e];
            N = [];
            for (
              let e = 0, n = t.length, i = n - 1, r = e + 1;
              e < n;
              e++, i++, r++
            )
              i === n && (i = 0),
                r === n && (r = 0),
                (N[e] = P(t[e], t[i], t[r]));
            D.push(N), (O = O.concat(N));
          }
          for (let e = 0; e < p; e++) {
            const t = e / p,
              n = h * Math.cos((t * Math.PI) / 2),
              i = u * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = A.length; e < t; e++) {
              const t = L(A[e], I[e], i);
              U(t.x, t.y, -n);
            }
            for (let e = 0, t = T.length; e < t; e++) {
              const t = T[e];
              N = D[e];
              for (let e = 0, r = t.length; e < r; e++) {
                const r = L(t[e], N[e], i);
                U(r.x, r.y, -n);
              }
            }
          }
          const z = u + d;
          for (let e = 0; e < R; e++) {
            const t = c ? L(S[e], O[e], z) : S[e];
            b
              ? (x.copy(v.normals[0]).multiplyScalar(t.x),
                _.copy(v.binormals[0]).multiplyScalar(t.y),
                y.copy(g[0]).add(x).add(_),
                U(y.x, y.y, y.z))
              : U(t.x, t.y, 0);
          }
          for (let e = 1; e <= o; e++)
            for (let t = 0; t < R; t++) {
              const n = c ? L(S[t], O[t], z) : S[t];
              b
                ? (x.copy(v.normals[e]).multiplyScalar(n.x),
                  _.copy(v.binormals[e]).multiplyScalar(n.y),
                  y.copy(g[e]).add(x).add(_),
                  U(y.x, y.y, y.z))
                : U(n.x, n.y, (l / o) * e);
            }
          for (let e = p - 1; e >= 0; e--) {
            const t = e / p,
              n = h * Math.cos((t * Math.PI) / 2),
              i = u * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = A.length; e < t; e++) {
              const t = L(A[e], I[e], i);
              U(t.x, t.y, l + n);
            }
            for (let e = 0, t = T.length; e < t; e++) {
              const t = T[e];
              N = D[e];
              for (let e = 0, r = t.length; e < r; e++) {
                const r = L(t[e], N[e], i);
                b
                  ? U(r.x, r.y + g[o - 1].y, g[o - 1].x + n)
                  : U(r.x, r.y, l + n);
              }
            }
          }
          function B(e, t) {
            let n = e.length;
            for (; --n >= 0; ) {
              const i = n;
              let r = n - 1;
              r < 0 && (r = e.length - 1);
              for (let e = 0, n = o + 2 * p; e < n; e++) {
                const n = R * e,
                  s = R * (e + 1);
                k(t + i + n, t + r + n, t + r + s, t + i + s);
              }
            }
          }
          function U(e, t, n) {
            s.push(e), s.push(t), s.push(n);
          }
          function H(e, t, r) {
            G(e), G(t), G(r);
            const s = i.length / 3,
              a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
            V(a[0]), V(a[1]), V(a[2]);
          }
          function k(e, t, r, s) {
            G(e), G(t), G(s), G(t), G(r), G(s);
            const a = i.length / 3,
              o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
            V(o[0]), V(o[1]), V(o[3]), V(o[1]), V(o[2]), V(o[3]);
          }
          function G(e) {
            i.push(s[3 * e + 0]), i.push(s[3 * e + 1]), i.push(s[3 * e + 2]);
          }
          function V(e) {
            r.push(e.x), r.push(e.y);
          }
          !(function () {
            const e = i.length / 3;
            if (c) {
              let e = 0,
                t = R * e;
              for (let e = 0; e < C; e++) {
                const n = E[e];
                H(n[2] + t, n[1] + t, n[0] + t);
              }
              (e = o + 2 * p), (t = R * e);
              for (let e = 0; e < C; e++) {
                const n = E[e];
                H(n[0] + t, n[1] + t, n[2] + t);
              }
            } else {
              for (let e = 0; e < C; e++) {
                const t = E[e];
                H(t[2], t[1], t[0]);
              }
              for (let e = 0; e < C; e++) {
                const t = E[e];
                H(t[0] + R * o, t[1] + R * o, t[2] + R * o);
              }
            }
            n.addGroup(e, i.length / 3 - e, 0);
          })(),
            (function () {
              const e = i.length / 3;
              let t = 0;
              B(A, t), (t += A.length);
              for (let e = 0, n = T.length; e < n; e++) {
                const n = T[e];
                B(n, t), (t += n.length);
              }
              n.addGroup(e, i.length / 3 - e, 1);
            })();
        }
        this.setAttribute("position", new dt(i, 3)),
          this.setAttribute("uv", new dt(r, 2)),
          this.computeVertexNormals();
      }
      toJSON() {
        const e = super.toJSON();
        return (function (e, t, n) {
          if (((n.shapes = []), Array.isArray(e)))
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t];
              n.shapes.push(i.uuid);
            }
          else n.shapes.push(e.uuid);
          void 0 !== t.extrudePath &&
            (n.options.extrudePath = t.extrudePath.toJSON());
          return n;
        })(this.parameters.shapes, this.parameters.options, e);
      }
      static fromJSON(e, t) {
        const n = [];
        for (let i = 0, r = e.shapes.length; i < r; i++) {
          const r = t[e.shapes[i]];
          n.push(r);
        }
        const i = e.options.extrudePath;
        return (
          void 0 !== i &&
            (e.options.extrudePath = new va[i.type]().fromJSON(i)),
          new Ja(n, e.options)
        );
      }
    }
    const Za = {
      generateTopUV: function (e, t, n, i, r) {
        const s = t[3 * n],
          a = t[3 * n + 1],
          o = t[3 * i],
          l = t[3 * i + 1],
          c = t[3 * r],
          h = t[3 * r + 1];
        return [new M(s, a), new M(o, l), new M(c, h)];
      },
      generateSideWallUV: function (e, t, n, i, r, s) {
        const a = t[3 * n],
          o = t[3 * n + 1],
          l = t[3 * n + 2],
          c = t[3 * i],
          h = t[3 * i + 1],
          u = t[3 * i + 2],
          d = t[3 * r],
          p = t[3 * r + 1],
          m = t[3 * r + 2],
          f = t[3 * s],
          g = t[3 * s + 1],
          v = t[3 * s + 2];
        return Math.abs(o - h) < Math.abs(a - c)
          ? [new M(a, 1 - l), new M(c, 1 - u), new M(d, 1 - m), new M(f, 1 - v)]
          : [
              new M(o, 1 - l),
              new M(h, 1 - u),
              new M(p, 1 - m),
              new M(g, 1 - v),
            ];
      },
    };
    class Ka extends yt {
      constructor(
        e = new ya([new M(0, 0.5), new M(-0.5, -0.5), new M(0.5, -0.5)]),
        t = 12
      ) {
        super(),
          (this.type = "ShapeGeometry"),
          (this.parameters = { shapes: e, curveSegments: t });
        const n = [],
          i = [],
          r = [],
          s = [];
        let a = 0,
          o = 0;
        if (!1 === Array.isArray(e)) l(e);
        else
          for (let t = 0; t < e.length; t++)
            l(e[t]), this.addGroup(a, o, t), (a += o), (o = 0);
        function l(e) {
          const a = i.length / 3,
            l = e.extractPoints(t);
          let c = l.shape;
          const h = l.holes;
          !1 === qa.isClockWise(c) && (c = c.reverse());
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e];
            !0 === qa.isClockWise(t) && (h[e] = t.reverse());
          }
          const u = qa.triangulateShape(c, h);
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e];
            c = c.concat(t);
          }
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y);
          }
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e],
              i = t[0] + a,
              r = t[1] + a,
              s = t[2] + a;
            n.push(i, r, s), (o += 3);
          }
        }
        this.setIndex(n),
          this.setAttribute("position", new dt(i, 3)),
          this.setAttribute("normal", new dt(r, 3)),
          this.setAttribute("uv", new dt(s, 2));
      }
      toJSON() {
        const e = super.toJSON();
        return (function (e, t) {
          if (((t.shapes = []), Array.isArray(e)))
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              t.shapes.push(i.uuid);
            }
          else t.shapes.push(e.uuid);
          return t;
        })(this.parameters.shapes, e);
      }
      static fromJSON(e, t) {
        const n = [];
        for (let i = 0, r = e.shapes.length; i < r; i++) {
          const r = t[e.shapes[i]];
          n.push(r);
        }
        return new Ka(n, e.curveSegments);
      }
    }
    class Qa extends yt {
      constructor(
        e = 1,
        t = 32,
        n = 16,
        i = 0,
        r = 2 * Math.PI,
        s = 0,
        a = Math.PI
      ) {
        super(),
          (this.type = "SphereGeometry"),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: s,
            thetaLength: a,
          }),
          (t = Math.max(3, Math.floor(t))),
          (n = Math.max(2, Math.floor(n)));
        const o = Math.min(s + a, Math.PI);
        let l = 0;
        const c = [],
          h = new F(),
          u = new F(),
          d = [],
          p = [],
          m = [],
          f = [];
        for (let d = 0; d <= n; d++) {
          const g = [],
            v = d / n;
          let _ = 0;
          0 == d && 0 == s
            ? (_ = 0.5 / t)
            : d == n && o == Math.PI && (_ = -0.5 / t);
          for (let n = 0; n <= t; n++) {
            const o = n / t;
            (h.x = -e * Math.cos(i + o * r) * Math.sin(s + v * a)),
              (h.y = e * Math.cos(s + v * a)),
              (h.z = e * Math.sin(i + o * r) * Math.sin(s + v * a)),
              p.push(h.x, h.y, h.z),
              u.copy(h).normalize(),
              m.push(u.x, u.y, u.z),
              f.push(o + _, 1 - v),
              g.push(l++);
          }
          c.push(g);
        }
        for (let e = 0; e < n; e++)
          for (let i = 0; i < t; i++) {
            const t = c[e][i + 1],
              r = c[e][i],
              a = c[e + 1][i],
              l = c[e + 1][i + 1];
            (0 !== e || s > 0) && d.push(t, r, l),
              (e !== n - 1 || o < Math.PI) && d.push(r, a, l);
          }
        this.setIndex(d),
          this.setAttribute("position", new dt(p, 3)),
          this.setAttribute("normal", new dt(m, 3)),
          this.setAttribute("uv", new dt(f, 2));
      }
      static fromJSON(e) {
        return new Qa(
          e.radius,
          e.widthSegments,
          e.heightSegments,
          e.phiStart,
          e.phiLength,
          e.thetaStart,
          e.thetaLength
        );
      }
    }
    class $a extends Qe {
      constructor(e) {
        super(),
          (this.type = "ShadowMaterial"),
          (this.color = new st(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this;
      }
    }
    $a.prototype.isShadowMaterial = !0;
    class eo extends Qe {
      constructor(e) {
        super(),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new st(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new st(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new M(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "" }),
          this.color.copy(e.color),
          (this.roughness = e.roughness),
          (this.metalness = e.metalness),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.roughnessMap = e.roughnessMap),
          (this.metalnessMap = e.metalnessMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.envMapIntensity = e.envMapIntensity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    eo.prototype.isMeshStandardMaterial = !0;
    class to extends eo {
      constructor(e) {
        super(),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new M(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.ior = 1.5),
          Object.defineProperty(this, "reflectivity", {
            get: function () {
              return g((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
            },
            set: function (e) {
              this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
            },
          }),
          (this.sheenColor = new st(0)),
          (this.sheenColorMap = null),
          (this.sheenRoughness = 1),
          (this.sheenRoughnessMap = null),
          (this.transmissionMap = null),
          (this.thickness = 0),
          (this.thicknessMap = null),
          (this.attenuationDistance = 0),
          (this.attenuationColor = new st(1, 1, 1)),
          (this.specularIntensity = 1),
          (this.specularIntensityMap = null),
          (this.specularColor = new st(1, 1, 1)),
          (this.specularColorMap = null),
          (this._sheen = 0),
          (this._clearcoat = 0),
          (this._transmission = 0),
          this.setValues(e);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
          (this._transmission = e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.clearcoat = e.clearcoat),
          (this.clearcoatMap = e.clearcoatMap),
          (this.clearcoatRoughness = e.clearcoatRoughness),
          (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = e.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
          (this.ior = e.ior),
          (this.sheen = e.sheen),
          this.sheenColor.copy(e.sheenColor),
          (this.sheenColorMap = e.sheenColorMap),
          (this.sheenRoughness = e.sheenRoughness),
          (this.sheenRoughnessMap = e.sheenRoughnessMap),
          (this.transmission = e.transmission),
          (this.transmissionMap = e.transmissionMap),
          (this.thickness = e.thickness),
          (this.thicknessMap = e.thicknessMap),
          (this.attenuationDistance = e.attenuationDistance),
          this.attenuationColor.copy(e.attenuationColor),
          (this.specularIntensity = e.specularIntensity),
          (this.specularIntensityMap = e.specularIntensityMap),
          this.specularColor.copy(e.specularColor),
          (this.specularColorMap = e.specularColorMap),
          this
        );
      }
    }
    to.prototype.isMeshPhysicalMaterial = !0;
    class no extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshPhongMaterial"),
          (this.color = new st(16777215)),
          (this.specular = new st(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new st(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new M(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          this.specular.copy(e.specular),
          (this.shininess = e.shininess),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    no.prototype.isMeshPhongMaterial = !0;
    class io extends Qe {
      constructor(e) {
        super(),
          (this.defines = { TOON: "" }),
          (this.type = "MeshToonMaterial"),
          (this.color = new st(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new st(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new M(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.gradientMap = e.gradientMap),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    io.prototype.isMeshToonMaterial = !0;
    class ro extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new M(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    ro.prototype.isMeshNormalMaterial = !0;
    class so extends Qe {
      constructor(e) {
        super(),
          (this.type = "MeshLambertMaterial"),
          (this.color = new st(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new st(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    so.prototype.isMeshLambertMaterial = !0;
    class ao extends Qe {
      constructor(e) {
        super(),
          (this.defines = { MATCAP: "" }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new st(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new M(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { MATCAP: "" }),
          this.color.copy(e.color),
          (this.matcap = e.matcap),
          (this.map = e.map),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    ao.prototype.isMeshMatcapMaterial = !0;
    class oo extends Ds {
      constructor(e) {
        super(),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.scale = e.scale),
          (this.dashSize = e.dashSize),
          (this.gapSize = e.gapSize),
          this
        );
      }
    }
    oo.prototype.isLineDashedMaterial = !0;
    const lo = {
      arraySlice: function (e, t, n) {
        return lo.isTypedArray(e)
          ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
          : e.slice(t, n);
      },
      convertArray: function (e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      },
      isTypedArray: function (e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      },
      getKeyframeOrder: function (e) {
        const t = e.length,
          n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return (
          n.sort(function (t, n) {
            return e[t] - e[n];
          }),
          n
        );
      },
      sortedArray: function (e, t, n) {
        const i = e.length,
          r = new e.constructor(i);
        for (let s = 0, a = 0; a !== i; ++s) {
          const i = n[s] * t;
          for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
        }
        return r;
      },
      flattenJSON: function (e, t, n, i) {
        let r = 1,
          s = e[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
        if (void 0 === s) return;
        let a = s[i];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
                (s = e[r++]);
            } while (void 0 !== s);
          else if (void 0 !== a.toArray)
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
                (s = e[r++]);
            } while (void 0 !== s);
          else
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push(a)),
                (s = e[r++]);
            } while (void 0 !== s);
      },
      subclip: function (e, t, n, i, r = 30) {
        const s = e.clone();
        s.name = t;
        const a = [];
        for (let e = 0; e < s.tracks.length; ++e) {
          const t = s.tracks[e],
            o = t.getValueSize(),
            l = [],
            c = [];
          for (let e = 0; e < t.times.length; ++e) {
            const s = t.times[e] * r;
            if (!(s < n || s >= i)) {
              l.push(t.times[e]);
              for (let n = 0; n < o; ++n) c.push(t.values[e * o + n]);
            }
          }
          0 !== l.length &&
            ((t.times = lo.convertArray(l, t.times.constructor)),
            (t.values = lo.convertArray(c, t.values.constructor)),
            a.push(t));
        }
        s.tracks = a;
        let o = 1 / 0;
        for (let e = 0; e < s.tracks.length; ++e)
          o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
        for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
        return s.resetDuration(), s;
      },
      makeClipAdditive: function (e, t = 0, n = e, i = 30) {
        i <= 0 && (i = 30);
        const r = n.tracks.length,
          s = t / i;
        for (let t = 0; t < r; ++t) {
          const i = n.tracks[t],
            r = i.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const a = e.tracks.find(function (e) {
            return e.name === i.name && e.ValueTypeName === r;
          });
          if (void 0 === a) continue;
          let o = 0;
          const l = i.getValueSize();
          i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (o = l / 3);
          let c = 0;
          const h = a.getValueSize();
          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (c = h / 3);
          const u = i.times.length - 1;
          let d;
          if (s <= i.times[0]) {
            const e = o,
              t = l - o;
            d = lo.arraySlice(i.values, e, t);
          } else if (s >= i.times[u]) {
            const e = u * l + o,
              t = e + l - o;
            d = lo.arraySlice(i.values, e, t);
          } else {
            const e = i.createInterpolant(),
              t = o,
              n = l - o;
            e.evaluate(s), (d = lo.arraySlice(e.resultBuffer, t, n));
          }
          if ("quaternion" === r) {
            new z().fromArray(d).normalize().conjugate().toArray(d);
          }
          const p = a.times.length;
          for (let e = 0; e < p; ++e) {
            const t = e * h + c;
            if ("quaternion" === r)
              z.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
            else {
              const e = h - 2 * c;
              for (let n = 0; n < e; ++n) a.values[t + n] -= d[n];
            }
          }
        }
        return (e.blendMode = 2501), e;
      },
    };
    class co {
      constructor(e, t, n, i) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
          (this.sampleValues = t),
          (this.valueSize = n),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
          i = t[n],
          r = t[n - 1];
        e: {
          t: {
            let s;
            n: {
              i: if (!(e < i)) {
                for (let s = n + 2; ; ) {
                  if (void 0 === i) {
                    if (e < r) break i;
                    return (
                      (n = t.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, e, r)
                    );
                  }
                  if (n === s) break;
                  if (((r = i), (i = t[++n]), e < i)) break t;
                }
                s = t.length;
                break n;
              }
              if (e >= r) break e;
              {
                const a = t[1];
                e < a && ((n = 2), (r = a));
                for (let s = n - 2; ; ) {
                  if (void 0 === r)
                    return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
                  if (n === s) break;
                  if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                }
                (s = n), (n = 0);
              }
            }
            for (; n < s; ) {
              const i = (n + s) >>> 1;
              e < t[i] ? (s = i) : (n = i + 1);
            }
            if (((i = t[n]), (r = t[n - 1]), void 0 === r))
              return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
            if (void 0 === i)
              return (
                (n = t.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, e)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, e, i);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = e * i;
        for (let e = 0; e !== i; ++e) t[e] = n[r + e];
        return t;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    (co.prototype.beforeStart_ = co.prototype.copySampleValue_),
      (co.prototype.afterEnd_ = co.prototype.copySampleValue_);
    class ho extends co {
      constructor(e, t, n, i) {
        super(e, t, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
      }
      intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2,
          s = e + 1,
          a = i[r],
          o = i[s];
        if (void 0 === a)
          switch (this.getSettings_().endingStart) {
            case 2401:
              (r = e), (a = 2 * t - n);
              break;
            case 2402:
              (r = i.length - 2), (a = t + i[r] - i[r + 1]);
              break;
            default:
              (r = e), (a = n);
          }
        if (void 0 === o)
          switch (this.getSettings_().endingEnd) {
            case 2401:
              (s = e), (o = 2 * n - t);
              break;
            case 2402:
              (s = 1), (o = n + i[1] - i[0]);
              break;
            default:
              (s = e - 1), (o = t);
          }
        const l = 0.5 * (n - t),
          c = this.valueSize;
        (this._weightPrev = l / (t - a)),
          (this._weightNext = l / (o - n)),
          (this._offsetPrev = r * c),
          (this._offsetNext = s * c);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          c = this._offsetPrev,
          h = this._offsetNext,
          u = this._weightPrev,
          d = this._weightNext,
          p = (n - t) / (i - t),
          m = p * p,
          f = m * p,
          g = -u * f + 2 * u * m - u * p,
          v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
          _ = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
          x = d * f - d * m;
        for (let e = 0; e !== a; ++e)
          r[e] = g * s[c + e] + v * s[l + e] + _ * s[o + e] + x * s[h + e];
        return r;
      }
    }
    class uo extends co {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = e * a,
          l = o - a,
          c = (n - t) / (i - t),
          h = 1 - c;
        for (let e = 0; e !== a; ++e) r[e] = s[l + e] * h + s[o + e] * c;
        return r;
      }
    }
    class po extends co {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    }
    class mo {
      constructor(e, t, n, i) {
        if (void 0 === e)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = lo.convertArray(t, this.TimeBufferType)),
          (this.values = lo.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation);
      }
      static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);
        else {
          n = {
            name: e.name,
            times: lo.convertArray(e.times, Array),
            values: lo.convertArray(e.values, Array),
          };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (n.interpolation = t);
        }
        return (n.type = e.ValueTypeName), n;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new po(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new uo(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new ho(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case 2300:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case 2301:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t) {
          const t =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", t), this;
        }
        return (this.createInterpolant = t), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return 2300;
          case this.InterpolantFactoryMethodLinear:
            return 2301;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (0 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
        }
        return this;
      }
      scale(e) {
        if (1 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
        }
        return this;
      }
      trim(e, t) {
        const n = this.times,
          i = n.length;
        let r = 0,
          s = i - 1;
        for (; r !== i && n[r] < e; ) ++r;
        for (; -1 !== s && n[s] > t; ) --s;
        if ((++s, 0 !== r || s !== i)) {
          r >= s && ((s = Math.max(s, 1)), (r = s - 1));
          const e = this.getValueSize();
          (this.times = lo.arraySlice(n, r, s)),
            (this.values = lo.arraySlice(this.values, r * e, s * e));
        }
        return this;
      }
      validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (e = !1));
        const n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (e = !1));
        let s = null;
        for (let t = 0; t !== r; t++) {
          const i = n[t];
          if ("number" == typeof i && isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              t,
              i
            ),
              (e = !1);
            break;
          }
          if (null !== s && s > i) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              t,
              i,
              s
            ),
              (e = !1);
            break;
          }
          s = i;
        }
        if (void 0 !== i && lo.isTypedArray(i))
          for (let t = 0, n = i.length; t !== n; ++t) {
            const n = i[t];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                t,
                n
              ),
                (e = !1);
              break;
            }
          }
        return e;
      }
      optimize() {
        const e = lo.arraySlice(this.times),
          t = lo.arraySlice(this.values),
          n = this.getValueSize(),
          i = 2302 === this.getInterpolation(),
          r = e.length - 1;
        let s = 1;
        for (let a = 1; a < r; ++a) {
          let r = !1;
          const o = e[a];
          if (o !== e[a + 1] && (1 !== a || o !== e[0]))
            if (i) r = !0;
            else {
              const e = a * n,
                i = e - n,
                s = e + n;
              for (let a = 0; a !== n; ++a) {
                const n = t[e + a];
                if (n !== t[i + a] || n !== t[s + a]) {
                  r = !0;
                  break;
                }
              }
            }
          if (r) {
            if (a !== s) {
              e[s] = e[a];
              const i = a * n,
                r = s * n;
              for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
            }
            ++s;
          }
        }
        if (r > 0) {
          e[s] = e[r];
          for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
            t[i + a] = t[e + a];
          ++s;
        }
        return (
          s !== e.length
            ? ((this.times = lo.arraySlice(e, 0, s)),
              (this.values = lo.arraySlice(t, 0, s * n)))
            : ((this.times = e), (this.values = t)),
          this
        );
      }
      clone() {
        const e = lo.arraySlice(this.times, 0),
          t = lo.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, e, t);
        return (n.createInterpolant = this.createInterpolant), n;
      }
    }
    (mo.prototype.TimeBufferType = Float32Array),
      (mo.prototype.ValueBufferType = Float32Array),
      (mo.prototype.DefaultInterpolation = 2301);
    class fo extends mo {}
    (fo.prototype.ValueTypeName = "bool"),
      (fo.prototype.ValueBufferType = Array),
      (fo.prototype.DefaultInterpolation = 2300),
      (fo.prototype.InterpolantFactoryMethodLinear = void 0),
      (fo.prototype.InterpolantFactoryMethodSmooth = void 0);
    class go extends mo {}
    go.prototype.ValueTypeName = "color";
    class vo extends mo {}
    vo.prototype.ValueTypeName = "number";
    class _o extends co {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      interpolate_(e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = (n - t) / (i - t);
        let l = e * a;
        for (let e = l + a; l !== e; l += 4)
          z.slerpFlat(r, 0, s, l - a, s, l, o);
        return r;
      }
    }
    class xo extends mo {
      InterpolantFactoryMethodLinear(e) {
        return new _o(this.times, this.values, this.getValueSize(), e);
      }
    }
    (xo.prototype.ValueTypeName = "quaternion"),
      (xo.prototype.DefaultInterpolation = 2301),
      (xo.prototype.InterpolantFactoryMethodSmooth = void 0);
    class yo extends mo {}
    (yo.prototype.ValueTypeName = "string"),
      (yo.prototype.ValueBufferType = Array),
      (yo.prototype.DefaultInterpolation = 2300),
      (yo.prototype.InterpolantFactoryMethodLinear = void 0),
      (yo.prototype.InterpolantFactoryMethodSmooth = void 0);
    class bo extends mo {}
    bo.prototype.ValueTypeName = "vector";
    class wo {
      constructor(e, t = -1, n, i = 2500) {
        (this.name = e),
          (this.tracks = n),
          (this.duration = t),
          (this.blendMode = i),
          (this.uuid = f()),
          this.duration < 0 && this.resetDuration();
      }
      static parse(e) {
        const t = [],
          n = e.tracks,
          i = 1 / (e.fps || 1);
        for (let e = 0, r = n.length; e !== r; ++e) t.push(Mo(n[e]).scale(i));
        const r = new this(e.name, e.duration, t, e.blendMode);
        return (r.uuid = e.uuid), r;
      }
      static toJSON(e) {
        const t = [],
          n = e.tracks,
          i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode,
          };
        for (let e = 0, i = n.length; e !== i; ++e) t.push(mo.toJSON(n[e]));
        return i;
      }
      static CreateFromMorphTargetSequence(e, t, n, i) {
        const r = t.length,
          s = [];
        for (let e = 0; e < r; e++) {
          let a = [],
            o = [];
          a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
          const l = lo.getKeyframeOrder(a);
          (a = lo.sortedArray(a, 1, l)),
            (o = lo.sortedArray(o, 1, l)),
            i || 0 !== a[0] || (a.push(r), o.push(o[0])),
            s.push(
              new vo(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(
                1 / n
              )
            );
        }
        return new this(e, -1, s);
      }
      static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
          const t = e;
          n = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {},
          r = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t],
            s = n.name.match(r);
          if (s && s.length > 1) {
            const e = s[1];
            let t = i[e];
            t || (i[e] = t = []), t.push(n);
          }
        }
        const s = [];
        for (const e in i)
          s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
        return s;
      }
      static parseAnimation(e, t) {
        if (!e)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data."
            ),
            null
          );
        const n = function (e, t, n, i, r) {
            if (0 !== n.length) {
              const s = [],
                a = [];
              lo.flattenJSON(n, s, a, i),
                0 !== s.length && r.push(new e(t, s, a));
            }
          },
          i = [],
          r = e.name || "default",
          s = e.fps || 30,
          a = e.blendMode;
        let o = e.length || -1;
        const l = e.hierarchy || [];
        for (let e = 0; e < l.length; e++) {
          const r = l[e].keys;
          if (r && 0 !== r.length)
            if (r[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < r.length; t++)
                if (r[t].morphTargets)
                  for (let n = 0; n < r[t].morphTargets.length; n++)
                    e[r[t].morphTargets[n]] = -1;
              for (const n in e) {
                const e = [],
                  s = [];
                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                  const i = r[t];
                  e.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                }
                i.push(new vo(".morphTargetInfluence[" + n + "]", e, s));
              }
              o = e.length * (s || 1);
            } else {
              const s = ".bones[" + t[e].name + "]";
              n(bo, s + ".position", r, "pos", i),
                n(xo, s + ".quaternion", r, "rot", i),
                n(bo, s + ".scale", r, "scl", i);
            }
        }
        if (0 === i.length) return null;
        return new this(r, o, i, a);
      }
      resetDuration() {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
          const n = this.tracks[t];
          e = Math.max(e, n.times[n.times.length - 1]);
        }
        return (this.duration = e), this;
      }
      trim() {
        for (let e = 0; e < this.tracks.length; e++)
          this.tracks[e].trim(0, this.duration);
        return this;
      }
      validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
          e = e && this.tracks[t].validate();
        return e;
      }
      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      }
      clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
          e.push(this.tracks[t].clone());
        return new this.constructor(
          this.name,
          this.duration,
          e,
          this.blendMode
        );
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function Mo(e) {
      if (void 0 === e.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      const t = (function (e) {
        switch (e.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return vo;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return bo;
          case "color":
            return go;
          case "quaternion":
            return xo;
          case "bool":
          case "boolean":
            return fo;
          case "string":
            return yo;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
      })(e.type);
      if (void 0 === e.times) {
        const t = [],
          n = [];
        lo.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
      }
      return void 0 !== t.parse
        ? t.parse(e)
        : new t(e.name, e.times, e.values, e.interpolation);
    }
    const So = {
      enabled: !1,
      files: {},
      add: function (e, t) {
        !1 !== this.enabled && (this.files[e] = t);
      },
      get: function (e) {
        if (!1 !== this.enabled) return this.files[e];
      },
      remove: function (e) {
        delete this.files[e];
      },
      clear: function () {
        this.files = {};
      },
    };
    class To {
      constructor(e, t, n) {
        const i = this;
        let r = !1,
          s = 0,
          a = 0,
          o = void 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = n),
          (this.itemStart = function (e) {
            a++,
              !1 === r && void 0 !== i.onStart && i.onStart(e, s, a),
              (r = !0);
          }),
          (this.itemEnd = function (e) {
            s++,
              void 0 !== i.onProgress && i.onProgress(e, s, a),
              s === a && ((r = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== i.onError && i.onError(e);
          }),
          (this.resolveURL = function (e) {
            return o ? o(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (o = e), this;
          }),
          (this.addHandler = function (e, t) {
            return l.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (let t = 0, n = l.length; t < n; t += 2) {
              const n = l[t],
                i = l[t + 1];
              if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
            }
            return null;
          });
      }
    }
    const Eo = new To();
    class Ao {
      constructor(e) {
        (this.manager = void 0 !== e ? e : Eo),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(e, t) {
        const n = this;
        return new Promise(function (i, r) {
          n.load(e, i, t, r);
        });
      }
      parse() {}
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setWithCredentials(e) {
        return (this.withCredentials = e), this;
      }
      setPath(e) {
        return (this.path = e), this;
      }
      setResourcePath(e) {
        return (this.resourcePath = e), this;
      }
      setRequestHeader(e) {
        return (this.requestHeader = e), this;
      }
    }
    const Lo = {};
    class Ro extends Ao {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = So.get(e);
        if (void 0 !== r)
          return (
            this.manager.itemStart(e),
            setTimeout(() => {
              t && t(r), this.manager.itemEnd(e);
            }, 0),
            r
          );
        if (void 0 !== Lo[e])
          return void Lo[e].push({ onLoad: t, onProgress: n, onError: i });
        (Lo[e] = []), Lo[e].push({ onLoad: t, onProgress: n, onError: i });
        const s = new Request(e, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        });
        fetch(s)
          .then((t) => {
            if (200 === t.status || 0 === t.status) {
              0 === t.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              const n = Lo[e],
                i = t.body.getReader(),
                r = t.headers.get("Content-Length"),
                s = r ? parseInt(r) : 0,
                a = 0 !== s;
              let o = 0;
              return new ReadableStream({
                start(e) {
                  !(function t() {
                    i.read().then(({ done: i, value: r }) => {
                      if (i) e.close();
                      else {
                        o += r.byteLength;
                        const i = new ProgressEvent("progress", {
                          lengthComputable: a,
                          loaded: o,
                          total: s,
                        });
                        for (let e = 0, t = n.length; e < t; e++) {
                          const t = n[e];
                          t.onProgress && t.onProgress(i);
                        }
                        e.enqueue(r), t();
                      }
                    });
                  })();
                },
              });
            }
            throw Error(
              `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`
            );
          })
          .then((e) => {
            const t = new Response(e);
            switch (this.responseType) {
              case "arraybuffer":
                return t.arrayBuffer();
              case "blob":
                return t.blob();
              case "document":
                return t
                  .text()
                  .then((e) =>
                    new DOMParser().parseFromString(e, this.mimeType)
                  );
              case "json":
                return t.json();
              default:
                return t.text();
            }
          })
          .then((t) => {
            So.add(e, t);
            const n = Lo[e];
            delete Lo[e];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              i.onLoad && i.onLoad(t);
            }
            this.manager.itemEnd(e);
          })
          .catch((t) => {
            const n = Lo[e];
            delete Lo[e];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              i.onError && i.onError(t);
            }
            this.manager.itemError(e), this.manager.itemEnd(e);
          }),
          this.manager.itemStart(e);
      }
      setResponseType(e) {
        return (this.responseType = e), this;
      }
      setMimeType(e) {
        return (this.mimeType = e), this;
      }
    }
    class Co extends Ao {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          s = So.get(e);
        if (void 0 !== s)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(s), r.manager.itemEnd(e);
            }, 0),
            s
          );
        const a = E("img");
        function o() {
          c(), So.add(e, this), t && t(this), r.manager.itemEnd(e);
        }
        function l(t) {
          c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
        }
        function c() {
          a.removeEventListener("load", o, !1),
            a.removeEventListener("error", l, !1);
        }
        return (
          a.addEventListener("load", o, !1),
          a.addEventListener("error", l, !1),
          "data:" !== e.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (a.crossOrigin = this.crossOrigin),
          r.manager.itemStart(e),
          (a.src = e),
          a
        );
      }
    }
    class Po extends Ao {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = new Yt(),
          s = new Co(this.manager);
        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
        let a = 0;
        function o(n) {
          s.load(
            e[n],
            function (e) {
              (r.images[n] = e),
                a++,
                6 === a && ((r.needsUpdate = !0), t && t(r));
            },
            void 0,
            i
          );
        }
        for (let t = 0; t < e.length; ++t) o(t);
        return r;
      }
    }
    class Io extends Ao {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = new P(),
          s = new Co(this.manager);
        return (
          s.setCrossOrigin(this.crossOrigin),
          s.setPath(this.path),
          s.load(
            e,
            function (e) {
              (r.image = e), (r.needsUpdate = !0), void 0 !== t && t(r);
            },
            n,
            i
          ),
          r
        );
      }
    }
    class Do extends Ue {
      constructor(e, t = 1) {
        super(),
          (this.type = "Light"),
          (this.color = new st(e)),
          (this.intensity = t);
      }
      dispose() {}
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.intensity = e.intensity),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      }
    }
    Do.prototype.isLight = !0;
    class No extends Do {
      constructor(e, t, n) {
        super(e, n),
          (this.type = "HemisphereLight"),
          this.position.copy(Ue.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new st(t));
      }
      copy(e) {
        return (
          Do.prototype.copy.call(this, e),
          this.groundColor.copy(e.groundColor),
          this
        );
      }
    }
    No.prototype.isHemisphereLight = !0;
    const Oo = new me(),
      zo = new F(),
      Fo = new F();
    class Bo {
      constructor(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.blurSamples = 8),
          (this.mapSize = new M(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new me()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new nn()),
          (this._frameExtents = new M(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new D(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        const t = this.camera,
          n = this.matrix;
        zo.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(zo),
          Fo.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(Fo),
          t.updateMatrixWorld(),
          Oo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(Oo),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(t.projectionMatrix),
          n.multiply(t.matrixWorldInverse);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = {};
        return (
          0 !== this.bias && (e.bias = this.bias),
          0 !== this.normalBias && (e.normalBias = this.normalBias),
          1 !== this.radius && (e.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      }
    }
    class Uo extends Bo {
      constructor() {
        super(new qt(50, 1, 0.5, 500)), (this.focus = 1);
      }
      updateMatrices(e) {
        const t = this.camera,
          n = 2 * m * e.angle * this.focus,
          i = this.mapSize.width / this.mapSize.height,
          r = e.distance || t.far;
        (n === t.fov && i === t.aspect && r === t.far) ||
          ((t.fov = n),
          (t.aspect = i),
          (t.far = r),
          t.updateProjectionMatrix()),
          super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
      }
    }
    Uo.prototype.isSpotLightShadow = !0;
    class Ho extends Do {
      constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
        super(e, t),
          (this.type = "SpotLight"),
          this.position.copy(Ue.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ue()),
          (this.distance = n),
          (this.angle = i),
          (this.penumbra = r),
          (this.decay = s),
          (this.shadow = new Uo());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    Ho.prototype.isSpotLight = !0;
    const ko = new me(),
      Go = new F(),
      Vo = new F();
    class Wo extends Bo {
      constructor() {
        super(new qt(90, 1, 0.5, 500)),
          (this._frameExtents = new M(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new D(2, 1, 1, 1),
            new D(0, 1, 1, 1),
            new D(3, 1, 1, 1),
            new D(1, 1, 1, 1),
            new D(3, 0, 1, 1),
            new D(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new F(1, 0, 0),
            new F(-1, 0, 0),
            new F(0, 0, 1),
            new F(0, 0, -1),
            new F(0, 1, 0),
            new F(0, -1, 0),
          ]),
          (this._cubeUps = [
            new F(0, 1, 0),
            new F(0, 1, 0),
            new F(0, 1, 0),
            new F(0, 1, 0),
            new F(0, 0, 1),
            new F(0, 0, -1),
          ]);
      }
      updateMatrices(e, t = 0) {
        const n = this.camera,
          i = this.matrix,
          r = e.distance || n.far;
        r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
          Go.setFromMatrixPosition(e.matrixWorld),
          n.position.copy(Go),
          Vo.copy(n.position),
          Vo.add(this._cubeDirections[t]),
          n.up.copy(this._cubeUps[t]),
          n.lookAt(Vo),
          n.updateMatrixWorld(),
          i.makeTranslation(-Go.x, -Go.y, -Go.z),
          ko.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(ko);
      }
    }
    Wo.prototype.isPointLightShadow = !0;
    class jo extends Do {
      constructor(e, t, n = 0, i = 1) {
        super(e, t),
          (this.type = "PointLight"),
          (this.distance = n),
          (this.decay = i),
          (this.shadow = new Wo());
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.decay = e.decay),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    jo.prototype.isPointLight = !0;
    class qo extends Bo {
      constructor() {
        super(new gn(-5, 5, 5, -5, 0.5, 500));
      }
    }
    qo.prototype.isDirectionalLightShadow = !0;
    class Xo extends Do {
      constructor(e, t) {
        super(e, t),
          (this.type = "DirectionalLight"),
          this.position.copy(Ue.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ue()),
          (this.shadow = new qo());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    Xo.prototype.isDirectionalLight = !0;
    class Yo extends Do {
      constructor(e, t) {
        super(e, t), (this.type = "AmbientLight");
      }
    }
    Yo.prototype.isAmbientLight = !0;
    class Jo extends Do {
      constructor(e, t, n = 10, i = 10) {
        super(e, t),
          (this.type = "RectAreaLight"),
          (this.width = n),
          (this.height = i);
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
      }
      copy(e) {
        return (
          super.copy(e), (this.width = e.width), (this.height = e.height), this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.width = this.width), (t.object.height = this.height), t
        );
      }
    }
    Jo.prototype.isRectAreaLight = !0;
    class Zo {
      constructor() {
        this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new F());
      }
      set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
      }
      zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
      }
      getAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = this.coefficients;
        return (
          t.copy(s[0]).multiplyScalar(0.282095),
          t.addScaledVector(s[1], 0.488603 * i),
          t.addScaledVector(s[2], 0.488603 * r),
          t.addScaledVector(s[3], 0.488603 * n),
          t.addScaledVector(s[4], n * i * 1.092548),
          t.addScaledVector(s[5], i * r * 1.092548),
          t.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
          t.addScaledVector(s[7], n * r * 1.092548),
          t.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
          t
        );
      }
      getIrradianceAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z,
          s = this.coefficients;
        return (
          t.copy(s[0]).multiplyScalar(0.886227),
          t.addScaledVector(s[1], 1.023328 * i),
          t.addScaledVector(s[2], 1.023328 * r),
          t.addScaledVector(s[3], 1.023328 * n),
          t.addScaledVector(s[4], 0.858086 * n * i),
          t.addScaledVector(s[5], 0.858086 * i * r),
          t.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
          t.addScaledVector(s[7], 0.858086 * n * r),
          t.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
          t
        );
      }
      add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
      }
      addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this;
      }
      scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
      }
      lerp(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].lerp(e.coefficients[n], t);
        return this;
      }
      equals(e) {
        for (let t = 0; t < 9; t++)
          if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
      }
      copy(e) {
        return this.set(e.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(e, t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
        return e;
      }
      static getBasisAt(e, t) {
        const n = e.x,
          i = e.y,
          r = e.z;
        (t[0] = 0.282095),
          (t[1] = 0.488603 * i),
          (t[2] = 0.488603 * r),
          (t[3] = 0.488603 * n),
          (t[4] = 1.092548 * n * i),
          (t[5] = 1.092548 * i * r),
          (t[6] = 0.315392 * (3 * r * r - 1)),
          (t[7] = 1.092548 * n * r),
          (t[8] = 0.546274 * (n * n - i * i));
      }
    }
    Zo.prototype.isSphericalHarmonics3 = !0;
    class Ko extends Do {
      constructor(e = new Zo(), t = 1) {
        super(void 0, t), (this.sh = e);
      }
      copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
      }
      fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
      }
    }
    Ko.prototype.isLightProbe = !0;
    class Qo {
      static decodeText(e) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
          t += String.fromCharCode(e[n]);
        try {
          return decodeURIComponent(escape(t));
        } catch (e) {
          return t;
        }
      }
      static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1);
      }
      static resolveURL(e, t) {
        return "string" != typeof e || "" === e
          ? ""
          : (/^https?:\/\//i.test(t) &&
              /^\//.test(e) &&
              (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(e) ||
            /^data:.*,.*$/i.test(e) ||
            /^blob:.*$/i.test(e)
              ? e
              : t + e);
      }
    }
    class $o extends yt {
      constructor() {
        super(),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = super.toJSON(this);
        return (
          (e.instanceCount = this.instanceCount),
          (e.isInstancedBufferGeometry = !0),
          e
        );
      }
    }
    $o.prototype.isInstancedBufferGeometry = !0;
    class el extends Ao {
      constructor(e) {
        super(e),
          "undefined" == typeof createImageBitmap &&
            console.warn(
              "THREE.ImageBitmapLoader: createImageBitmap() not supported."
            ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          (this.options = { premultiplyAlpha: "none" });
      }
      setOptions(e) {
        return (this.options = e), this;
      }
      load(e, t, n, i) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          s = So.get(e);
        if (void 0 !== s)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(s), r.manager.itemEnd(e);
            }, 0),
            s
          );
        const a = {};
        (a.credentials =
          "anonymous" === this.crossOrigin ? "same-origin" : "include"),
          (a.headers = this.requestHeader),
          fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(
                e,
                Object.assign(r.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (n) {
              So.add(e, n), t && t(n), r.manager.itemEnd(e);
            })
            .catch(function (t) {
              i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
            }),
          r.manager.itemStart(e);
      }
    }
    let tl;
    el.prototype.isImageBitmapLoader = !0;
    const nl = function () {
      return (
        void 0 === tl &&
          (tl = new (window.AudioContext || window.webkitAudioContext)()),
        tl
      );
    };
    class il extends Ao {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const r = this,
          s = new Ro(this.manager);
        s.setResponseType("arraybuffer"),
          s.setPath(this.path),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(
            e,
            function (n) {
              try {
                const e = n.slice(0);
                nl().decodeAudioData(e, function (e) {
                  t(e);
                });
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      }
    }
    (class extends Ko {
      constructor(e, t, n = 1) {
        super(void 0, n);
        const i = new st().set(e),
          r = new st().set(t),
          s = new F(i.r, i.g, i.b),
          a = new F(r.r, r.g, r.b),
          o = Math.sqrt(Math.PI),
          l = o * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
          this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
      }
    }.prototype.isHemisphereLightProbe = !0);
    (class extends Ko {
      constructor(e, t = 1) {
        super(void 0, t);
        const n = new st().set(e);
        this.sh.coefficients[0]
          .set(n.r, n.g, n.b)
          .multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    }.prototype.isAmbientLightProbe = !0);
    class rl extends Ue {
      constructor(e) {
        super(),
          (this.type = "Audio"),
          (this.listener = e),
          (this.context = e.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(e.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.detune = 0),
          (this.loop = !1),
          (this.loopStart = 0),
          (this.loopEnd = 0),
          (this.offset = 0),
          (this.duration = void 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.source = null),
          (this.sourceType = "empty"),
          (this._startedAt = 0),
          (this._progress = 0),
          (this._connected = !1),
          (this.filters = []);
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "audioNode"),
          (this.source = e),
          this.connect(),
          this
        );
      }
      setMediaElementSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaNode"),
          (this.source = this.context.createMediaElementSource(e)),
          this.connect(),
          this
        );
      }
      setMediaStreamSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaStreamNode"),
          (this.source = this.context.createMediaStreamSource(e)),
          this.connect(),
          this
        );
      }
      setBuffer(e) {
        return (
          (this.buffer = e),
          (this.sourceType = "buffer"),
          this.autoplay && this.play(),
          this
        );
      }
      play(e = 0) {
        if (!0 === this.isPlaying)
          return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl)
          return void console.warn(
            "THREE.Audio: this Audio has no playback control."
          );
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return (
          (t.buffer = this.buffer),
          (t.loop = this.loop),
          (t.loopStart = this.loopStart),
          (t.loopEnd = this.loopEnd),
          (t.onended = this.onEnded.bind(this)),
          t.start(this._startedAt, this._progress + this.offset, this.duration),
          (this.isPlaying = !0),
          (this.source = t),
          this.setDetune(this.detune),
          this.setPlaybackRate(this.playbackRate),
          this.connect()
        );
      }
      pause() {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              !0 === this.loop &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      stop() {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let e = 1, t = this.filters.length; e < t; e++)
            this.filters[e - 1].connect(this.filters[e]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return (this._connected = !0), this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let e = 1, t = this.filters.length; e < t; e++)
            this.filters[e - 1].disconnect(this.filters[e]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return (this._connected = !1), this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(e) {
        return (
          e || (e = []),
          !0 === this._connected
            ? (this.disconnect(), (this.filters = e.slice()), this.connect())
            : (this.filters = e.slice()),
          this
        );
      }
      setDetune(e) {
        if (((this.detune = e), void 0 !== this.source.detune))
          return (
            !0 === this.isPlaying &&
              this.source.detune.setTargetAtTime(
                this.detune,
                this.context.currentTime,
                0.01
              ),
            this
          );
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(e) {
        return this.setFilters(e ? [e] : []);
      }
      setPlaybackRate(e) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = e),
            !0 === this.isPlaying &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = !1;
      }
      getLoop() {
        return !1 === this.hasPlaybackControl
          ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1)
          : this.loop;
      }
      setLoop(e) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = e),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      setLoopStart(e) {
        return (this.loopStart = e), this;
      }
      setLoopEnd(e) {
        return (this.loopEnd = e), this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(e) {
        return (
          this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
          this
        );
      }
    }
    class sl {
      constructor(e, t, n) {
        let i, r, s;
        switch (((this.binding = e), (this.valueSize = n), t)) {
          case "quaternion":
            (i = this._slerp),
              (r = this._slerpAdditive),
              (s = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (i = this._select),
              (r = this._select),
              (s = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (i = this._lerp),
              (r = this._lerpAdditive),
              (s = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = i),
          (this._mixBufferRegionAdditive = r),
          (this._setIdentity = s),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      accumulate(e, t) {
        const n = this.buffer,
          i = this.valueSize,
          r = e * i + i;
        let s = this.cumulativeWeight;
        if (0 === s) {
          for (let e = 0; e !== i; ++e) n[r + e] = n[e];
          s = t;
        } else {
          s += t;
          const e = t / s;
          this._mixBufferRegion(n, r, 0, e, i);
        }
        this.cumulativeWeight = s;
      }
      accumulateAdditive(e) {
        const t = this.buffer,
          n = this.valueSize,
          i = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(),
          this._mixBufferRegionAdditive(t, i, 0, e, n),
          (this.cumulativeWeightAdditive += e);
      }
      apply(e) {
        const t = this.valueSize,
          n = this.buffer,
          i = e * t + t,
          r = this.cumulativeWeight,
          s = this.cumulativeWeightAdditive,
          a = this.binding;
        if (
          ((this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          r < 1)
        ) {
          const e = t * this._origIndex;
          this._mixBufferRegion(n, i, e, 1 - r, t);
        }
        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let e = t, r = t + t; e !== r; ++e)
          if (n[e] !== n[e + t]) {
            a.setValue(n, i);
            break;
          }
      }
      saveOriginalState() {
        const e = this.binding,
          t = this.buffer,
          n = this.valueSize,
          i = n * this._origIndex;
        e.getValue(t, i);
        for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
        this._setIdentity(),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0);
      }
      restoreOriginalState() {
        const e = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e);
      }
      _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
          t = e + this.valueSize;
        for (let n = e; n < t; n++) this.buffer[n] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
          (this.buffer[this._addIndex * this.valueSize + 3] = 1);
      }
      _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
          t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
          this.buffer[t + n] = this.buffer[e + n];
      }
      _select(e, t, n, i, r) {
        if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
      }
      _slerp(e, t, n, i) {
        z.slerpFlat(e, t, e, t, e, n, i);
      }
      _slerpAdditive(e, t, n, i, r) {
        const s = this._workIndex * r;
        z.multiplyQuaternionsFlat(e, s, e, t, e, n),
          z.slerpFlat(e, t, e, t, e, s, i);
      }
      _lerp(e, t, n, i, r) {
        const s = 1 - i;
        for (let a = 0; a !== r; ++a) {
          const r = t + a;
          e[r] = e[r] * s + e[n + a] * i;
        }
      }
      _lerpAdditive(e, t, n, i, r) {
        for (let s = 0; s !== r; ++s) {
          const r = t + s;
          e[r] = e[r] + e[n + s] * i;
        }
      }
    }
    const al = new RegExp("[\\[\\]\\.:\\/]", "g"),
      ol = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      ll = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      cl = /(WCOD+)?/.source.replace("WCOD", ol),
      hl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      ul = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      dl = new RegExp("^" + ll + cl + hl + ul + "$"),
      pl = ["material", "materials", "bones"];
    class ml {
      constructor(e, t, n) {
        (this.path = t),
          (this.parsedPath = n || ml.parseTrackName(t)),
          (this.node = ml.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(e, t, n) {
        return e && e.isAnimationObjectGroup
          ? new ml.Composite(e, t, n)
          : new ml(e, t, n);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(al, "");
      }
      static parseTrackName(e) {
        const t = dl.exec(e);
        if (!t)
          throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
          const e = n.nodeName.substring(i + 1);
          -1 !== pl.indexOf(e) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + e
          );
        return n;
      }
      static findNode(e, t) {
        if (
          !t ||
          "" === t ||
          "." === t ||
          -1 === t ||
          t === e.name ||
          t === e.uuid
        )
          return e;
        if (e.skeleton) {
          const n = e.skeleton.getBoneByName(t);
          if (void 0 !== n) return n;
        }
        if (e.children) {
          const n = function (e) {
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                if (r.name === t || r.uuid === t) return r;
                const s = n(r.children);
                if (s) return s;
              }
              return null;
            },
            i = n(e.children);
          if (i) return i;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node;
        const t = this.parsedPath,
          n = t.objectName,
          i = t.propertyName;
        let r = t.propertyIndex;
        if (
          (e ||
            ((e = ml.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        )
          return void console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
        if (n) {
          let i = t.objectIndex;
          switch (n) {
            case "materials":
              if (!e.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!e.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              e = e.skeleton.bones;
              for (let t = 0; t < e.length; t++)
                if (e[t].name === i) {
                  i = t;
                  break;
                }
              break;
            default:
              if (void 0 === e[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              e = e[n];
          }
          if (void 0 !== i) {
            if (void 0 === e[i])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                e
              );
            e = e[i];
          }
        }
        const s = e[i];
        if (void 0 === s) {
          const n = t.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              i +
              " but it wasn't found.",
            e
          );
        }
        let a = this.Versioning.None;
        (this.targetObject = e),
          void 0 !== e.needsUpdate
            ? (a = this.Versioning.NeedsUpdate)
            : void 0 !== e.matrixWorldNeedsUpdate &&
              (a = this.Versioning.MatrixWorldNeedsUpdate);
        let o = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === i) {
            if (!e.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!e.geometry.isBufferGeometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                this
              );
            if (!e.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== e.morphTargetDictionary[r] &&
              (r = e.morphTargetDictionary[r]);
          }
          (o = this.BindingType.ArrayElement),
            (this.resolvedProperty = s),
            (this.propertyIndex = r);
        } else
          void 0 !== s.fromArray && void 0 !== s.toArray
            ? ((o = this.BindingType.HasFromToArray),
              (this.resolvedProperty = s))
            : Array.isArray(s)
            ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
            : (this.propertyName = i);
        (this.getValue = this.GetterByBindingType[o]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }
    (ml.Composite = class {
      constructor(e, t, n) {
        const i = n || ml.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
      }
      getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(e, t);
      }
      setValue(e, t) {
        const n = this._bindings;
        for (
          let i = this._targetGroup.nCachedObjects_, r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(e, t);
      }
      bind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].bind();
      }
      unbind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].unbind();
      }
    }),
      (ml.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
      (ml.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (ml.prototype.GetterByBindingType = [
        ml.prototype._getValue_direct,
        ml.prototype._getValue_array,
        ml.prototype._getValue_arrayElement,
        ml.prototype._getValue_toArray,
      ]),
      (ml.prototype.SetterByBindingTypeAndVersioning = [
        [
          ml.prototype._setValue_direct,
          ml.prototype._setValue_direct_setNeedsUpdate,
          ml.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          ml.prototype._setValue_array,
          ml.prototype._setValue_array_setNeedsUpdate,
          ml.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          ml.prototype._setValue_arrayElement,
          ml.prototype._setValue_arrayElement_setNeedsUpdate,
          ml.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          ml.prototype._setValue_fromArray,
          ml.prototype._setValue_fromArray_setNeedsUpdate,
          ml.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    (class {
      constructor() {
        (this.uuid = f()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        const e = {};
        this._indicesByUUID = e;
        for (let t = 0, n = arguments.length; t !== n; ++t)
          e[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        const t = this;
        this.stats = {
          objects: {
            get total() {
              return t._objects.length;
            },
            get inUse() {
              return this.total - t.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return t._bindings.length;
          },
        };
      }
      add() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._paths,
          i = this._parsedPaths,
          r = this._bindings,
          s = r.length;
        let a = void 0,
          o = e.length,
          l = this.nCachedObjects_;
        for (let c = 0, h = arguments.length; c !== h; ++c) {
          const h = arguments[c],
            u = h.uuid;
          let d = t[u];
          if (void 0 === d) {
            (d = o++), (t[u] = d), e.push(h);
            for (let e = 0, t = s; e !== t; ++e)
              r[e].push(new ml(h, n[e], i[e]));
          } else if (d < l) {
            a = e[d];
            const o = --l,
              c = e[o];
            (t[c.uuid] = d), (e[d] = c), (t[u] = o), (e[o] = h);
            for (let e = 0, t = s; e !== t; ++e) {
              const t = r[e],
                s = t[o];
              let a = t[d];
              (t[d] = s),
                void 0 === a && (a = new ml(h, n[e], i[e])),
                (t[o] = a);
            }
          } else
            e[d] !== a &&
              console.error(
                "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
              );
        }
        this.nCachedObjects_ = l;
      }
      remove() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
        let r = this.nCachedObjects_;
        for (let s = 0, a = arguments.length; s !== a; ++s) {
          const a = arguments[s],
            o = a.uuid,
            l = t[o];
          if (void 0 !== l && l >= r) {
            const s = r++,
              c = e[s];
            (t[c.uuid] = l), (e[l] = c), (t[o] = s), (e[s] = a);
            for (let e = 0, t = i; e !== t; ++e) {
              const t = n[e],
                i = t[s],
                r = t[l];
              (t[l] = i), (t[s] = r);
            }
          }
        }
        this.nCachedObjects_ = r;
      }
      uncache() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
        let r = this.nCachedObjects_,
          s = e.length;
        for (let a = 0, o = arguments.length; a !== o; ++a) {
          const o = arguments[a].uuid,
            l = t[o];
          if (void 0 !== l)
            if ((delete t[o], l < r)) {
              const a = --r,
                o = e[a],
                c = --s,
                h = e[c];
              (t[o.uuid] = l), (e[l] = o), (t[h.uuid] = a), (e[a] = h), e.pop();
              for (let e = 0, t = i; e !== t; ++e) {
                const t = n[e],
                  i = t[a],
                  r = t[c];
                (t[l] = i), (t[a] = r), t.pop();
              }
            } else {
              const r = --s,
                a = e[r];
              r > 0 && (t[a.uuid] = l), (e[l] = a), e.pop();
              for (let e = 0, t = i; e !== t; ++e) {
                const t = n[e];
                (t[l] = t[r]), t.pop();
              }
            }
        }
        this.nCachedObjects_ = r;
      }
      subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let i = n[e];
        const r = this._bindings;
        if (void 0 !== i) return r[i];
        const s = this._paths,
          a = this._parsedPaths,
          o = this._objects,
          l = o.length,
          c = this.nCachedObjects_,
          h = new Array(l);
        (i = r.length), (n[e] = i), s.push(e), a.push(t), r.push(h);
        for (let n = c, i = o.length; n !== i; ++n) {
          const i = o[n];
          h[n] = new ml(i, e, t);
        }
        return h;
      }
      unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
          n = t[e];
        if (void 0 !== n) {
          const i = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            a = s.length - 1,
            o = s[a];
          (t[e[a]] = n),
            (s[n] = o),
            s.pop(),
            (r[n] = r[a]),
            r.pop(),
            (i[n] = i[a]),
            i.pop();
        }
      }
    }.prototype.isAnimationObjectGroup = !0);
    class fl {
      constructor(e, t, n = null, i = t.blendMode) {
        (this._mixer = e),
          (this._clip = t),
          (this._localRoot = n),
          (this.blendMode = i);
        const r = t.tracks,
          s = r.length,
          a = new Array(s),
          o = { endingStart: 2400, endingEnd: 2400 };
        for (let e = 0; e !== s; ++e) {
          const t = r[e].createInterpolant(null);
          (a[e] = t), (t.settings = o);
        }
        (this._interpolantSettings = o),
          (this._interpolants = a),
          (this._propertyBindings = new Array(s)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = 2201),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      }
      isRunning() {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(e) {
        return (this._startTime = e), this;
      }
      setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
      }
      setEffectiveWeight(e) {
        return (
          (this.weight = e),
          (this._effectiveWeight = this.enabled ? e : 0),
          this.stopFading()
        );
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
      }
      fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
      }
      crossFadeFrom(e, t, n) {
        if ((e.fadeOut(t), this.fadeIn(t), n)) {
          const n = this._clip.duration,
            i = e._clip.duration,
            r = i / n,
            s = n / i;
          e.warp(1, r, t), this.warp(s, 1, t);
        }
        return this;
      }
      crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n);
      }
      stopFading() {
        const e = this._weightInterpolant;
        return (
          null !== e &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      setEffectiveTimeScale(e) {
        return (
          (this.timeScale = e),
          (this._effectiveTimeScale = this.paused ? 0 : e),
          this.stopWarping()
        );
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
      }
      syncWith(e) {
        return (
          (this.time = e.time),
          (this.timeScale = e.timeScale),
          this.stopWarping()
        );
      }
      halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
      }
      warp(e, t, n) {
        const i = this._mixer,
          r = i.time,
          s = this.timeScale;
        let a = this._timeScaleInterpolant;
        null === a &&
          ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        const o = a.parameterPositions,
          l = a.sampleValues;
        return (o[0] = r), (o[1] = r + n), (l[0] = e / s), (l[1] = t / s), this;
      }
      stopWarping() {
        const e = this._timeScaleInterpolant;
        return (
          null !== e &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(e, t, n, i) {
        if (!this.enabled) return void this._updateWeight(e);
        const r = this._startTime;
        if (null !== r) {
          const i = (e - r) * n;
          if (i < 0 || 0 === n) return;
          (this._startTime = null), (t = n * i);
        }
        t *= this._updateTimeScale(e);
        const s = this._updateTime(t),
          a = this._updateWeight(e);
        if (a > 0) {
          const e = this._interpolants,
            t = this._propertyBindings;
          switch (this.blendMode) {
            case 2501:
              for (let n = 0, i = e.length; n !== i; ++n)
                e[n].evaluate(s), t[n].accumulateAdditive(a);
              break;
            case 2500:
            default:
              for (let n = 0, r = e.length; n !== r; ++n)
                e[n].evaluate(s), t[n].accumulate(i, a);
          }
        }
      }
      _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
          t = this.weight;
          const n = this._weightInterpolant;
          if (null !== n) {
            const i = n.evaluate(e)[0];
            (t *= i),
              e > n.parameterPositions[1] &&
                (this.stopFading(), 0 === i && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = t), t;
      }
      _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
          t = this.timeScale;
          const n = this._timeScaleInterpolant;
          if (null !== n) {
            (t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === t ? (this.paused = !0) : (this.timeScale = t));
          }
        }
        return (this._effectiveTimeScale = t), t;
      }
      _updateTime(e) {
        const t = this._clip.duration,
          n = this.loop;
        let i = this.time + e,
          r = this._loopCount;
        const s = 2202 === n;
        if (0 === e) return -1 === r ? i : s && 1 == (1 & r) ? t - i : i;
        if (2200 === n) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          e: {
            if (i >= t) i = t;
            else {
              if (!(i < 0)) {
                this.time = i;
                break e;
              }
              i = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === r &&
              (e >= 0
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                : this._setEndings(0 === this.repetitions, !0, s)),
            i >= t || i < 0)
          ) {
            const n = Math.floor(i / t);
            (i -= t * n), (r += Math.abs(n));
            const a = this.repetitions - r;
            if (a <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (i = e > 0 ? t : 0),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e > 0 ? 1 : -1,
                });
            else {
              if (1 === a) {
                const t = e < 0;
                this._setEndings(t, !t, s);
              } else this._setEndings(!1, !1, s);
              (this._loopCount = r),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: n,
                });
            }
          } else this.time = i;
          if (s && 1 == (1 & r)) return t - i;
        }
        return i;
      }
      _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n
          ? ((i.endingStart = 2401), (i.endingEnd = 2401))
          : ((i.endingStart = e ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
            (i.endingEnd = t ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
      }
      _scheduleFading(e, t, n) {
        const i = this._mixer,
          r = i.time;
        let s = this._weightInterpolant;
        null === s &&
          ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
        const a = s.parameterPositions,
          o = s.sampleValues;
        return (a[0] = r), (o[0] = t), (a[1] = r + e), (o[1] = n), this;
      }
    }
    (class extends h {
      constructor(e) {
        super(),
          (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      _bindAction(e, t) {
        const n = e._localRoot || this._root,
          i = e._clip.tracks,
          r = i.length,
          s = e._propertyBindings,
          a = e._interpolants,
          o = n.uuid,
          l = this._bindingsByRootAndName;
        let c = l[o];
        void 0 === c && ((c = {}), (l[o] = c));
        for (let e = 0; e !== r; ++e) {
          const r = i[e],
            l = r.name;
          let h = c[l];
          if (void 0 !== h) s[e] = h;
          else {
            if (((h = s[e]), void 0 !== h)) {
              null === h._cacheIndex &&
                (++h.referenceCount, this._addInactiveBinding(h, o, l));
              continue;
            }
            const i = t && t._propertyBindings[e].binding.parsedPath;
            (h = new sl(ml.create(n, l, i), r.ValueTypeName, r.getValueSize())),
              ++h.referenceCount,
              this._addInactiveBinding(h, o, l),
              (s[e] = h);
          }
          a[e].resultBuffer = h.buffer;
        }
      }
      _activateAction(e) {
        if (!this._isActiveAction(e)) {
          if (null === e._cacheIndex) {
            const t = (e._localRoot || this._root).uuid,
              n = e._clip.uuid,
              i = this._actionsByClip[n];
            this._bindAction(e, i && i.knownActions[0]),
              this._addInactiveAction(e, n, t);
          }
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
          }
          this._lendAction(e);
        }
      }
      _deactivateAction(e) {
        if (this._isActiveAction(e)) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.useCount &&
              (n.restoreOriginalState(), this._takeBackBinding(n));
          }
          this._takeBackAction(e);
        }
      }
      _initMemoryManager() {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        const e = this;
        this.stats = {
          actions: {
            get total() {
              return e._actions.length;
            },
            get inUse() {
              return e._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return e._bindings.length;
            },
            get inUse() {
              return e._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return e._controlInterpolants.length;
            },
            get inUse() {
              return e._nActiveControlInterpolants;
            },
          },
        };
      }
      _isActiveAction(e) {
        const t = e._cacheIndex;
        return null !== t && t < this._nActiveActions;
      }
      _addInactiveAction(e, t, n) {
        const i = this._actions,
          r = this._actionsByClip;
        let s = r[t];
        if (void 0 === s)
          (s = { knownActions: [e], actionByRoot: {} }),
            (e._byClipCacheIndex = 0),
            (r[t] = s);
        else {
          const t = s.knownActions;
          (e._byClipCacheIndex = t.length), t.push(e);
        }
        (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[n] = e);
      }
      _removeInactiveAction(e) {
        const t = this._actions,
          n = t[t.length - 1],
          i = e._cacheIndex;
        (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
        const r = e._clip.uuid,
          s = this._actionsByClip,
          a = s[r],
          o = a.knownActions,
          l = o[o.length - 1],
          c = e._byClipCacheIndex;
        (l._byClipCacheIndex = c),
          (o[c] = l),
          o.pop(),
          (e._byClipCacheIndex = null);
        delete a.actionByRoot[(e._localRoot || this._root).uuid],
          0 === o.length && delete s[r],
          this._removeInactiveBindingsForAction(e);
      }
      _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == --n.referenceCount && this._removeInactiveBinding(n);
        }
      }
      _lendAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          i = this._nActiveActions++,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _takeBackAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          i = --this._nActiveActions,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName,
          r = this._bindings;
        let s = i[t];
        void 0 === s && ((s = {}), (i[t] = s)),
          (s[n] = e),
          (e._cacheIndex = r.length),
          r.push(e);
      }
      _removeInactiveBinding(e) {
        const t = this._bindings,
          n = e.binding,
          i = n.rootNode.uuid,
          r = n.path,
          s = this._bindingsByRootAndName,
          a = s[i],
          o = t[t.length - 1],
          l = e._cacheIndex;
        (o._cacheIndex = l),
          (t[l] = o),
          t.pop(),
          delete a[r],
          0 === Object.keys(a).length && delete s[i];
      }
      _lendBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          i = this._nActiveBindings++,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _takeBackBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          i = --this._nActiveBindings,
          r = t[i];
        (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
      }
      _lendControlInterpolant() {
        const e = this._controlInterpolants,
          t = this._nActiveControlInterpolants++;
        let n = e[t];
        return (
          void 0 === n &&
            ((n = new uo(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )),
            (n.__cacheIndex = t),
            (e[t] = n)),
          n
        );
      }
      _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
          n = e.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = t[i];
        (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
      }
      clipAction(e, t, n) {
        const i = t || this._root,
          r = i.uuid;
        let s = "string" == typeof e ? wo.findByName(i, e) : e;
        const a = null !== s ? s.uuid : e,
          o = this._actionsByClip[a];
        let l = null;
        if (
          (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o)
        ) {
          const e = o.actionByRoot[r];
          if (void 0 !== e && e.blendMode === n) return e;
          (l = o.knownActions[0]), null === s && (s = l._clip);
        }
        if (null === s) return null;
        const c = new fl(this, s, t, n);
        return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
      }
      existingAction(e, t) {
        const n = t || this._root,
          i = n.uuid,
          r = "string" == typeof e ? wo.findByName(n, e) : e,
          s = r ? r.uuid : e,
          a = this._actionsByClip[s];
        return (void 0 !== a && a.actionByRoot[i]) || null;
      }
      stopAllAction() {
        const e = this._actions;
        for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
        return this;
      }
      update(e) {
        e *= this.timeScale;
        const t = this._actions,
          n = this._nActiveActions,
          i = (this.time += e),
          r = Math.sign(e),
          s = (this._accuIndex ^= 1);
        for (let a = 0; a !== n; ++a) {
          t[a]._update(i, e, r, s);
        }
        const a = this._bindings,
          o = this._nActiveBindings;
        for (let e = 0; e !== o; ++e) a[e].apply(s);
        return this;
      }
      setTime(e) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++)
          this._actions[e].time = 0;
        return this.update(e);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(e) {
        const t = this._actions,
          n = e.uuid,
          i = this._actionsByClip,
          r = i[n];
        if (void 0 !== r) {
          const e = r.knownActions;
          for (let n = 0, i = e.length; n !== i; ++n) {
            const i = e[n];
            this._deactivateAction(i);
            const r = i._cacheIndex,
              s = t[t.length - 1];
            (i._cacheIndex = null),
              (i._byClipCacheIndex = null),
              (s._cacheIndex = r),
              (t[r] = s),
              t.pop(),
              this._removeInactiveBindingsForAction(i);
          }
          delete i[n];
        }
      }
      uncacheRoot(e) {
        const t = e.uuid,
          n = this._actionsByClip;
        for (const e in n) {
          const i = n[e].actionByRoot[t];
          void 0 !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
        const i = this._bindingsByRootAndName[t];
        if (void 0 !== i)
          for (const e in i) {
            const t = i[e];
            t.restoreOriginalState(), this._removeInactiveBinding(t);
          }
      }
      uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        null !== n &&
          (this._deactivateAction(n), this._removeInactiveAction(n));
      }
    }.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
    class gl {
      constructor(e) {
        "string" == typeof e &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (e = arguments[1])),
          (this.value = e);
      }
      clone() {
        return new gl(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }
    }
    (class extends Kr {
      constructor(e, t, n = 1) {
        super(e, t), (this.meshPerAttribute = n);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.isInstancedInterleavedBuffer = !0),
          (t.meshPerAttribute = this.meshPerAttribute),
          t
        );
      }
    }.prototype.isInstancedInterleavedBuffer = !0);
    (class {
      constructor(e, t, n, i, r) {
        (this.buffer = e),
          (this.type = t),
          (this.itemSize = n),
          (this.elementSize = i),
          (this.count = r),
          (this.version = 0);
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setBuffer(e) {
        return (this.buffer = e), this;
      }
      setType(e, t) {
        return (this.type = e), (this.elementSize = t), this;
      }
      setItemSize(e) {
        return (this.itemSize = e), this;
      }
      setCount(e) {
        return (this.count = e), this;
      }
    }.prototype.isGLBufferAttribute = !0);
    class vl {
      constructor(e = 1, t = 0, n = 0) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
      }
      set(e, t, n) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
      }
      copy(e) {
        return (
          (this.radius = e.radius),
          (this.phi = e.phi),
          (this.theta = e.theta),
          this
        );
      }
      makeSafe() {
        return (
          (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
        );
      }
      setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
      }
      setFromCartesianCoords(e, t, n) {
        return (
          (this.radius = Math.sqrt(e * e + t * t + n * n)),
          0 === this.radius
            ? ((this.theta = 0), (this.phi = 0))
            : ((this.theta = Math.atan2(e, n)),
              (this.phi = Math.acos(g(t / this.radius, -1, 1)))),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const _l = new M();
    class xl {
      constructor(e = new M(1 / 0, 1 / 0), t = new M(-1 / 0, -1 / 0)) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = _l.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y)
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y
        );
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return _l.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this;
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    xl.prototype.isBox2 = !0;
    const yl = new F(),
      bl = new F();
    const wl = new F(),
      Ml = new me(),
      Sl = new me();
    const Tl = new Float32Array(1);
    new Int32Array(Tl.buffer);
    (Qs.create = function (e, t) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (e.prototype = Object.create(Qs.prototype)),
        (e.prototype.constructor = e),
        (e.prototype.getPoint = t),
        e
      );
    }),
      (xa.prototype.fromPoints = function (e) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(e)
        );
      }),
      (class extends Gs {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
          (n = new st(n)), (i = new st(i));
          const r = t / 2,
            s = e / t,
            a = e / 2,
            o = [],
            l = [];
          for (let e = 0, c = 0, h = -a; e <= t; e++, h += s) {
            o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
            const t = e === r ? n : i;
            t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3),
              t.toArray(l, c),
              (c += 3);
          }
          const c = new yt();
          c.setAttribute("position", new dt(o, 3)),
            c.setAttribute("color", new dt(l, 3));
          super(c, new Ds({ vertexColors: !0, toneMapped: !1 })),
            (this.type = "GridHelper");
        }
      }.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (class extends Gs {
        constructor(e) {
          const t = (function e(t) {
              const n = [];
              t && t.isBone && n.push(t);
              for (let i = 0; i < t.children.length; i++)
                n.push.apply(n, e(t.children[i]));
              return n;
            })(e),
            n = new yt(),
            i = [],
            r = [],
            s = new st(0, 0, 1),
            a = new st(0, 1, 0);
          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            n.parent &&
              n.parent.isBone &&
              (i.push(0, 0, 0),
              i.push(0, 0, 0),
              r.push(s.r, s.g, s.b),
              r.push(a.r, a.g, a.b));
          }
          n.setAttribute("position", new dt(i, 3)),
            n.setAttribute("color", new dt(r, 3));
          super(
            n,
            new Ds({
              vertexColors: !0,
              depthTest: !1,
              depthWrite: !1,
              toneMapped: !1,
              transparent: !0,
            })
          ),
            (this.type = "SkeletonHelper"),
            (this.isSkeletonHelper = !0),
            (this.root = e),
            (this.bones = t),
            (this.matrix = e.matrixWorld),
            (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
          const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
          Sl.copy(this.root.matrixWorld).invert();
          for (let e = 0, n = 0; e < t.length; e++) {
            const r = t[e];
            r.parent &&
              r.parent.isBone &&
              (Ml.multiplyMatrices(Sl, r.matrixWorld),
              wl.setFromMatrixPosition(Ml),
              i.setXYZ(n, wl.x, wl.y, wl.z),
              Ml.multiplyMatrices(Sl, r.parent.matrixWorld),
              wl.setFromMatrixPosition(Ml),
              i.setXYZ(n + 1, wl.x, wl.y, wl.z),
              (n += 2));
          }
          (n.getAttribute("position").needsUpdate = !0),
            super.updateMatrixWorld(e);
        }
      }.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      (Ao.prototype.extractUrlBase = function (e) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Qo.extractUrlBase(e)
        );
      }),
      (Ao.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      (xl.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (xl.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (xl.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (xl.prototype.size = function (e) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (H.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (H.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (H.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (H.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (H.prototype.size = function (e) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (se.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      }),
      (nn.prototype.setFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(e)
        );
      }),
      (class {
        constructor(e = new F(), t = new F()) {
          (this.start = e), (this.end = t);
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return e.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(e) {
          return e.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
          yl.subVectors(e, this.start), bl.subVectors(this.end, this.start);
          const n = bl.dot(bl);
          let i = bl.dot(yl) / n;
          return t && (i = g(i, 0, 1)), i;
        }
        closestPointToPoint(e, t, n) {
          const i = this.closestPointToPointParameter(e, t);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (S.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (S.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (S.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      }),
      (S.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (S.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      }),
      (S.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      (me.prototype.extractPosition = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(e)
        );
      }),
      (me.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (me.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new F().setFromMatrixColumn(this, 3)
        );
      }),
      (me.prototype.setRotationFromQuaternion = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(e)
        );
      }),
      (me.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }),
      (me.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (me.prototype.multiplyVector4 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (me.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      }),
      (me.prototype.rotateAxis = function (e) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          e.transformDirection(this);
      }),
      (me.prototype.crossVector = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (me.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }),
      (me.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }),
      (me.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }),
      (me.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }),
      (me.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }),
      (me.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (me.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      }),
      (me.prototype.makeFrustum = function (e, t, n, i, r, s) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(e, t, i, n, r, s)
        );
      }),
      (me.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      ($t.prototype.isIntersectionLine = function (e) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(e)
        );
      }),
      (z.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          e.applyQuaternion(this)
        );
      }),
      (z.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      }),
      (pe.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (pe.prototype.isIntersectionPlane = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(e)
        );
      }),
      (pe.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (Ze.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      }),
      (Ze.prototype.barycoordFromPoint = function (e, t) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(e, t)
        );
      }),
      (Ze.prototype.midpoint = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(e)
        );
      }),
      (Ze.prototypenormal = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(e)
        );
      }),
      (Ze.prototype.plane = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(e)
        );
      }),
      (Ze.barycoordFromPoint = function (e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          Ze.getBarycoord(e, t, n, i, r)
        );
      }),
      (Ze.normal = function (e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          Ze.getNormal(e, t, n, i)
        );
      }),
      (ya.prototype.extractAllPoints = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(e)
        );
      }),
      (ya.prototype.extrude = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Ja(this, e)
        );
      }),
      (ya.prototype.makeGeometry = function (e) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Ka(this, e)
        );
      }),
      (M.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (M.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (M.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (F.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      }),
      (F.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      }),
      (F.prototype.getPositionFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(e)
        );
      }),
      (F.prototype.getScaleFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(e)
        );
      }),
      (F.prototype.getColumnFromMatrix = function (e, t) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(t, e)
        );
      }),
      (F.prototype.applyProjection = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(e)
        );
      }),
      (F.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (F.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (F.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (D.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (D.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (Ue.prototype.getChildByName = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(e)
        );
      }),
      (Ue.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      }),
      (Ue.prototype.translate = function (e, t) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(t, e)
        );
      }),
      (Ue.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      }),
      (Ue.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(Ue.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (e) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = e);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      (Bt.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      }),
      Object.defineProperties(Bt.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              0
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      }),
      (bs.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      (qt.prototype.setLens = function (e, t) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== t && (this.filmGauge = t),
          this.setFocalLength(e);
      }),
      Object.defineProperties(Do.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = e);
          },
        },
        shadowCameraLeft: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = e);
          },
        },
        shadowCameraRight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = e);
          },
        },
        shadowCameraTop: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = e);
          },
        },
        shadowCameraBottom: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = e);
          },
        },
        shadowCameraNear: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = e);
          },
        },
        shadowCameraFar: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = e);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (e) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = e);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = e);
          },
        },
        shadowMapHeight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = e);
          },
        },
      }),
      Object.defineProperties(ct.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              35048 === this.usage
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(35048);
          },
        },
      }),
      (ct.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? 35048 : 35044),
          this
        );
      }),
      (ct.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
      (ct.prototype.setArray = function () {
        console.error(
          "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (yt.prototype.addIndex = function (e) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(e);
      }),
      (yt.prototype.addAttribute = function (e, t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
            ? "index" === e
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(t),
                this)
              : this.setAttribute(e, t)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(e, new ct(arguments[1], arguments[2])))
        );
      }),
      (yt.prototype.addDrawCall = function (e, t, n) {
        void 0 !== n &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(e, t);
      }),
      (yt.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      }),
      (yt.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      }),
      (yt.prototype.removeAttribute = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(e)
        );
      }),
      (yt.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(yt.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      (Kr.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? 35048 : 35044),
          this
        );
      }),
      (Kr.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (Ja.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }),
      (Ja.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      }),
      (Ja.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }),
      (Zr.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      }),
      (gl.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      }),
      Object.defineProperties(Qe.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new st()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === e);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = e);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      }),
      Object.defineProperties(Wt.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (e) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = e);
          },
        },
      }),
      (Xr.prototype.clearTarget = function (e, t, n, i) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(e),
          this.clear(t, n, i);
      }),
      (Xr.prototype.animate = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(e);
      }),
      (Xr.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      }),
      (Xr.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      }),
      (Xr.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      }),
      (Xr.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      }),
      (Xr.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      }),
      (Xr.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      }),
      (Xr.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      }),
      (Xr.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      }),
      (Xr.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      }),
      (Xr.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      }),
      (Xr.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      }),
      (Xr.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      }),
      (Xr.prototype.enableScissorTest = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(e);
      }),
      (Xr.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }),
      (Xr.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }),
      (Xr.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }),
      (Xr.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      }),
      (Xr.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      }),
      (Xr.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      }),
      (Xr.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }),
      (Xr.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }),
      (Xr.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      }),
      (Xr.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      }),
      Object.defineProperties(Xr.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = e);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = e);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === e ? 3001 : 3e3);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      }),
      Object.defineProperties(zr.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties(N.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = e);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = e);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = e);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = e);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = e);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = e);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = e);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = e);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = e);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = e);
          },
        },
      }),
      (rl.prototype.load = function (e) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const t = this;
        return (
          new il().load(e, function (e) {
            t.setBuffer(e);
          }),
          this
        );
      }),
      (class {
        constructor(e, t = 2048) {
          (this.analyser = e.context.createAnalyser()),
            (this.analyser.fftSize = t),
            (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
            e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let e = 0;
          const t = this.getFrequencyData();
          for (let n = 0; n < t.length; n++) e += t[n];
          return e / t.length;
        }
      }.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (Xt.prototype.updateCubeMap = function (e, t) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(e, t)
        );
      }),
      (Xt.prototype.clear = function (e, t, n, i) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(e, t, n, i)
        );
      }),
      (R.crossOrigin = void 0),
      (R.loadTexture = function (e, t, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const r = new Io();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s;
      }),
      (R.loadTextureCube = function (e, t, n, i) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const r = new Po();
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(e, n, void 0, i);
        return t && (s.mapping = t), s;
      }),
      (R.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (R.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: "135" } })
      ),
      "undefined" != typeof window &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = "135"));
    const El = { type: "change" },
      Al = { type: "start" },
      Ll = { type: "end" };
    class Rl extends h {
      constructor(e, t) {
        super(),
          void 0 === t &&
            console.warn(
              'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
            ),
          t === document &&
            console.error(
              'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
            ),
          (this.object = e),
          (this.domElement = t),
          (this.domElement.style.touchAction = "none"),
          (this.enabled = !0),
          (this.target = new F()),
          (this.minDistance = 0),
          (this.maxDistance = 1 / 0),
          (this.minZoom = 0),
          (this.maxZoom = 1 / 0),
          (this.minPolarAngle = 0),
          (this.maxPolarAngle = Math.PI),
          (this.minAzimuthAngle = -1 / 0),
          (this.maxAzimuthAngle = 1 / 0),
          (this.enableDamping = !1),
          (this.dampingFactor = 0.05),
          (this.enableZoom = !0),
          (this.zoomSpeed = 1),
          (this.enableRotate = !0),
          (this.rotateSpeed = 1),
          (this.enablePan = !0),
          (this.panSpeed = 1),
          (this.screenSpacePanning = !0),
          (this.keyPanSpeed = 7),
          (this.autoRotate = !1),
          (this.autoRotateSpeed = 2),
          (this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown",
          }),
          (this.mouseButtons = { LEFT: i, MIDDLE: r, RIGHT: s }),
          (this.touches = { ONE: a, TWO: l }),
          (this.target0 = this.target.clone()),
          (this.position0 = this.object.position.clone()),
          (this.zoom0 = this.object.zoom),
          (this._domElementKeyEvents = null),
          (this.getPolarAngle = function () {
            return p.phi;
          }),
          (this.getAzimuthalAngle = function () {
            return p.theta;
          }),
          (this.getDistance = function () {
            return this.object.position.distanceTo(this.target);
          }),
          (this.listenToKeyEvents = function (e) {
            e.addEventListener("keydown", $), (this._domElementKeyEvents = e);
          }),
          (this.saveState = function () {
            n.target0.copy(n.target),
              n.position0.copy(n.object.position),
              (n.zoom0 = n.object.zoom);
          }),
          (this.reset = function () {
            n.target.copy(n.target0),
              n.object.position.copy(n.position0),
              (n.object.zoom = n.zoom0),
              n.object.updateProjectionMatrix(),
              n.dispatchEvent(El),
              n.update(),
              (u = h.NONE);
          }),
          (this.update = (function () {
            const t = new F(),
              i = new z().setFromUnitVectors(e.up, new F(0, 1, 0)),
              r = i.clone().invert(),
              s = new F(),
              a = new z(),
              o = 2 * Math.PI;
            return function () {
              const e = n.object.position;
              t.copy(e).sub(n.target),
                t.applyQuaternion(i),
                p.setFromVector3(t),
                n.autoRotate &&
                  u === h.NONE &&
                  P(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed),
                n.enableDamping
                  ? ((p.theta += m.theta * n.dampingFactor),
                    (p.phi += m.phi * n.dampingFactor))
                  : ((p.theta += m.theta), (p.phi += m.phi));
              let l = n.minAzimuthAngle,
                c = n.maxAzimuthAngle;
              return (
                isFinite(l) &&
                  isFinite(c) &&
                  (l < -Math.PI ? (l += o) : l > Math.PI && (l -= o),
                  c < -Math.PI ? (c += o) : c > Math.PI && (c -= o),
                  (p.theta =
                    l <= c
                      ? Math.max(l, Math.min(c, p.theta))
                      : p.theta > (l + c) / 2
                      ? Math.max(l, p.theta)
                      : Math.min(c, p.theta))),
                (p.phi = Math.max(
                  n.minPolarAngle,
                  Math.min(n.maxPolarAngle, p.phi)
                )),
                p.makeSafe(),
                (p.radius *= f),
                (p.radius = Math.max(
                  n.minDistance,
                  Math.min(n.maxDistance, p.radius)
                )),
                !0 === n.enableDamping
                  ? n.target.addScaledVector(g, n.dampingFactor)
                  : n.target.add(g),
                t.setFromSpherical(p),
                t.applyQuaternion(r),
                e.copy(n.target).add(t),
                n.object.lookAt(n.target),
                !0 === n.enableDamping
                  ? ((m.theta *= 1 - n.dampingFactor),
                    (m.phi *= 1 - n.dampingFactor),
                    g.multiplyScalar(1 - n.dampingFactor))
                  : (m.set(0, 0, 0), g.set(0, 0, 0)),
                (f = 1),
                !!(
                  v ||
                  s.distanceToSquared(n.object.position) > d ||
                  8 * (1 - a.dot(n.object.quaternion)) > d
                ) &&
                  (n.dispatchEvent(El),
                  s.copy(n.object.position),
                  a.copy(n.object.quaternion),
                  (v = !1),
                  !0)
              );
            };
          })()),
          (this.dispose = function () {
            n.domElement.removeEventListener("contextmenu", ee),
              n.domElement.removeEventListener("pointerdown", Y),
              n.domElement.removeEventListener("pointercancel", K),
              n.domElement.removeEventListener("wheel", Q),
              n.domElement.removeEventListener("pointermove", J),
              n.domElement.removeEventListener("pointerup", Z),
              null !== n._domElementKeyEvents &&
                n._domElementKeyEvents.removeEventListener("keydown", $);
          });
        const n = this,
          h = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6,
          };
        let u = h.NONE;
        const d = 1e-6,
          p = new vl(),
          m = new vl();
        let f = 1;
        const g = new F();
        let v = !1;
        const _ = new M(),
          x = new M(),
          y = new M(),
          b = new M(),
          w = new M(),
          S = new M(),
          T = new M(),
          E = new M(),
          A = new M(),
          L = [],
          R = {};
        function C() {
          return Math.pow(0.95, n.zoomSpeed);
        }
        function P(e) {
          m.theta -= e;
        }
        function I(e) {
          m.phi -= e;
        }
        const D = (function () {
            const e = new F();
            return function (t, n) {
              e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), g.add(e);
            };
          })(),
          N = (function () {
            const e = new F();
            return function (t, i) {
              !0 === n.screenSpacePanning
                ? e.setFromMatrixColumn(i, 1)
                : (e.setFromMatrixColumn(i, 0), e.crossVectors(n.object.up, e)),
                e.multiplyScalar(t),
                g.add(e);
            };
          })(),
          O = (function () {
            const e = new F();
            return function (t, i) {
              const r = n.domElement;
              if (n.object.isPerspectiveCamera) {
                const s = n.object.position;
                e.copy(s).sub(n.target);
                let a = e.length();
                (a *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
                  D((2 * t * a) / r.clientHeight, n.object.matrix),
                  N((2 * i * a) / r.clientHeight, n.object.matrix);
              } else
                n.object.isOrthographicCamera
                  ? (D(
                      (t * (n.object.right - n.object.left)) /
                        n.object.zoom /
                        r.clientWidth,
                      n.object.matrix
                    ),
                    N(
                      (i * (n.object.top - n.object.bottom)) /
                        n.object.zoom /
                        r.clientHeight,
                      n.object.matrix
                    ))
                  : (console.warn(
                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                    ),
                    (n.enablePan = !1));
            };
          })();
        function B(e) {
          n.object.isPerspectiveCamera
            ? (f /= e)
            : n.object.isOrthographicCamera
            ? ((n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom * e)
              )),
              n.object.updateProjectionMatrix(),
              (v = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (n.enableZoom = !1));
        }
        function U(e) {
          n.object.isPerspectiveCamera
            ? (f *= e)
            : n.object.isOrthographicCamera
            ? ((n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom / e)
              )),
              n.object.updateProjectionMatrix(),
              (v = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (n.enableZoom = !1));
        }
        function H(e) {
          _.set(e.clientX, e.clientY);
        }
        function k(e) {
          b.set(e.clientX, e.clientY);
        }
        function G() {
          if (1 === L.length) _.set(L[0].pageX, L[0].pageY);
          else {
            const e = 0.5 * (L[0].pageX + L[1].pageX),
              t = 0.5 * (L[0].pageY + L[1].pageY);
            _.set(e, t);
          }
        }
        function V() {
          if (1 === L.length) b.set(L[0].pageX, L[0].pageY);
          else {
            const e = 0.5 * (L[0].pageX + L[1].pageX),
              t = 0.5 * (L[0].pageY + L[1].pageY);
            b.set(e, t);
          }
        }
        function W() {
          const e = L[0].pageX - L[1].pageX,
            t = L[0].pageY - L[1].pageY,
            n = Math.sqrt(e * e + t * t);
          T.set(0, n);
        }
        function j(e) {
          if (1 == L.length) x.set(e.pageX, e.pageY);
          else {
            const t = ie(e),
              n = 0.5 * (e.pageX + t.x),
              i = 0.5 * (e.pageY + t.y);
            x.set(n, i);
          }
          y.subVectors(x, _).multiplyScalar(n.rotateSpeed);
          const t = n.domElement;
          P((2 * Math.PI * y.x) / t.clientHeight),
            I((2 * Math.PI * y.y) / t.clientHeight),
            _.copy(x);
        }
        function q(e) {
          if (1 === L.length) w.set(e.pageX, e.pageY);
          else {
            const t = ie(e),
              n = 0.5 * (e.pageX + t.x),
              i = 0.5 * (e.pageY + t.y);
            w.set(n, i);
          }
          S.subVectors(w, b).multiplyScalar(n.panSpeed), O(S.x, S.y), b.copy(w);
        }
        function X(e) {
          const t = ie(e),
            i = e.pageX - t.x,
            r = e.pageY - t.y,
            s = Math.sqrt(i * i + r * r);
          E.set(0, s),
            A.set(0, Math.pow(E.y / T.y, n.zoomSpeed)),
            B(A.y),
            T.copy(E);
        }
        function Y(e) {
          !1 !== n.enabled &&
            (0 === L.length &&
              (n.domElement.setPointerCapture(e.pointerId),
              n.domElement.addEventListener("pointermove", J),
              n.domElement.addEventListener("pointerup", Z)),
            (function (e) {
              L.push(e);
            })(e),
            "touch" === e.pointerType
              ? (function (e) {
                  switch ((ne(e), L.length)) {
                    case 1:
                      switch (n.touches.ONE) {
                        case a:
                          if (!1 === n.enableRotate) return;
                          G(), (u = h.TOUCH_ROTATE);
                          break;
                        case o:
                          if (!1 === n.enablePan) return;
                          V(), (u = h.TOUCH_PAN);
                          break;
                        default:
                          u = h.NONE;
                      }
                      break;
                    case 2:
                      switch (n.touches.TWO) {
                        case l:
                          if (!1 === n.enableZoom && !1 === n.enablePan) return;
                          n.enableZoom && W(),
                            n.enablePan && V(),
                            (u = h.TOUCH_DOLLY_PAN);
                          break;
                        case c:
                          if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                          n.enableZoom && W(),
                            n.enableRotate && G(),
                            (u = h.TOUCH_DOLLY_ROTATE);
                          break;
                        default:
                          u = h.NONE;
                      }
                      break;
                    default:
                      u = h.NONE;
                  }
                  u !== h.NONE && n.dispatchEvent(Al);
                })(e)
              : (function (e) {
                  let t;
                  switch (e.button) {
                    case 0:
                      t = n.mouseButtons.LEFT;
                      break;
                    case 1:
                      t = n.mouseButtons.MIDDLE;
                      break;
                    case 2:
                      t = n.mouseButtons.RIGHT;
                      break;
                    default:
                      t = -1;
                  }
                  switch (t) {
                    case r:
                      if (!1 === n.enableZoom) return;
                      !(function (e) {
                        T.set(e.clientX, e.clientY);
                      })(e),
                        (u = h.DOLLY);
                      break;
                    case i:
                      if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enablePan) return;
                        k(e), (u = h.PAN);
                      } else {
                        if (!1 === n.enableRotate) return;
                        H(e), (u = h.ROTATE);
                      }
                      break;
                    case s:
                      if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enableRotate) return;
                        H(e), (u = h.ROTATE);
                      } else {
                        if (!1 === n.enablePan) return;
                        k(e), (u = h.PAN);
                      }
                      break;
                    default:
                      u = h.NONE;
                  }
                  u !== h.NONE && n.dispatchEvent(Al);
                })(e));
        }
        function J(e) {
          !1 !== n.enabled &&
            ("touch" === e.pointerType
              ? (function (e) {
                  switch ((ne(e), u)) {
                    case h.TOUCH_ROTATE:
                      if (!1 === n.enableRotate) return;
                      j(e), n.update();
                      break;
                    case h.TOUCH_PAN:
                      if (!1 === n.enablePan) return;
                      q(e), n.update();
                      break;
                    case h.TOUCH_DOLLY_PAN:
                      if (!1 === n.enableZoom && !1 === n.enablePan) return;
                      !(function (e) {
                        n.enableZoom && X(e), n.enablePan && q(e);
                      })(e),
                        n.update();
                      break;
                    case h.TOUCH_DOLLY_ROTATE:
                      if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                      !(function (e) {
                        n.enableZoom && X(e), n.enableRotate && j(e);
                      })(e),
                        n.update();
                      break;
                    default:
                      u = h.NONE;
                  }
                })(e)
              : (function (e) {
                  if (!1 === n.enabled) return;
                  switch (u) {
                    case h.ROTATE:
                      if (!1 === n.enableRotate) return;
                      !(function (e) {
                        x.set(e.clientX, e.clientY),
                          y.subVectors(x, _).multiplyScalar(n.rotateSpeed);
                        const t = n.domElement;
                        P((2 * Math.PI * y.x) / t.clientHeight),
                          I((2 * Math.PI * y.y) / t.clientHeight),
                          _.copy(x),
                          n.update();
                      })(e);
                      break;
                    case h.DOLLY:
                      if (!1 === n.enableZoom) return;
                      !(function (e) {
                        E.set(e.clientX, e.clientY),
                          A.subVectors(E, T),
                          A.y > 0 ? B(C()) : A.y < 0 && U(C()),
                          T.copy(E),
                          n.update();
                      })(e);
                      break;
                    case h.PAN:
                      if (!1 === n.enablePan) return;
                      !(function (e) {
                        w.set(e.clientX, e.clientY),
                          S.subVectors(w, b).multiplyScalar(n.panSpeed),
                          O(S.x, S.y),
                          b.copy(w),
                          n.update();
                      })(e);
                  }
                })(e));
        }
        function Z(e) {
          te(e),
            0 === L.length &&
              (n.domElement.releasePointerCapture(e.pointerId),
              n.domElement.removeEventListener("pointermove", J),
              n.domElement.removeEventListener("pointerup", Z)),
            n.dispatchEvent(Ll),
            (u = h.NONE);
        }
        function K(e) {
          te(e);
        }
        function Q(e) {
          !1 !== n.enabled &&
            !1 !== n.enableZoom &&
            u === h.NONE &&
            (e.preventDefault(),
            n.dispatchEvent(Al),
            (function (e) {
              e.deltaY < 0 ? U(C()) : e.deltaY > 0 && B(C()), n.update();
            })(e),
            n.dispatchEvent(Ll));
        }
        function $(e) {
          !1 !== n.enabled &&
            !1 !== n.enablePan &&
            (function (e) {
              let t = !1;
              switch (e.code) {
                case n.keys.UP:
                  O(0, n.keyPanSpeed), (t = !0);
                  break;
                case n.keys.BOTTOM:
                  O(0, -n.keyPanSpeed), (t = !0);
                  break;
                case n.keys.LEFT:
                  O(n.keyPanSpeed, 0), (t = !0);
                  break;
                case n.keys.RIGHT:
                  O(-n.keyPanSpeed, 0), (t = !0);
              }
              t && (e.preventDefault(), n.update());
            })(e);
        }
        function ee(e) {
          !1 !== n.enabled && e.preventDefault();
        }
        function te(e) {
          delete R[e.pointerId];
          for (let t = 0; t < L.length; t++)
            if (L[t].pointerId == e.pointerId) return void L.splice(t, 1);
        }
        function ne(e) {
          let t = R[e.pointerId];
          void 0 === t && ((t = new M()), (R[e.pointerId] = t)),
            t.set(e.pageX, e.pageY);
        }
        function ie(e) {
          const t = e.pointerId === L[0].pointerId ? L[1] : L[0];
          return R[t.pointerId];
        }
        n.domElement.addEventListener("contextmenu", ee),
          n.domElement.addEventListener("pointerdown", Y),
          n.domElement.addEventListener("pointercancel", K),
          n.domElement.addEventListener("wheel", Q, { passive: !1 }),
          this.update();
      }
    }
    function Cl(e, t) {
      var n = e.__state.conversionName.toString(),
        i = Math.round(e.r),
        r = Math.round(e.g),
        s = Math.round(e.b),
        a = e.a,
        o = Math.round(e.h),
        l = e.s.toFixed(1),
        c = e.v.toFixed(1);
      if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
        for (var h = e.hex.toString(16); h.length < 6; ) h = "0" + h;
        return "#" + h;
      }
      return "CSS_RGB" === n
        ? "rgb(" + i + "," + r + "," + s + ")"
        : "CSS_RGBA" === n
        ? "rgba(" + i + "," + r + "," + s + "," + a + ")"
        : "HEX" === n
        ? "0x" + e.hex.toString(16)
        : "RGB_ARRAY" === n
        ? "[" + i + "," + r + "," + s + "]"
        : "RGBA_ARRAY" === n
        ? "[" + i + "," + r + "," + s + "," + a + "]"
        : "RGB_OBJ" === n
        ? "{r:" + i + ",g:" + r + ",b:" + s + "}"
        : "RGBA_OBJ" === n
        ? "{r:" + i + ",g:" + r + ",b:" + s + ",a:" + a + "}"
        : "HSV_OBJ" === n
        ? "{h:" + o + ",s:" + l + ",v:" + c + "}"
        : "HSVA_OBJ" === n
        ? "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + a + "}"
        : "unknown format";
    }
    var Pl = Array.prototype.forEach,
      Il = Array.prototype.slice,
      Dl = {
        BREAK: {},
        extend: function (e) {
          return (
            this.each(
              Il.call(arguments, 1),
              function (t) {
                (this.isObject(t) ? Object.keys(t) : []).forEach(
                  function (n) {
                    this.isUndefined(t[n]) || (e[n] = t[n]);
                  }.bind(this)
                );
              },
              this
            ),
            e
          );
        },
        defaults: function (e) {
          return (
            this.each(
              Il.call(arguments, 1),
              function (t) {
                (this.isObject(t) ? Object.keys(t) : []).forEach(
                  function (n) {
                    this.isUndefined(e[n]) && (e[n] = t[n]);
                  }.bind(this)
                );
              },
              this
            ),
            e
          );
        },
        compose: function () {
          var e = Il.call(arguments);
          return function () {
            for (var t = Il.call(arguments), n = e.length - 1; n >= 0; n--)
              t = [e[n].apply(this, t)];
            return t[0];
          };
        },
        each: function (e, t, n) {
          if (e)
            if (Pl && e.forEach && e.forEach === Pl) e.forEach(t, n);
            else if (e.length === e.length + 0) {
              var i,
                r = void 0;
              for (r = 0, i = e.length; r < i; r++)
                if (r in e && t.call(n, e[r], r) === this.BREAK) return;
            } else
              for (var s in e) if (t.call(n, e[s], s) === this.BREAK) return;
        },
        defer: function (e) {
          setTimeout(e, 0);
        },
        debounce: function (e, t, n) {
          var i = void 0;
          return function () {
            var r = this,
              s = arguments;
            function a() {
              (i = null), n || e.apply(r, s);
            }
            var o = n || !i;
            clearTimeout(i), (i = setTimeout(a, t)), o && e.apply(r, s);
          };
        },
        toArray: function (e) {
          return e.toArray ? e.toArray() : Il.call(e);
        },
        isUndefined: function (e) {
          return void 0 === e;
        },
        isNull: function (e) {
          return null === e;
        },
        isNaN: (function (e) {
          function t(t) {
            return e.apply(this, arguments);
          }
          return (
            (t.toString = function () {
              return e.toString();
            }),
            t
          );
        })(function (e) {
          return isNaN(e);
        }),
        isArray:
          Array.isArray ||
          function (e) {
            return e.constructor === Array;
          },
        isObject: function (e) {
          return e === Object(e);
        },
        isNumber: function (e) {
          return e === e + 0;
        },
        isString: function (e) {
          return e === e + "";
        },
        isBoolean: function (e) {
          return !1 === e || !0 === e;
        },
        isFunction: function (e) {
          return e instanceof Function;
        },
      },
      Nl = [
        {
          litmus: Dl.isString,
          conversions: {
            THREE_CHAR_HEX: {
              read: function (e) {
                var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                return (
                  null !== t && {
                    space: "HEX",
                    hex: parseInt(
                      "0x" +
                        t[1].toString() +
                        t[1].toString() +
                        t[2].toString() +
                        t[2].toString() +
                        t[3].toString() +
                        t[3].toString(),
                      0
                    ),
                  }
                );
              },
              write: Cl,
            },
            SIX_CHAR_HEX: {
              read: function (e) {
                var t = e.match(/^#([A-F0-9]{6})$/i);
                return (
                  null !== t && {
                    space: "HEX",
                    hex: parseInt("0x" + t[1].toString(), 0),
                  }
                );
              },
              write: Cl,
            },
            CSS_RGB: {
              read: function (e) {
                var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                return (
                  null !== t && {
                    space: "RGB",
                    r: parseFloat(t[1]),
                    g: parseFloat(t[2]),
                    b: parseFloat(t[3]),
                  }
                );
              },
              write: Cl,
            },
            CSS_RGBA: {
              read: function (e) {
                var t = e.match(
                  /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/
                );
                return (
                  null !== t && {
                    space: "RGB",
                    r: parseFloat(t[1]),
                    g: parseFloat(t[2]),
                    b: parseFloat(t[3]),
                    a: parseFloat(t[4]),
                  }
                );
              },
              write: Cl,
            },
          },
        },
        {
          litmus: Dl.isNumber,
          conversions: {
            HEX: {
              read: function (e) {
                return { space: "HEX", hex: e, conversionName: "HEX" };
              },
              write: function (e) {
                return e.hex;
              },
            },
          },
        },
        {
          litmus: Dl.isArray,
          conversions: {
            RGB_ARRAY: {
              read: function (e) {
                return (
                  3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] }
                );
              },
              write: function (e) {
                return [e.r, e.g, e.b];
              },
            },
            RGBA_ARRAY: {
              read: function (e) {
                return (
                  4 === e.length && {
                    space: "RGB",
                    r: e[0],
                    g: e[1],
                    b: e[2],
                    a: e[3],
                  }
                );
              },
              write: function (e) {
                return [e.r, e.g, e.b, e.a];
              },
            },
          },
        },
        {
          litmus: Dl.isObject,
          conversions: {
            RGBA_OBJ: {
              read: function (e) {
                return (
                  !!(
                    Dl.isNumber(e.r) &&
                    Dl.isNumber(e.g) &&
                    Dl.isNumber(e.b) &&
                    Dl.isNumber(e.a)
                  ) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a }
                );
              },
              write: function (e) {
                return { r: e.r, g: e.g, b: e.b, a: e.a };
              },
            },
            RGB_OBJ: {
              read: function (e) {
                return (
                  !!(
                    Dl.isNumber(e.r) &&
                    Dl.isNumber(e.g) &&
                    Dl.isNumber(e.b)
                  ) && { space: "RGB", r: e.r, g: e.g, b: e.b }
                );
              },
              write: function (e) {
                return { r: e.r, g: e.g, b: e.b };
              },
            },
            HSVA_OBJ: {
              read: function (e) {
                return (
                  !!(
                    Dl.isNumber(e.h) &&
                    Dl.isNumber(e.s) &&
                    Dl.isNumber(e.v) &&
                    Dl.isNumber(e.a)
                  ) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a }
                );
              },
              write: function (e) {
                return { h: e.h, s: e.s, v: e.v, a: e.a };
              },
            },
            HSV_OBJ: {
              read: function (e) {
                return (
                  !!(
                    Dl.isNumber(e.h) &&
                    Dl.isNumber(e.s) &&
                    Dl.isNumber(e.v)
                  ) && { space: "HSV", h: e.h, s: e.s, v: e.v }
                );
              },
              write: function (e) {
                return { h: e.h, s: e.s, v: e.v };
              },
            },
          },
        },
      ],
      Ol = void 0,
      zl = void 0,
      Fl = function () {
        zl = !1;
        var e = arguments.length > 1 ? Dl.toArray(arguments) : arguments[0];
        return (
          Dl.each(Nl, function (t) {
            if (t.litmus(e))
              return (
                Dl.each(t.conversions, function (t, n) {
                  if (((Ol = t.read(e)), !1 === zl && !1 !== Ol))
                    return (
                      (zl = Ol),
                      (Ol.conversionName = n),
                      (Ol.conversion = t),
                      Dl.BREAK
                    );
                }),
                Dl.BREAK
              );
          }),
          zl
        );
      },
      Bl = void 0,
      Ul = {
        hsv_to_rgb: function (e, t, n) {
          var i = Math.floor(e / 60) % 6,
            r = e / 60 - Math.floor(e / 60),
            s = n * (1 - t),
            a = n * (1 - r * t),
            o = n * (1 - (1 - r) * t),
            l = [
              [n, o, s],
              [a, n, s],
              [s, n, o],
              [s, a, n],
              [o, s, n],
              [n, s, a],
            ][i];
          return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] };
        },
        rgb_to_hsv: function (e, t, n) {
          var i = Math.min(e, t, n),
            r = Math.max(e, t, n),
            s = r - i,
            a = void 0;
          return 0 === r
            ? { h: NaN, s: 0, v: 0 }
            : ((a =
                e === r
                  ? (t - n) / s
                  : t === r
                  ? 2 + (n - e) / s
                  : 4 + (e - t) / s),
              (a /= 6) < 0 && (a += 1),
              { h: 360 * a, s: s / r, v: r / 255 });
        },
        rgb_to_hex: function (e, t, n) {
          var i = this.hex_with_component(0, 2, e);
          return (
            (i = this.hex_with_component(i, 1, t)),
            (i = this.hex_with_component(i, 0, n))
          );
        },
        component_from_hex: function (e, t) {
          return (e >> (8 * t)) & 255;
        },
        hex_with_component: function (e, t, n) {
          return (n << (Bl = 8 * t)) | (e & ~(255 << Bl));
        },
      },
      Hl =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (e) {
              return typeof e;
            }
          : function (e) {
              return e &&
                "function" == typeof Symbol &&
                e.constructor === Symbol &&
                e !== Symbol.prototype
                ? "symbol"
                : typeof e;
            },
      kl = function (e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      },
      Gl = (function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];
            (i.enumerable = i.enumerable || !1),
              (i.configurable = !0),
              "value" in i && (i.writable = !0),
              Object.defineProperty(e, i.key, i);
          }
        }
        return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      })(),
      Vl = function e(t, n, i) {
        null === t && (t = Function.prototype);
        var r = Object.getOwnPropertyDescriptor(t, n);
        if (void 0 === r) {
          var s = Object.getPrototypeOf(t);
          return null === s ? void 0 : e(s, n, i);
        }
        if ("value" in r) return r.value;
        var a = r.get;
        return void 0 !== a ? a.call(i) : void 0;
      },
      Wl = function (e, t) {
        if ("function" != typeof t && null !== t)
          throw new TypeError(
            "Super expression must either be null or a function, not " +
              typeof t
          );
        (e.prototype = Object.create(t && t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
          t &&
            (Object.setPrototypeOf
              ? Object.setPrototypeOf(e, t)
              : (e.__proto__ = t));
      },
      jl = function (e, t) {
        if (!e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
      },
      ql = (function () {
        function e() {
          if (
            (kl(this, e),
            (this.__state = Fl.apply(this, arguments)),
            !1 === this.__state)
          )
            throw new Error("Failed to interpret color arguments");
          this.__state.a = this.__state.a || 1;
        }
        return (
          Gl(e, [
            {
              key: "toString",
              value: function () {
                return Cl(this);
              },
            },
            {
              key: "toHexString",
              value: function () {
                return Cl(this, !0);
              },
            },
            {
              key: "toOriginal",
              value: function () {
                return this.__state.conversion.write(this);
              },
            },
          ]),
          e
        );
      })();
    function Xl(e, t, n) {
      Object.defineProperty(e, t, {
        get: function () {
          return (
            "RGB" === this.__state.space || ql.recalculateRGB(this, t, n),
            this.__state[t]
          );
        },
        set: function (e) {
          "RGB" !== this.__state.space &&
            (ql.recalculateRGB(this, t, n), (this.__state.space = "RGB")),
            (this.__state[t] = e);
        },
      });
    }
    function Yl(e, t) {
      Object.defineProperty(e, t, {
        get: function () {
          return (
            "HSV" === this.__state.space || ql.recalculateHSV(this),
            this.__state[t]
          );
        },
        set: function (e) {
          "HSV" !== this.__state.space &&
            (ql.recalculateHSV(this), (this.__state.space = "HSV")),
            (this.__state[t] = e);
        },
      });
    }
    (ql.recalculateRGB = function (e, t, n) {
      if ("HEX" === e.__state.space)
        e.__state[t] = Ul.component_from_hex(e.__state.hex, n);
      else {
        if ("HSV" !== e.__state.space) throw new Error("Corrupted color state");
        Dl.extend(
          e.__state,
          Ul.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)
        );
      }
    }),
      (ql.recalculateHSV = function (e) {
        var t = Ul.rgb_to_hsv(e.r, e.g, e.b);
        Dl.extend(e.__state, { s: t.s, v: t.v }),
          Dl.isNaN(t.h)
            ? Dl.isUndefined(e.__state.h) && (e.__state.h = 0)
            : (e.__state.h = t.h);
      }),
      (ql.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"]),
      Xl(ql.prototype, "r", 2),
      Xl(ql.prototype, "g", 1),
      Xl(ql.prototype, "b", 0),
      Yl(ql.prototype, "h"),
      Yl(ql.prototype, "s"),
      Yl(ql.prototype, "v"),
      Object.defineProperty(ql.prototype, "a", {
        get: function () {
          return this.__state.a;
        },
        set: function (e) {
          this.__state.a = e;
        },
      }),
      Object.defineProperty(ql.prototype, "hex", {
        get: function () {
          return (
            "HEX" !== this.__state.space &&
              ((this.__state.hex = Ul.rgb_to_hex(this.r, this.g, this.b)),
              (this.__state.space = "HEX")),
            this.__state.hex
          );
        },
        set: function (e) {
          (this.__state.space = "HEX"), (this.__state.hex = e);
        },
      });
    var Jl = (function () {
        function e(t, n) {
          kl(this, e),
            (this.initialValue = t[n]),
            (this.domElement = document.createElement("div")),
            (this.object = t),
            (this.property = n),
            (this.__onChange = void 0),
            (this.__onFinishChange = void 0);
        }
        return (
          Gl(e, [
            {
              key: "onChange",
              value: function (e) {
                return (this.__onChange = e), this;
              },
            },
            {
              key: "onFinishChange",
              value: function (e) {
                return (this.__onFinishChange = e), this;
              },
            },
            {
              key: "setValue",
              value: function (e) {
                return (
                  (this.object[this.property] = e),
                  this.__onChange && this.__onChange.call(this, e),
                  this.updateDisplay(),
                  this
                );
              },
            },
            {
              key: "getValue",
              value: function () {
                return this.object[this.property];
              },
            },
            {
              key: "updateDisplay",
              value: function () {
                return this;
              },
            },
            {
              key: "isModified",
              value: function () {
                return this.initialValue !== this.getValue();
              },
            },
          ]),
          e
        );
      })(),
      Zl = {};
    Dl.each(
      {
        HTMLEvents: ["change"],
        MouseEvents: [
          "click",
          "mousemove",
          "mousedown",
          "mouseup",
          "mouseover",
        ],
        KeyboardEvents: ["keydown"],
      },
      function (e, t) {
        Dl.each(e, function (e) {
          Zl[e] = t;
        });
      }
    );
    var Kl = /(\d+(\.\d+)?)px/;
    function Ql(e) {
      if ("0" === e || Dl.isUndefined(e)) return 0;
      var t = e.match(Kl);
      return Dl.isNull(t) ? 0 : parseFloat(t[1]);
    }
    var $l = {
        makeSelectable: function (e, t) {
          void 0 !== e &&
            void 0 !== e.style &&
            ((e.onselectstart = t
              ? function () {
                  return !1;
                }
              : function () {}),
            (e.style.MozUserSelect = t ? "auto" : "none"),
            (e.style.KhtmlUserSelect = t ? "auto" : "none"),
            (e.unselectable = t ? "on" : "off"));
        },
        makeFullscreen: function (e, t, n) {
          var i = n,
            r = t;
          Dl.isUndefined(r) && (r = !0),
            Dl.isUndefined(i) && (i = !0),
            (e.style.position = "absolute"),
            r && ((e.style.left = 0), (e.style.right = 0)),
            i && ((e.style.top = 0), (e.style.bottom = 0));
        },
        fakeEvent: function (e, t, n, i) {
          var r = n || {},
            s = Zl[t];
          if (!s) throw new Error("Event type " + t + " not supported.");
          var a = document.createEvent(s);
          switch (s) {
            case "MouseEvents":
              var o = r.x || r.clientX || 0,
                l = r.y || r.clientY || 0;
              a.initMouseEvent(
                t,
                r.bubbles || !1,
                r.cancelable || !0,
                window,
                r.clickCount || 1,
                0,
                0,
                o,
                l,
                !1,
                !1,
                !1,
                !1,
                0,
                null
              );
              break;
            case "KeyboardEvents":
              var c = a.initKeyboardEvent || a.initKeyEvent;
              Dl.defaults(r, {
                cancelable: !0,
                ctrlKey: !1,
                altKey: !1,
                shiftKey: !1,
                metaKey: !1,
                keyCode: void 0,
                charCode: void 0,
              }),
                c(
                  t,
                  r.bubbles || !1,
                  r.cancelable,
                  window,
                  r.ctrlKey,
                  r.altKey,
                  r.shiftKey,
                  r.metaKey,
                  r.keyCode,
                  r.charCode
                );
              break;
            default:
              a.initEvent(t, r.bubbles || !1, r.cancelable || !0);
          }
          Dl.defaults(a, i), e.dispatchEvent(a);
        },
        bind: function (e, t, n, i) {
          var r = i || !1;
          return (
            e.addEventListener
              ? e.addEventListener(t, n, r)
              : e.attachEvent && e.attachEvent("on" + t, n),
            $l
          );
        },
        unbind: function (e, t, n, i) {
          var r = i || !1;
          return (
            e.removeEventListener
              ? e.removeEventListener(t, n, r)
              : e.detachEvent && e.detachEvent("on" + t, n),
            $l
          );
        },
        addClass: function (e, t) {
          if (void 0 === e.className) e.className = t;
          else if (e.className !== t) {
            var n = e.className.split(/ +/);
            -1 === n.indexOf(t) &&
              (n.push(t),
              (e.className = n
                .join(" ")
                .replace(/^\s+/, "")
                .replace(/\s+$/, "")));
          }
          return $l;
        },
        removeClass: function (e, t) {
          if (t)
            if (e.className === t) e.removeAttribute("class");
            else {
              var n = e.className.split(/ +/),
                i = n.indexOf(t);
              -1 !== i && (n.splice(i, 1), (e.className = n.join(" ")));
            }
          else e.className = void 0;
          return $l;
        },
        hasClass: function (e, t) {
          return (
            new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
          );
        },
        getWidth: function (e) {
          var t = getComputedStyle(e);
          return (
            Ql(t["border-left-width"]) +
            Ql(t["border-right-width"]) +
            Ql(t["padding-left"]) +
            Ql(t["padding-right"]) +
            Ql(t.width)
          );
        },
        getHeight: function (e) {
          var t = getComputedStyle(e);
          return (
            Ql(t["border-top-width"]) +
            Ql(t["border-bottom-width"]) +
            Ql(t["padding-top"]) +
            Ql(t["padding-bottom"]) +
            Ql(t.height)
          );
        },
        getOffset: function (e) {
          var t = e,
            n = { left: 0, top: 0 };
          if (t.offsetParent)
            do {
              (n.left += t.offsetLeft),
                (n.top += t.offsetTop),
                (t = t.offsetParent);
            } while (t);
          return n;
        },
        isActive: function (e) {
          return e === document.activeElement && (e.type || e.href);
        },
      },
      ec = (function (e) {
        function t(e, n) {
          kl(this, t);
          var i = jl(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
            ),
            r = i;
          return (
            (i.__prev = i.getValue()),
            (i.__checkbox = document.createElement("input")),
            i.__checkbox.setAttribute("type", "checkbox"),
            $l.bind(
              i.__checkbox,
              "change",
              function () {
                r.setValue(!r.__prev);
              },
              !1
            ),
            i.domElement.appendChild(i.__checkbox),
            i.updateDisplay(),
            i
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "setValue",
              value: function (e) {
                var n = Vl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "setValue",
                  this
                ).call(this, e);
                return (
                  this.__onFinishChange &&
                    this.__onFinishChange.call(this, this.getValue()),
                  (this.__prev = this.getValue()),
                  n
                );
              },
            },
            {
              key: "updateDisplay",
              value: function () {
                return (
                  !0 === this.getValue()
                    ? (this.__checkbox.setAttribute("checked", "checked"),
                      (this.__checkbox.checked = !0),
                      (this.__prev = !0))
                    : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                  Vl(
                    t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                    "updateDisplay",
                    this
                  ).call(this)
                );
              },
            },
          ]),
          t
        );
      })(Jl),
      tc = (function (e) {
        function t(e, n, i) {
          kl(this, t);
          var r = jl(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
            ),
            s = i,
            a = r;
          if (
            ((r.__select = document.createElement("select")), Dl.isArray(s))
          ) {
            var o = {};
            Dl.each(s, function (e) {
              o[e] = e;
            }),
              (s = o);
          }
          return (
            Dl.each(s, function (e, t) {
              var n = document.createElement("option");
              (n.innerHTML = t),
                n.setAttribute("value", e),
                a.__select.appendChild(n);
            }),
            r.updateDisplay(),
            $l.bind(r.__select, "change", function () {
              var e = this.options[this.selectedIndex].value;
              a.setValue(e);
            }),
            r.domElement.appendChild(r.__select),
            r
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "setValue",
              value: function (e) {
                var n = Vl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "setValue",
                  this
                ).call(this, e);
                return (
                  this.__onFinishChange &&
                    this.__onFinishChange.call(this, this.getValue()),
                  n
                );
              },
            },
            {
              key: "updateDisplay",
              value: function () {
                return $l.isActive(this.__select)
                  ? this
                  : ((this.__select.value = this.getValue()),
                    Vl(
                      t.prototype.__proto__ ||
                        Object.getPrototypeOf(t.prototype),
                      "updateDisplay",
                      this
                    ).call(this));
              },
            },
          ]),
          t
        );
      })(Jl),
      nc = (function (e) {
        function t(e, n) {
          kl(this, t);
          var i = jl(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
            ),
            r = i;
          function s() {
            r.setValue(r.__input.value);
          }
          return (
            (i.__input = document.createElement("input")),
            i.__input.setAttribute("type", "text"),
            $l.bind(i.__input, "keyup", s),
            $l.bind(i.__input, "change", s),
            $l.bind(i.__input, "blur", function () {
              r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
            }),
            $l.bind(i.__input, "keydown", function (e) {
              13 === e.keyCode && this.blur();
            }),
            i.updateDisplay(),
            i.domElement.appendChild(i.__input),
            i
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "updateDisplay",
              value: function () {
                return (
                  $l.isActive(this.__input) ||
                    (this.__input.value = this.getValue()),
                  Vl(
                    t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                    "updateDisplay",
                    this
                  ).call(this)
                );
              },
            },
          ]),
          t
        );
      })(Jl);
    function ic(e) {
      var t = e.toString();
      return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0;
    }
    var rc = (function (e) {
      function t(e, n, i) {
        kl(this, t);
        var r = jl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          s = i || {};
        return (
          (r.__min = s.min),
          (r.__max = s.max),
          (r.__step = s.step),
          Dl.isUndefined(r.__step)
            ? 0 === r.initialValue
              ? (r.__impliedStep = 1)
              : (r.__impliedStep =
                  Math.pow(
                    10,
                    Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)
                  ) / 10)
            : (r.__impliedStep = r.__step),
          (r.__precision = ic(r.__impliedStep)),
          r
        );
      }
      return (
        Wl(t, e),
        Gl(t, [
          {
            key: "setValue",
            value: function (e) {
              var n = e;
              return (
                void 0 !== this.__min && n < this.__min
                  ? (n = this.__min)
                  : void 0 !== this.__max && n > this.__max && (n = this.__max),
                void 0 !== this.__step &&
                  n % this.__step != 0 &&
                  (n = Math.round(n / this.__step) * this.__step),
                Vl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "setValue",
                  this
                ).call(this, n)
              );
            },
          },
          {
            key: "min",
            value: function (e) {
              return (this.__min = e), this;
            },
          },
          {
            key: "max",
            value: function (e) {
              return (this.__max = e), this;
            },
          },
          {
            key: "step",
            value: function (e) {
              return (
                (this.__step = e),
                (this.__impliedStep = e),
                (this.__precision = ic(e)),
                this
              );
            },
          },
        ]),
        t
      );
    })(Jl);
    var sc = (function (e) {
      function t(e, n, i) {
        kl(this, t);
        var r = jl(
          this,
          (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, i)
        );
        r.__truncationSuspended = !1;
        var s = r,
          a = void 0;
        function o() {
          s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
        }
        function l(e) {
          var t = a - e.clientY;
          s.setValue(s.getValue() + t * s.__impliedStep), (a = e.clientY);
        }
        function c() {
          $l.unbind(window, "mousemove", l),
            $l.unbind(window, "mouseup", c),
            o();
        }
        return (
          (r.__input = document.createElement("input")),
          r.__input.setAttribute("type", "text"),
          $l.bind(r.__input, "change", function () {
            var e = parseFloat(s.__input.value);
            Dl.isNaN(e) || s.setValue(e);
          }),
          $l.bind(r.__input, "blur", function () {
            o();
          }),
          $l.bind(r.__input, "mousedown", function (e) {
            $l.bind(window, "mousemove", l),
              $l.bind(window, "mouseup", c),
              (a = e.clientY);
          }),
          $l.bind(r.__input, "keydown", function (e) {
            13 === e.keyCode &&
              ((s.__truncationSuspended = !0),
              this.blur(),
              (s.__truncationSuspended = !1),
              o());
          }),
          r.updateDisplay(),
          r.domElement.appendChild(r.__input),
          r
        );
      }
      return (
        Wl(t, e),
        Gl(t, [
          {
            key: "updateDisplay",
            value: function () {
              var e, n, i;
              return (
                (this.__input.value = this.__truncationSuspended
                  ? this.getValue()
                  : ((e = this.getValue()),
                    (n = this.__precision),
                    (i = Math.pow(10, n)),
                    Math.round(e * i) / i)),
                Vl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "updateDisplay",
                  this
                ).call(this)
              );
            },
          },
        ]),
        t
      );
    })(rc);
    function ac(e, t, n, i, r) {
      return i + ((e - t) / (n - t)) * (r - i);
    }
    var oc = (function (e) {
        function t(e, n, i, r, s) {
          kl(this, t);
          var a = jl(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, {
                min: i,
                max: r,
                step: s,
              })
            ),
            o = a;
          function l(e) {
            e.preventDefault();
            var t = o.__background.getBoundingClientRect();
            return (
              o.setValue(ac(e.clientX, t.left, t.right, o.__min, o.__max)), !1
            );
          }
          function c() {
            $l.unbind(window, "mousemove", l),
              $l.unbind(window, "mouseup", c),
              o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
          }
          function h(e) {
            var t = e.touches[0].clientX,
              n = o.__background.getBoundingClientRect();
            o.setValue(ac(t, n.left, n.right, o.__min, o.__max));
          }
          function u() {
            $l.unbind(window, "touchmove", h),
              $l.unbind(window, "touchend", u),
              o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
          }
          return (
            (a.__background = document.createElement("div")),
            (a.__foreground = document.createElement("div")),
            $l.bind(a.__background, "mousedown", function (e) {
              document.activeElement.blur(),
                $l.bind(window, "mousemove", l),
                $l.bind(window, "mouseup", c),
                l(e);
            }),
            $l.bind(a.__background, "touchstart", function (e) {
              if (1 !== e.touches.length) return;
              $l.bind(window, "touchmove", h),
                $l.bind(window, "touchend", u),
                h(e);
            }),
            $l.addClass(a.__background, "slider"),
            $l.addClass(a.__foreground, "slider-fg"),
            a.updateDisplay(),
            a.__background.appendChild(a.__foreground),
            a.domElement.appendChild(a.__background),
            a
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "updateDisplay",
              value: function () {
                var e =
                  (this.getValue() - this.__min) / (this.__max - this.__min);
                return (
                  (this.__foreground.style.width = 100 * e + "%"),
                  Vl(
                    t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                    "updateDisplay",
                    this
                  ).call(this)
                );
              },
            },
          ]),
          t
        );
      })(rc),
      lc = (function (e) {
        function t(e, n, i) {
          kl(this, t);
          var r = jl(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
            ),
            s = r;
          return (
            (r.__button = document.createElement("div")),
            (r.__button.innerHTML = void 0 === i ? "Fire" : i),
            $l.bind(r.__button, "click", function (e) {
              return e.preventDefault(), s.fire(), !1;
            }),
            $l.addClass(r.__button, "button"),
            r.domElement.appendChild(r.__button),
            r
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "fire",
              value: function () {
                this.__onChange && this.__onChange.call(this),
                  this.getValue().call(this.object),
                  this.__onFinishChange &&
                    this.__onFinishChange.call(this, this.getValue());
              },
            },
          ]),
          t
        );
      })(Jl),
      cc = (function (e) {
        function t(e, n) {
          kl(this, t);
          var i = jl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          );
          (i.__color = new ql(i.getValue())), (i.__temp = new ql(0));
          var r = i;
          (i.domElement = document.createElement("div")),
            $l.makeSelectable(i.domElement, !1),
            (i.__selector = document.createElement("div")),
            (i.__selector.className = "selector"),
            (i.__saturation_field = document.createElement("div")),
            (i.__saturation_field.className = "saturation-field"),
            (i.__field_knob = document.createElement("div")),
            (i.__field_knob.className = "field-knob"),
            (i.__field_knob_border = "2px solid "),
            (i.__hue_knob = document.createElement("div")),
            (i.__hue_knob.className = "hue-knob"),
            (i.__hue_field = document.createElement("div")),
            (i.__hue_field.className = "hue-field"),
            (i.__input = document.createElement("input")),
            (i.__input.type = "text"),
            (i.__input_textShadow = "0 1px 1px "),
            $l.bind(i.__input, "keydown", function (e) {
              13 === e.keyCode && u.call(this);
            }),
            $l.bind(i.__input, "blur", u),
            $l.bind(i.__selector, "mousedown", function () {
              $l.addClass(this, "drag").bind(window, "mouseup", function () {
                $l.removeClass(r.__selector, "drag");
              });
            }),
            $l.bind(i.__selector, "touchstart", function () {
              $l.addClass(this, "drag").bind(window, "touchend", function () {
                $l.removeClass(r.__selector, "drag");
              });
            });
          var s,
            a = document.createElement("div");
          function o(e) {
            p(e),
              $l.bind(window, "mousemove", p),
              $l.bind(window, "touchmove", p),
              $l.bind(window, "mouseup", c),
              $l.bind(window, "touchend", c);
          }
          function l(e) {
            m(e),
              $l.bind(window, "mousemove", m),
              $l.bind(window, "touchmove", m),
              $l.bind(window, "mouseup", h),
              $l.bind(window, "touchend", h);
          }
          function c() {
            $l.unbind(window, "mousemove", p),
              $l.unbind(window, "touchmove", p),
              $l.unbind(window, "mouseup", c),
              $l.unbind(window, "touchend", c),
              d();
          }
          function h() {
            $l.unbind(window, "mousemove", m),
              $l.unbind(window, "touchmove", m),
              $l.unbind(window, "mouseup", h),
              $l.unbind(window, "touchend", h),
              d();
          }
          function u() {
            var e = Fl(this.value);
            !1 !== e
              ? ((r.__color.__state = e), r.setValue(r.__color.toOriginal()))
              : (this.value = r.__color.toString());
          }
          function d() {
            r.__onFinishChange &&
              r.__onFinishChange.call(r, r.__color.toOriginal());
          }
          function p(e) {
            -1 === e.type.indexOf("touch") && e.preventDefault();
            var t = r.__saturation_field.getBoundingClientRect(),
              n = (e.touches && e.touches[0]) || e,
              i = n.clientX,
              s = n.clientY,
              a = (i - t.left) / (t.right - t.left),
              o = 1 - (s - t.top) / (t.bottom - t.top);
            return (
              o > 1 ? (o = 1) : o < 0 && (o = 0),
              a > 1 ? (a = 1) : a < 0 && (a = 0),
              (r.__color.v = o),
              (r.__color.s = a),
              r.setValue(r.__color.toOriginal()),
              !1
            );
          }
          function m(e) {
            -1 === e.type.indexOf("touch") && e.preventDefault();
            var t = r.__hue_field.getBoundingClientRect(),
              n =
                1 -
                (((e.touches && e.touches[0]) || e).clientY - t.top) /
                  (t.bottom - t.top);
            return (
              n > 1 ? (n = 1) : n < 0 && (n = 0),
              (r.__color.h = 360 * n),
              r.setValue(r.__color.toOriginal()),
              !1
            );
          }
          return (
            Dl.extend(i.__selector.style, {
              width: "122px",
              height: "102px",
              padding: "3px",
              backgroundColor: "#222",
              boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
            }),
            Dl.extend(i.__field_knob.style, {
              position: "absolute",
              width: "12px",
              height: "12px",
              border:
                i.__field_knob_border + (i.__color.v < 0.5 ? "#fff" : "#000"),
              boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
              borderRadius: "12px",
              zIndex: 1,
            }),
            Dl.extend(i.__hue_knob.style, {
              position: "absolute",
              width: "15px",
              height: "2px",
              borderRight: "4px solid #fff",
              zIndex: 1,
            }),
            Dl.extend(i.__saturation_field.style, {
              width: "100px",
              height: "100px",
              border: "1px solid #555",
              marginRight: "3px",
              display: "inline-block",
              cursor: "pointer",
            }),
            Dl.extend(a.style, {
              width: "100%",
              height: "100%",
              background: "none",
            }),
            uc(a, "top", "rgba(0,0,0,0)", "#000"),
            Dl.extend(i.__hue_field.style, {
              width: "15px",
              height: "100px",
              border: "1px solid #555",
              cursor: "ns-resize",
              position: "absolute",
              top: "3px",
              right: "3px",
            }),
            ((s = i.__hue_field).style.background = ""),
            (s.style.cssText +=
              "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
            (s.style.cssText +=
              "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (s.style.cssText +=
              "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (s.style.cssText +=
              "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (s.style.cssText +=
              "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            Dl.extend(i.__input.style, {
              outline: "none",
              textAlign: "center",
              color: "#fff",
              border: 0,
              fontWeight: "bold",
              textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)",
            }),
            $l.bind(i.__saturation_field, "mousedown", o),
            $l.bind(i.__saturation_field, "touchstart", o),
            $l.bind(i.__field_knob, "mousedown", o),
            $l.bind(i.__field_knob, "touchstart", o),
            $l.bind(i.__hue_field, "mousedown", l),
            $l.bind(i.__hue_field, "touchstart", l),
            i.__saturation_field.appendChild(a),
            i.__selector.appendChild(i.__field_knob),
            i.__selector.appendChild(i.__saturation_field),
            i.__selector.appendChild(i.__hue_field),
            i.__hue_field.appendChild(i.__hue_knob),
            i.domElement.appendChild(i.__input),
            i.domElement.appendChild(i.__selector),
            i.updateDisplay(),
            i
          );
        }
        return (
          Wl(t, e),
          Gl(t, [
            {
              key: "updateDisplay",
              value: function () {
                var e = Fl(this.getValue());
                if (!1 !== e) {
                  var t = !1;
                  Dl.each(
                    ql.COMPONENTS,
                    function (n) {
                      if (
                        !Dl.isUndefined(e[n]) &&
                        !Dl.isUndefined(this.__color.__state[n]) &&
                        e[n] !== this.__color.__state[n]
                      )
                        return (t = !0), {};
                    },
                    this
                  ),
                    t && Dl.extend(this.__color.__state, e);
                }
                Dl.extend(this.__temp.__state, this.__color.__state),
                  (this.__temp.a = 1);
                var n = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                  i = 255 - n;
                Dl.extend(this.__field_knob.style, {
                  marginLeft: 100 * this.__color.s - 7 + "px",
                  marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                  backgroundColor: this.__temp.toHexString(),
                  border:
                    this.__field_knob_border +
                    "rgb(" +
                    n +
                    "," +
                    n +
                    "," +
                    n +
                    ")",
                }),
                  (this.__hue_knob.style.marginTop =
                    100 * (1 - this.__color.h / 360) + "px"),
                  (this.__temp.s = 1),
                  (this.__temp.v = 1),
                  uc(
                    this.__saturation_field,
                    "left",
                    "#fff",
                    this.__temp.toHexString()
                  ),
                  (this.__input.value = this.__color.toString()),
                  Dl.extend(this.__input.style, {
                    backgroundColor: this.__color.toHexString(),
                    color: "rgb(" + n + "," + n + "," + n + ")",
                    textShadow:
                      this.__input_textShadow +
                      "rgba(" +
                      i +
                      "," +
                      i +
                      "," +
                      i +
                      ",.7)",
                  });
              },
            },
          ]),
          t
        );
      })(Jl),
      hc = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
    function uc(e, t, n, i) {
      (e.style.background = ""),
        Dl.each(hc, function (r) {
          e.style.cssText +=
            "background: " +
            r +
            "linear-gradient(" +
            t +
            ", " +
            n +
            " 0%, " +
            i +
            " 100%); ";
        });
    }
    var dc = function (e, t) {
        var n = t || document,
          i = document.createElement("style");
        (i.type = "text/css"), (i.innerHTML = e);
        var r = n.getElementsByTagName("head")[0];
        try {
          r.appendChild(i);
        } catch (e) {}
      },
      pc =
        '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
      mc = function (e, t) {
        var n = e[t];
        return Dl.isArray(arguments[2]) || Dl.isObject(arguments[2])
          ? new tc(e, t, arguments[2])
          : Dl.isNumber(n)
          ? Dl.isNumber(arguments[2]) && Dl.isNumber(arguments[3])
            ? Dl.isNumber(arguments[4])
              ? new oc(e, t, arguments[2], arguments[3], arguments[4])
              : new oc(e, t, arguments[2], arguments[3])
            : Dl.isNumber(arguments[4])
            ? new sc(e, t, {
                min: arguments[2],
                max: arguments[3],
                step: arguments[4],
              })
            : new sc(e, t, { min: arguments[2], max: arguments[3] })
          : Dl.isString(n)
          ? new nc(e, t)
          : Dl.isFunction(n)
          ? new lc(e, t, "")
          : Dl.isBoolean(n)
          ? new ec(e, t)
          : null;
      };
    var fc =
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (e) {
          setTimeout(e, 1e3 / 60);
        },
      gc = (function () {
        function e() {
          kl(this, e),
            (this.backgroundElement = document.createElement("div")),
            Dl.extend(this.backgroundElement.style, {
              backgroundColor: "rgba(0,0,0,0.8)",
              top: 0,
              left: 0,
              display: "none",
              zIndex: "1000",
              opacity: 0,
              WebkitTransition: "opacity 0.2s linear",
              transition: "opacity 0.2s linear",
            }),
            $l.makeFullscreen(this.backgroundElement),
            (this.backgroundElement.style.position = "fixed"),
            (this.domElement = document.createElement("div")),
            Dl.extend(this.domElement.style, {
              position: "fixed",
              display: "none",
              zIndex: "1001",
              opacity: 0,
              WebkitTransition:
                "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
              transition: "transform 0.2s ease-out, opacity 0.2s linear",
            }),
            document.body.appendChild(this.backgroundElement),
            document.body.appendChild(this.domElement);
          var t = this;
          $l.bind(this.backgroundElement, "click", function () {
            t.hide();
          });
        }
        return (
          Gl(e, [
            {
              key: "show",
              value: function () {
                var e = this;
                (this.backgroundElement.style.display = "block"),
                  (this.domElement.style.display = "block"),
                  (this.domElement.style.opacity = 0),
                  (this.domElement.style.webkitTransform = "scale(1.1)"),
                  this.layout(),
                  Dl.defer(function () {
                    (e.backgroundElement.style.opacity = 1),
                      (e.domElement.style.opacity = 1),
                      (e.domElement.style.webkitTransform = "scale(1)");
                  });
              },
            },
            {
              key: "hide",
              value: function () {
                var e = this,
                  t = function t() {
                    (e.domElement.style.display = "none"),
                      (e.backgroundElement.style.display = "none"),
                      $l.unbind(e.domElement, "webkitTransitionEnd", t),
                      $l.unbind(e.domElement, "transitionend", t),
                      $l.unbind(e.domElement, "oTransitionEnd", t);
                  };
                $l.bind(this.domElement, "webkitTransitionEnd", t),
                  $l.bind(this.domElement, "transitionend", t),
                  $l.bind(this.domElement, "oTransitionEnd", t),
                  (this.backgroundElement.style.opacity = 0),
                  (this.domElement.style.opacity = 0),
                  (this.domElement.style.webkitTransform = "scale(1.1)");
              },
            },
            {
              key: "layout",
              value: function () {
                (this.domElement.style.left =
                  window.innerWidth / 2 -
                  $l.getWidth(this.domElement) / 2 +
                  "px"),
                  (this.domElement.style.top =
                    window.innerHeight / 2 -
                    $l.getHeight(this.domElement) / 2 +
                    "px");
              },
            },
          ]),
          e
        );
      })();
    dc(
      (function (e) {
        if (e && "undefined" != typeof window) {
          var t = document.createElement("style");
          return (
            t.setAttribute("type", "text/css"),
            (t.innerHTML = e),
            document.head.appendChild(t),
            e
          );
        }
      })(
        ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"
      )
    );
    var vc = (function () {
        try {
          return !!window.localStorage;
        } catch (e) {
          return !1;
        }
      })(),
      _c = void 0,
      xc = !0,
      yc = void 0,
      bc = !1,
      wc = [],
      Mc = function e(t) {
        var n = this,
          i = t || {};
        (this.domElement = document.createElement("div")),
          (this.__ul = document.createElement("ul")),
          this.domElement.appendChild(this.__ul),
          $l.addClass(this.domElement, "dg"),
          (this.__folders = {}),
          (this.__controllers = []),
          (this.__rememberedObjects = []),
          (this.__rememberedObjectIndecesToControllers = []),
          (this.__listening = []),
          (i = Dl.defaults(i, {
            closeOnTop: !1,
            autoPlace: !0,
            width: e.DEFAULT_WIDTH,
          })),
          (i = Dl.defaults(i, {
            resizable: i.autoPlace,
            hideable: i.autoPlace,
          })),
          Dl.isUndefined(i.load)
            ? (i.load = { preset: "Default" })
            : i.preset && (i.load.preset = i.preset),
          Dl.isUndefined(i.parent) && i.hideable && wc.push(this),
          (i.resizable = Dl.isUndefined(i.parent) && i.resizable),
          i.autoPlace && Dl.isUndefined(i.scrollable) && (i.scrollable = !0);
        var r,
          s = vc && "true" === localStorage.getItem(Rc(this, "isLocal")),
          a = void 0,
          o = void 0;
        if (
          (Object.defineProperties(this, {
            parent: {
              get: function () {
                return i.parent;
              },
            },
            scrollable: {
              get: function () {
                return i.scrollable;
              },
            },
            autoPlace: {
              get: function () {
                return i.autoPlace;
              },
            },
            closeOnTop: {
              get: function () {
                return i.closeOnTop;
              },
            },
            preset: {
              get: function () {
                return n.parent ? n.getRoot().preset : i.load.preset;
              },
              set: function (e) {
                n.parent ? (n.getRoot().preset = e) : (i.load.preset = e),
                  (function (e) {
                    for (var t = 0; t < e.__preset_select.length; t++)
                      e.__preset_select[t].value === e.preset &&
                        (e.__preset_select.selectedIndex = t);
                  })(this),
                  n.revert();
              },
            },
            width: {
              get: function () {
                return i.width;
              },
              set: function (e) {
                (i.width = e), Nc(n, e);
              },
            },
            name: {
              get: function () {
                return i.name;
              },
              set: function (e) {
                (i.name = e), o && (o.innerHTML = i.name);
              },
            },
            closed: {
              get: function () {
                return i.closed;
              },
              set: function (t) {
                (i.closed = t),
                  i.closed
                    ? $l.addClass(n.__ul, e.CLASS_CLOSED)
                    : $l.removeClass(n.__ul, e.CLASS_CLOSED),
                  this.onResize(),
                  n.__closeButton &&
                    (n.__closeButton.innerHTML = t
                      ? e.TEXT_OPEN
                      : e.TEXT_CLOSED);
              },
            },
            load: {
              get: function () {
                return i.load;
              },
            },
            useLocalStorage: {
              get: function () {
                return s;
              },
              set: function (e) {
                vc &&
                  ((s = e),
                  e
                    ? $l.bind(window, "unload", a)
                    : $l.unbind(window, "unload", a),
                  localStorage.setItem(Rc(n, "isLocal"), e));
              },
            },
          }),
          Dl.isUndefined(i.parent))
        ) {
          if (
            ((this.closed = i.closed || !1),
            $l.addClass(this.domElement, e.CLASS_MAIN),
            $l.makeSelectable(this.domElement, !1),
            vc && s)
          ) {
            n.useLocalStorage = !0;
            var l = localStorage.getItem(Rc(this, "gui"));
            l && (i.load = JSON.parse(l));
          }
          (this.__closeButton = document.createElement("div")),
            (this.__closeButton.innerHTML = e.TEXT_CLOSED),
            $l.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON),
            i.closeOnTop
              ? ($l.addClass(this.__closeButton, e.CLASS_CLOSE_TOP),
                this.domElement.insertBefore(
                  this.__closeButton,
                  this.domElement.childNodes[0]
                ))
              : ($l.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM),
                this.domElement.appendChild(this.__closeButton)),
            $l.bind(this.__closeButton, "click", function () {
              n.closed = !n.closed;
            });
        } else {
          void 0 === i.closed && (i.closed = !0);
          var c = document.createTextNode(i.name);
          $l.addClass(c, "controller-name"), (o = Sc(n, c));
          $l.addClass(this.__ul, e.CLASS_CLOSED),
            $l.addClass(o, "title"),
            $l.bind(o, "click", function (e) {
              return e.preventDefault(), (n.closed = !n.closed), !1;
            }),
            i.closed || (this.closed = !1);
        }
        i.autoPlace &&
          (Dl.isUndefined(i.parent) &&
            (xc &&
              ((yc = document.createElement("div")),
              $l.addClass(yc, "dg"),
              $l.addClass(yc, e.CLASS_AUTO_PLACE_CONTAINER),
              document.body.appendChild(yc),
              (xc = !1)),
            yc.appendChild(this.domElement),
            $l.addClass(this.domElement, e.CLASS_AUTO_PLACE)),
          this.parent || Nc(n, i.width)),
          (this.__resizeHandler = function () {
            n.onResizeDebounced();
          }),
          $l.bind(window, "resize", this.__resizeHandler),
          $l.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
          $l.bind(this.__ul, "transitionend", this.__resizeHandler),
          $l.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
          this.onResize(),
          i.resizable && Dc(this),
          (a = function () {
            vc &&
              "true" === localStorage.getItem(Rc(n, "isLocal")) &&
              localStorage.setItem(
                Rc(n, "gui"),
                JSON.stringify(n.getSaveObject())
              );
          }),
          (this.saveToLocalStorageIfPossible = a),
          i.parent ||
            (((r = n.getRoot()).width += 1),
            Dl.defer(function () {
              r.width -= 1;
            }));
      };
    function Sc(e, t, n) {
      var i = document.createElement("li");
      return (
        t && i.appendChild(t),
        n ? e.__ul.insertBefore(i, n) : e.__ul.appendChild(i),
        e.onResize(),
        i
      );
    }
    function Tc(e) {
      $l.unbind(window, "resize", e.__resizeHandler),
        e.saveToLocalStorageIfPossible &&
          $l.unbind(window, "unload", e.saveToLocalStorageIfPossible);
    }
    function Ec(e, t) {
      var n = e.__preset_select[e.__preset_select.selectedIndex];
      n.innerHTML = t ? n.value + "*" : n.value;
    }
    function Ac(e, t) {
      var n = e.getRoot(),
        i = n.__rememberedObjects.indexOf(t.object);
      if (-1 !== i) {
        var r = n.__rememberedObjectIndecesToControllers[i];
        if (
          (void 0 === r &&
            ((r = {}), (n.__rememberedObjectIndecesToControllers[i] = r)),
          (r[t.property] = t),
          n.load && n.load.remembered)
        ) {
          var s = n.load.remembered,
            a = void 0;
          if (s[e.preset]) a = s[e.preset];
          else {
            if (!s.Default) return;
            a = s.Default;
          }
          if (a[i] && void 0 !== a[i][t.property]) {
            var o = a[i][t.property];
            (t.initialValue = o), t.setValue(o);
          }
        }
      }
    }
    function Lc(e, t, n, i) {
      if (void 0 === t[n])
        throw new Error('Object "' + t + '" has no property "' + n + '"');
      var r = void 0;
      if (i.color) r = new cc(t, n);
      else {
        var s = [t, n].concat(i.factoryArgs);
        r = mc.apply(e, s);
      }
      i.before instanceof Jl && (i.before = i.before.__li),
        Ac(e, r),
        $l.addClass(r.domElement, "c");
      var a = document.createElement("span");
      $l.addClass(a, "property-name"), (a.innerHTML = r.property);
      var o = document.createElement("div");
      o.appendChild(a), o.appendChild(r.domElement);
      var l = Sc(e, o, i.before);
      return (
        $l.addClass(l, Mc.CLASS_CONTROLLER_ROW),
        r instanceof cc
          ? $l.addClass(l, "color")
          : $l.addClass(l, Hl(r.getValue())),
        (function (e, t, n) {
          if (
            ((n.__li = t),
            (n.__gui = e),
            Dl.extend(n, {
              options: function (t) {
                if (arguments.length > 1) {
                  var i = n.__li.nextElementSibling;
                  return (
                    n.remove(),
                    Lc(e, n.object, n.property, {
                      before: i,
                      factoryArgs: [Dl.toArray(arguments)],
                    })
                  );
                }
                if (Dl.isArray(t) || Dl.isObject(t)) {
                  var r = n.__li.nextElementSibling;
                  return (
                    n.remove(),
                    Lc(e, n.object, n.property, { before: r, factoryArgs: [t] })
                  );
                }
              },
              name: function (e) {
                return (
                  (n.__li.firstElementChild.firstElementChild.innerHTML = e), n
                );
              },
              listen: function () {
                return n.__gui.listen(n), n;
              },
              remove: function () {
                return n.__gui.remove(n), n;
              },
            }),
            n instanceof oc)
          ) {
            var i = new sc(n.object, n.property, {
              min: n.__min,
              max: n.__max,
              step: n.__step,
            });
            Dl.each(
              [
                "updateDisplay",
                "onChange",
                "onFinishChange",
                "step",
                "min",
                "max",
              ],
              function (e) {
                var t = n[e],
                  r = i[e];
                n[e] = i[e] = function () {
                  var e = Array.prototype.slice.call(arguments);
                  return r.apply(i, e), t.apply(n, e);
                };
              }
            ),
              $l.addClass(t, "has-slider"),
              n.domElement.insertBefore(
                i.domElement,
                n.domElement.firstElementChild
              );
          } else if (n instanceof sc) {
            var r = function (t) {
              if (Dl.isNumber(n.__min) && Dl.isNumber(n.__max)) {
                var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                  r = n.__gui.__listening.indexOf(n) > -1;
                n.remove();
                var s = Lc(e, n.object, n.property, {
                  before: n.__li.nextElementSibling,
                  factoryArgs: [n.__min, n.__max, n.__step],
                });
                return s.name(i), r && s.listen(), s;
              }
              return t;
            };
            (n.min = Dl.compose(r, n.min)), (n.max = Dl.compose(r, n.max));
          } else
            n instanceof ec
              ? ($l.bind(t, "click", function () {
                  $l.fakeEvent(n.__checkbox, "click");
                }),
                $l.bind(n.__checkbox, "click", function (e) {
                  e.stopPropagation();
                }))
              : n instanceof lc
              ? ($l.bind(t, "click", function () {
                  $l.fakeEvent(n.__button, "click");
                }),
                $l.bind(t, "mouseover", function () {
                  $l.addClass(n.__button, "hover");
                }),
                $l.bind(t, "mouseout", function () {
                  $l.removeClass(n.__button, "hover");
                }))
              : n instanceof cc &&
                ($l.addClass(t, "color"),
                (n.updateDisplay = Dl.compose(function (e) {
                  return (t.style.borderLeftColor = n.__color.toString()), e;
                }, n.updateDisplay)),
                n.updateDisplay());
          n.setValue = Dl.compose(function (t) {
            return (
              e.getRoot().__preset_select &&
                n.isModified() &&
                Ec(e.getRoot(), !0),
              t
            );
          }, n.setValue);
        })(e, l, r),
        e.__controllers.push(r),
        r
      );
    }
    function Rc(e, t) {
      return document.location.href + "." + t;
    }
    function Cc(e, t, n) {
      var i = document.createElement("option");
      (i.innerHTML = t),
        (i.value = t),
        e.__preset_select.appendChild(i),
        n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1);
    }
    function Pc(e, t) {
      t.style.display = e.useLocalStorage ? "block" : "none";
    }
    function Ic(e) {
      var t = (e.__save_row = document.createElement("li"));
      $l.addClass(e.domElement, "has-save"),
        e.__ul.insertBefore(t, e.__ul.firstChild),
        $l.addClass(t, "save-row");
      var n = document.createElement("span");
      (n.innerHTML = "&nbsp;"), $l.addClass(n, "button gears");
      var i = document.createElement("span");
      (i.innerHTML = "Save"), $l.addClass(i, "button"), $l.addClass(i, "save");
      var r = document.createElement("span");
      (r.innerHTML = "New"),
        $l.addClass(r, "button"),
        $l.addClass(r, "save-as");
      var s = document.createElement("span");
      (s.innerHTML = "Revert"),
        $l.addClass(s, "button"),
        $l.addClass(s, "revert");
      var a = (e.__preset_select = document.createElement("select"));
      if (
        (e.load && e.load.remembered
          ? Dl.each(e.load.remembered, function (t, n) {
              Cc(e, n, n === e.preset);
            })
          : Cc(e, "Default", !1),
        $l.bind(a, "change", function () {
          for (var t = 0; t < e.__preset_select.length; t++)
            e.__preset_select[t].innerHTML = e.__preset_select[t].value;
          e.preset = this.value;
        }),
        t.appendChild(a),
        t.appendChild(n),
        t.appendChild(i),
        t.appendChild(r),
        t.appendChild(s),
        vc)
      ) {
        var o = document.getElementById("dg-local-explain"),
          l = document.getElementById("dg-local-storage");
        (document.getElementById("dg-save-locally").style.display = "block"),
          "true" === localStorage.getItem(Rc(0, "isLocal")) &&
            l.setAttribute("checked", "checked"),
          Pc(e, o),
          $l.bind(l, "change", function () {
            (e.useLocalStorage = !e.useLocalStorage), Pc(e, o);
          });
      }
      var c = document.getElementById("dg-new-constructor");
      $l.bind(c, "keydown", function (e) {
        !e.metaKey || (67 !== e.which && 67 !== e.keyCode) || _c.hide();
      }),
        $l.bind(n, "click", function () {
          (c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2)),
            _c.show(),
            c.focus(),
            c.select();
        }),
        $l.bind(i, "click", function () {
          e.save();
        }),
        $l.bind(r, "click", function () {
          var t = prompt("Enter a new preset name.");
          t && e.saveAs(t);
        }),
        $l.bind(s, "click", function () {
          e.revert();
        });
    }
    function Dc(e) {
      var t = void 0;
      function n(n) {
        return (
          n.preventDefault(),
          (e.width += t - n.clientX),
          e.onResize(),
          (t = n.clientX),
          !1
        );
      }
      function i() {
        $l.removeClass(e.__closeButton, Mc.CLASS_DRAG),
          $l.unbind(window, "mousemove", n),
          $l.unbind(window, "mouseup", i);
      }
      function r(r) {
        return (
          r.preventDefault(),
          (t = r.clientX),
          $l.addClass(e.__closeButton, Mc.CLASS_DRAG),
          $l.bind(window, "mousemove", n),
          $l.bind(window, "mouseup", i),
          !1
        );
      }
      (e.__resize_handle = document.createElement("div")),
        Dl.extend(e.__resize_handle.style, {
          width: "6px",
          marginLeft: "-3px",
          height: "200px",
          cursor: "ew-resize",
          position: "absolute",
        }),
        $l.bind(e.__resize_handle, "mousedown", r),
        $l.bind(e.__closeButton, "mousedown", r),
        e.domElement.insertBefore(
          e.__resize_handle,
          e.domElement.firstElementChild
        );
    }
    function Nc(e, t) {
      (e.domElement.style.width = t + "px"),
        e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"),
        e.__closeButton && (e.__closeButton.style.width = t + "px");
    }
    function Oc(e, t) {
      var n = {};
      return (
        Dl.each(e.__rememberedObjects, function (i, r) {
          var s = {},
            a = e.__rememberedObjectIndecesToControllers[r];
          Dl.each(a, function (e, n) {
            s[n] = t ? e.initialValue : e.getValue();
          }),
            (n[r] = s);
        }),
        n
      );
    }
    (Mc.toggleHide = function () {
      (bc = !bc),
        Dl.each(wc, function (e) {
          e.domElement.style.display = bc ? "none" : "";
        });
    }),
      (Mc.CLASS_AUTO_PLACE = "a"),
      (Mc.CLASS_AUTO_PLACE_CONTAINER = "ac"),
      (Mc.CLASS_MAIN = "main"),
      (Mc.CLASS_CONTROLLER_ROW = "cr"),
      (Mc.CLASS_TOO_TALL = "taller-than-window"),
      (Mc.CLASS_CLOSED = "closed"),
      (Mc.CLASS_CLOSE_BUTTON = "close-button"),
      (Mc.CLASS_CLOSE_TOP = "close-top"),
      (Mc.CLASS_CLOSE_BOTTOM = "close-bottom"),
      (Mc.CLASS_DRAG = "drag"),
      (Mc.DEFAULT_WIDTH = 245),
      (Mc.TEXT_CLOSED = "Close Controls"),
      (Mc.TEXT_OPEN = "Open Controls"),
      (Mc._keydownHandler = function (e) {
        "text" === document.activeElement.type ||
          (72 !== e.which && 72 !== e.keyCode) ||
          Mc.toggleHide();
      }),
      $l.bind(window, "keydown", Mc._keydownHandler, !1),
      Dl.extend(Mc.prototype, {
        add: function (e, t) {
          return Lc(this, e, t, {
            factoryArgs: Array.prototype.slice.call(arguments, 2),
          });
        },
        addColor: function (e, t) {
          return Lc(this, e, t, { color: !0 });
        },
        remove: function (e) {
          this.__ul.removeChild(e.__li),
            this.__controllers.splice(this.__controllers.indexOf(e), 1);
          var t = this;
          Dl.defer(function () {
            t.onResize();
          });
        },
        destroy: function () {
          if (this.parent)
            throw new Error(
              "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."
            );
          this.autoPlace && yc.removeChild(this.domElement);
          var e = this;
          Dl.each(this.__folders, function (t) {
            e.removeFolder(t);
          }),
            $l.unbind(window, "keydown", Mc._keydownHandler, !1),
            Tc(this);
        },
        addFolder: function (e) {
          if (void 0 !== this.__folders[e])
            throw new Error(
              'You already have a folder in this GUI by the name "' + e + '"'
            );
          var t = { name: e, parent: this };
          (t.autoPlace = this.autoPlace),
            this.load &&
              this.load.folders &&
              this.load.folders[e] &&
              ((t.closed = this.load.folders[e].closed),
              (t.load = this.load.folders[e]));
          var n = new Mc(t);
          this.__folders[e] = n;
          var i = Sc(this, n.domElement);
          return $l.addClass(i, "folder"), n;
        },
        removeFolder: function (e) {
          this.__ul.removeChild(e.domElement.parentElement),
            delete this.__folders[e.name],
            this.load &&
              this.load.folders &&
              this.load.folders[e.name] &&
              delete this.load.folders[e.name],
            Tc(e);
          var t = this;
          Dl.each(e.__folders, function (t) {
            e.removeFolder(t);
          }),
            Dl.defer(function () {
              t.onResize();
            });
        },
        open: function () {
          this.closed = !1;
        },
        close: function () {
          this.closed = !0;
        },
        hide: function () {
          this.domElement.style.display = "none";
        },
        show: function () {
          this.domElement.style.display = "";
        },
        onResize: function () {
          var e = this.getRoot();
          if (e.scrollable) {
            var t = $l.getOffset(e.__ul).top,
              n = 0;
            Dl.each(e.__ul.childNodes, function (t) {
              (e.autoPlace && t === e.__save_row) || (n += $l.getHeight(t));
            }),
              window.innerHeight - t - 20 < n
                ? ($l.addClass(e.domElement, Mc.CLASS_TOO_TALL),
                  (e.__ul.style.height = window.innerHeight - t - 20 + "px"))
                : ($l.removeClass(e.domElement, Mc.CLASS_TOO_TALL),
                  (e.__ul.style.height = "auto"));
          }
          e.__resize_handle &&
            Dl.defer(function () {
              e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
            }),
            e.__closeButton && (e.__closeButton.style.width = e.width + "px");
        },
        onResizeDebounced: Dl.debounce(function () {
          this.onResize();
        }, 50),
        remember: function () {
          if (
            (Dl.isUndefined(_c) && ((_c = new gc()).domElement.innerHTML = pc),
            this.parent)
          )
            throw new Error("You can only call remember on a top level GUI.");
          var e = this;
          Dl.each(Array.prototype.slice.call(arguments), function (t) {
            0 === e.__rememberedObjects.length && Ic(e),
              -1 === e.__rememberedObjects.indexOf(t) &&
                e.__rememberedObjects.push(t);
          }),
            this.autoPlace && Nc(this, this.width);
        },
        getRoot: function () {
          for (var e = this; e.parent; ) e = e.parent;
          return e;
        },
        getSaveObject: function () {
          var e = this.load;
          return (
            (e.closed = this.closed),
            this.__rememberedObjects.length > 0 &&
              ((e.preset = this.preset),
              e.remembered || (e.remembered = {}),
              (e.remembered[this.preset] = Oc(this))),
            (e.folders = {}),
            Dl.each(this.__folders, function (t, n) {
              e.folders[n] = t.getSaveObject();
            }),
            e
          );
        },
        save: function () {
          this.load.remembered || (this.load.remembered = {}),
            (this.load.remembered[this.preset] = Oc(this)),
            Ec(this, !1),
            this.saveToLocalStorageIfPossible();
        },
        saveAs: function (e) {
          this.load.remembered ||
            ((this.load.remembered = {}),
            (this.load.remembered.Default = Oc(this, !0))),
            (this.load.remembered[e] = Oc(this)),
            (this.preset = e),
            Cc(this, e, !0),
            this.saveToLocalStorageIfPossible();
        },
        revert: function (e) {
          Dl.each(
            this.__controllers,
            function (t) {
              this.getRoot().load.remembered
                ? Ac(e || this.getRoot(), t)
                : t.setValue(t.initialValue),
                t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
            },
            this
          ),
            Dl.each(this.__folders, function (e) {
              e.revert(e);
            }),
            e || Ec(this.getRoot(), !1);
        },
        listen: function (e) {
          var t = 0 === this.__listening.length;
          this.__listening.push(e),
            t &&
              (function e(t) {
                0 !== t.length &&
                  fc.call(window, function () {
                    e(t);
                  });
                Dl.each(t, function (e) {
                  e.updateDisplay();
                });
              })(this.__listening);
        },
        updateDisplay: function () {
          Dl.each(this.__controllers, function (e) {
            e.updateDisplay();
          }),
            Dl.each(this.__folders, function (e) {
              e.updateDisplay();
            });
        },
      });
    var zc = Mc;
    class Fc extends Ao {
      constructor(e) {
        super(e),
          (this.dracoLoader = null),
          (this.ktx2Loader = null),
          (this.meshoptDecoder = null),
          (this.pluginCallbacks = []),
          this.register(function (e) {
            return new Gc(e);
          }),
          this.register(function (e) {
            return new Yc(e);
          }),
          this.register(function (e) {
            return new Jc(e);
          }),
          this.register(function (e) {
            return new Vc(e);
          }),
          this.register(function (e) {
            return new Wc(e);
          }),
          this.register(function (e) {
            return new jc(e);
          }),
          this.register(function (e) {
            return new qc(e);
          }),
          this.register(function (e) {
            return new Xc(e);
          }),
          this.register(function (e) {
            return new Hc(e);
          }),
          this.register(function (e) {
            return new Zc(e);
          });
      }
      load(e, t, n, i) {
        const r = this;
        let s;
        (s =
          "" !== this.resourcePath
            ? this.resourcePath
            : "" !== this.path
            ? this.path
            : Qo.extractUrlBase(e)),
          this.manager.itemStart(e);
        const a = function (t) {
            i ? i(t) : console.error(t),
              r.manager.itemError(e),
              r.manager.itemEnd(e);
          },
          o = new Ro(this.manager);
        o.setPath(this.path),
          o.setResponseType("arraybuffer"),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                r.parse(
                  n,
                  s,
                  function (n) {
                    t(n), r.manager.itemEnd(e);
                  },
                  a
                );
              } catch (e) {
                a(e);
              }
            },
            n,
            a
          );
      }
      setDRACOLoader(e) {
        return (this.dracoLoader = e), this;
      }
      setDDSLoader() {
        throw new Error(
          'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
        );
      }
      setKTX2Loader(e) {
        return (this.ktx2Loader = e), this;
      }
      setMeshoptDecoder(e) {
        return (this.meshoptDecoder = e), this;
      }
      register(e) {
        return (
          -1 === this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.push(e),
          this
        );
      }
      unregister(e) {
        return (
          -1 !== this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
          this
        );
      }
      parse(e, t, n, i) {
        let r;
        const s = {},
          a = {};
        if ("string" == typeof e) r = e;
        else {
          if (Qo.decodeText(new Uint8Array(e, 0, 4)) === Kc) {
            try {
              s[Uc.KHR_BINARY_GLTF] = new eh(e);
            } catch (e) {
              return void (i && i(e));
            }
            r = s[Uc.KHR_BINARY_GLTF].content;
          } else r = Qo.decodeText(new Uint8Array(e));
        }
        const o = JSON.parse(r);
        if (void 0 === o.asset || o.asset.version[0] < 2)
          return void (
            i &&
            i(
              new Error(
                "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
              )
            )
          );
        const l = new Ih(o, {
          path: t || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder,
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
          const t = this.pluginCallbacks[e](l);
          (a[t.name] = t), (s[t.name] = !0);
        }
        if (o.extensionsUsed)
          for (let e = 0; e < o.extensionsUsed.length; ++e) {
            const t = o.extensionsUsed[e],
              n = o.extensionsRequired || [];
            switch (t) {
              case Uc.KHR_MATERIALS_UNLIT:
                s[t] = new kc();
                break;
              case Uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                s[t] = new rh();
                break;
              case Uc.KHR_DRACO_MESH_COMPRESSION:
                s[t] = new th(o, this.dracoLoader);
                break;
              case Uc.KHR_TEXTURE_TRANSFORM:
                s[t] = new nh();
                break;
              case Uc.KHR_MESH_QUANTIZATION:
                s[t] = new sh();
                break;
              default:
                n.indexOf(t) >= 0 &&
                  void 0 === a[t] &&
                  console.warn(
                    'THREE.GLTFLoader: Unknown extension "' + t + '".'
                  );
            }
          }
        l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
      }
      parseAsync(e, t) {
        const n = this;
        return new Promise(function (i, r) {
          n.parse(e, t, i, r);
        });
      }
    }
    function Bc() {
      let e = {};
      return {
        get: function (t) {
          return e[t];
        },
        add: function (t, n) {
          e[t] = n;
        },
        remove: function (t) {
          delete e[t];
        },
        removeAll: function () {
          e = {};
        },
      };
    }
    const Uc = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
        "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    };
    class Hc {
      constructor(e) {
        (this.parser = e),
          (this.name = Uc.KHR_LIGHTS_PUNCTUAL),
          (this.cache = { refs: {}, uses: {} });
      }
      _markDefs() {
        const e = this.parser,
          t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          i.extensions &&
            i.extensions[this.name] &&
            void 0 !== i.extensions[this.name].light &&
            e._addNodeRef(this.cache, i.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        const t = this.parser,
          n = "light:" + e;
        let i = t.cache.get(n);
        if (i) return i;
        const r = t.json,
          s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[
            e
          ];
        let a;
        const o = new st(16777215);
        void 0 !== s.color && o.fromArray(s.color);
        const l = void 0 !== s.range ? s.range : 0;
        switch (s.type) {
          case "directional":
            (a = new Xo(o)), a.target.position.set(0, 0, -1), a.add(a.target);
            break;
          case "point":
            (a = new jo(o)), (a.distance = l);
            break;
          case "spot":
            (a = new Ho(o)),
              (a.distance = l),
              (s.spot = s.spot || {}),
              (s.spot.innerConeAngle =
                void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
              (s.spot.outerConeAngle =
                void 0 !== s.spot.outerConeAngle
                  ? s.spot.outerConeAngle
                  : Math.PI / 4),
              (a.angle = s.spot.outerConeAngle),
              (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
              a.target.position.set(0, 0, -1),
              a.add(a.target);
            break;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unexpected light type: " + s.type
            );
        }
        return (
          a.position.set(0, 0, 0),
          (a.decay = 2),
          void 0 !== s.intensity && (a.intensity = s.intensity),
          (a.name = t.createUniqueName(s.name || "light_" + e)),
          (i = Promise.resolve(a)),
          t.cache.add(n, i),
          i
        );
      }
      createNodeAttachment(e) {
        const t = this,
          n = this.parser,
          i = n.json.nodes[e],
          r = ((i.extensions && i.extensions[this.name]) || {}).light;
        return void 0 === r
          ? null
          : this._loadLight(r).then(function (e) {
              return n._getNodeRef(t.cache, r, e);
            });
      }
    }
    class kc {
      constructor() {
        this.name = Uc.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return at;
      }
      extendParams(e, t, n) {
        const i = [];
        (e.color = new st(1, 1, 1)), (e.opacity = 1);
        const r = t.pbrMetallicRoughness;
        if (r) {
          if (Array.isArray(r.baseColorFactor)) {
            const t = r.baseColorFactor;
            e.color.fromArray(t), (e.opacity = t[3]);
          }
          void 0 !== r.baseColorTexture &&
            i.push(n.assignTexture(e, "map", r.baseColorTexture));
        }
        return Promise.all(i);
      }
    }
    class Gc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_CLEARCOAT);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        if (
          (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
          void 0 !== s.clearcoatTexture &&
            r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
          void 0 !== s.clearcoatRoughnessFactor &&
            (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
          void 0 !== s.clearcoatRoughnessTexture &&
            r.push(
              n.assignTexture(
                t,
                "clearcoatRoughnessMap",
                s.clearcoatRoughnessTexture
              )
            ),
          void 0 !== s.clearcoatNormalTexture &&
            (r.push(
              n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)
            ),
            void 0 !== s.clearcoatNormalTexture.scale))
        ) {
          const e = s.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new M(e, e);
        }
        return Promise.all(r);
      }
    }
    class Vc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_SHEEN);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [];
        (t.sheenColor = new st(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
        const s = i.extensions[this.name];
        return (
          void 0 !== s.sheenColorFactor &&
            t.sheenColor.fromArray(s.sheenColorFactor),
          void 0 !== s.sheenRoughnessFactor &&
            (t.sheenRoughness = s.sheenRoughnessFactor),
          void 0 !== s.sheenColorTexture &&
            r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture)),
          void 0 !== s.sheenRoughnessTexture &&
            r.push(
              n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)
            ),
          Promise.all(r)
        );
      }
    }
    class Wc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_TRANSMISSION);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        return (
          void 0 !== s.transmissionFactor &&
            (t.transmission = s.transmissionFactor),
          void 0 !== s.transmissionTexture &&
            r.push(
              n.assignTexture(t, "transmissionMap", s.transmissionTexture)
            ),
          Promise.all(r)
        );
      }
    }
    class jc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_VOLUME);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        (t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
          void 0 !== s.thicknessTexture &&
            r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
          (t.attenuationDistance = s.attenuationDistance || 0);
        const a = s.attenuationColor || [1, 1, 1];
        return (t.attenuationColor = new st(a[0], a[1], a[2])), Promise.all(r);
      }
    }
    class qc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_IOR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = n.extensions[this.name];
        return (t.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
      }
    }
    class Xc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_MATERIALS_SPECULAR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? to : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const r = [],
          s = i.extensions[this.name];
        (t.specularIntensity =
          void 0 !== s.specularFactor ? s.specularFactor : 1),
          void 0 !== s.specularTexture &&
            r.push(
              n.assignTexture(t, "specularIntensityMap", s.specularTexture)
            );
        const a = s.specularColorFactor || [1, 1, 1];
        return (
          (t.specularColor = new st(a[0], a[1], a[2])),
          void 0 !== s.specularColorTexture &&
            r.push(
              n
                .assignTexture(t, "specularColorMap", s.specularColorTexture)
                .then(function (e) {
                  e.encoding = 3001;
                })
            ),
          Promise.all(r)
        );
      }
    }
    class Yc {
      constructor(e) {
        (this.parser = e), (this.name = Uc.KHR_TEXTURE_BASISU);
      }
      loadTexture(e) {
        const t = this.parser,
          n = t.json,
          i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name]) return null;
        const r = i.extensions[this.name],
          s = n.images[r.source],
          a = t.options.ktx2Loader;
        if (!a) {
          if (
            n.extensionsRequired &&
            n.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
            );
          return null;
        }
        return t.loadTextureImage(e, s, a);
      }
    }
    class Jc {
      constructor(e) {
        (this.parser = e),
          (this.name = Uc.EXT_TEXTURE_WEBP),
          (this.isSupported = null);
      }
      loadTexture(e) {
        const t = this.name,
          n = this.parser,
          i = n.json,
          r = i.textures[e];
        if (!r.extensions || !r.extensions[t]) return null;
        const s = r.extensions[t],
          a = i.images[s.source];
        let o = n.textureLoader;
        if (a.uri) {
          const e = n.options.manager.getHandler(a.uri);
          null !== e && (o = e);
        }
        return this.detectSupport().then(function (r) {
          if (r) return n.loadTextureImage(e, a, o);
          if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
            throw new Error(
              "THREE.GLTFLoader: WebP required by asset but unsupported."
            );
          return n.loadTexture(e);
        });
      }
      detectSupport() {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              const t = new Image();
              (t.src =
                "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                (t.onload = t.onerror =
                  function () {
                    e(1 === t.height);
                  });
            })),
          this.isSupported
        );
      }
    }
    class Zc {
      constructor(e) {
        (this.name = Uc.EXT_MESHOPT_COMPRESSION), (this.parser = e);
      }
      loadBufferView(e) {
        const t = this.parser.json,
          n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
          const e = n.extensions[this.name],
            i = this.parser.getDependency("buffer", e.buffer),
            r = this.parser.options.meshoptDecoder;
          if (!r || !r.supported) {
            if (
              t.extensionsRequired &&
              t.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
              );
            return null;
          }
          return Promise.all([i, r.ready]).then(function (t) {
            const n = e.byteOffset || 0,
              i = e.byteLength || 0,
              s = e.count,
              a = e.byteStride,
              o = new ArrayBuffer(s * a),
              l = new Uint8Array(t[0], n, i);
            return (
              r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter),
              o
            );
          });
        }
        return null;
      }
    }
    const Kc = "glTF",
      Qc = 1313821514,
      $c = 5130562;
    class eh {
      constructor(e) {
        (this.name = Uc.KHR_BINARY_GLTF),
          (this.content = null),
          (this.body = null);
        const t = new DataView(e, 0, 12);
        if (
          ((this.header = {
            magic: Qo.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0),
          }),
          this.header.magic !== Kc)
        )
          throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
          throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - 12,
          i = new DataView(e, 12);
        let r = 0;
        for (; r < n; ) {
          const t = i.getUint32(r, !0);
          r += 4;
          const n = i.getUint32(r, !0);
          if (((r += 4), n === Qc)) {
            const n = new Uint8Array(e, 12 + r, t);
            this.content = Qo.decodeText(n);
          } else if (n === $c) {
            const n = 12 + r;
            this.body = e.slice(n, n + t);
          }
          r += t;
        }
        if (null === this.content)
          throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
    class th {
      constructor(e, t) {
        if (!t)
          throw new Error(
            "THREE.GLTFLoader: No DRACOLoader instance provided."
          );
        (this.name = Uc.KHR_DRACO_MESH_COMPRESSION),
          (this.json = e),
          (this.dracoLoader = t),
          this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        const n = this.json,
          i = this.dracoLoader,
          r = e.extensions[this.name].bufferView,
          s = e.extensions[this.name].attributes,
          a = {},
          o = {},
          l = {};
        for (const e in s) {
          const t = yh[e] || e.toLowerCase();
          a[t] = s[e];
        }
        for (const t in e.attributes) {
          const i = yh[t] || t.toLowerCase();
          if (void 0 !== s[t]) {
            const r = n.accessors[e.attributes[t]],
              s = gh[r.componentType];
            (l[i] = s), (o[i] = !0 === r.normalized);
          }
        }
        return t.getDependency("bufferView", r).then(function (e) {
          return new Promise(function (t) {
            i.decodeDracoFile(
              e,
              function (e) {
                for (const t in e.attributes) {
                  const n = e.attributes[t],
                    i = o[t];
                  void 0 !== i && (n.normalized = i);
                }
                t(e);
              },
              a,
              l
            );
          });
        });
      }
    }
    class nh {
      constructor() {
        this.name = Uc.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (
          void 0 !== t.texCoord &&
            console.warn(
              'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
            ),
          (void 0 === t.offset &&
            void 0 === t.rotation &&
            void 0 === t.scale) ||
            ((e = e.clone()),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
            (e.needsUpdate = !0)),
          e
        );
      }
    }
    class ih extends eo {
      constructor(e) {
        super(), (this.isGLTFSpecularGlossinessMaterial = !0);
        const t = [
            "#ifdef USE_SPECULARMAP",
            "\tuniform sampler2D specularMap;",
            "#endif",
          ].join("\n"),
          n = [
            "#ifdef USE_GLOSSINESSMAP",
            "\tuniform sampler2D glossinessMap;",
            "#endif",
          ].join("\n"),
          i = [
            "vec3 specularFactor = specular;",
            "#ifdef USE_SPECULARMAP",
            "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
            "\ttexelSpecular = sRGBToLinear( texelSpecular );",
            "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tspecularFactor *= texelSpecular.rgb;",
            "#endif",
          ].join("\n"),
          r = [
            "float glossinessFactor = glossiness;",
            "#ifdef USE_GLOSSINESSMAP",
            "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
            "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tglossinessFactor *= texelGlossiness.a;",
            "#endif",
          ].join("\n"),
          s = [
            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
            "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.specularColor = specularFactor;",
          ].join("\n"),
          a = {
            specular: { value: new st().setHex(16777215) },
            glossiness: { value: 1 },
            specularMap: { value: null },
            glossinessMap: { value: null },
          };
        (this._extraUniforms = a),
          (this.onBeforeCompile = function (e) {
            for (const t in a) e.uniforms[t] = a[t];
            e.fragmentShader = e.fragmentShader
              .replace("uniform float roughness;", "uniform vec3 specular;")
              .replace("uniform float metalness;", "uniform float glossiness;")
              .replace("#include <roughnessmap_pars_fragment>", t)
              .replace("#include <metalnessmap_pars_fragment>", n)
              .replace("#include <roughnessmap_fragment>", i)
              .replace("#include <metalnessmap_fragment>", r)
              .replace("#include <lights_physical_fragment>", s);
          }),
          Object.defineProperties(this, {
            specular: {
              get: function () {
                return a.specular.value;
              },
              set: function (e) {
                a.specular.value = e;
              },
            },
            specularMap: {
              get: function () {
                return a.specularMap.value;
              },
              set: function (e) {
                (a.specularMap.value = e),
                  e
                    ? (this.defines.USE_SPECULARMAP = "")
                    : delete this.defines.USE_SPECULARMAP;
              },
            },
            glossiness: {
              get: function () {
                return a.glossiness.value;
              },
              set: function (e) {
                a.glossiness.value = e;
              },
            },
            glossinessMap: {
              get: function () {
                return a.glossinessMap.value;
              },
              set: function (e) {
                (a.glossinessMap.value = e),
                  e
                    ? ((this.defines.USE_GLOSSINESSMAP = ""),
                      (this.defines.USE_UV = ""))
                    : (delete this.defines.USE_GLOSSINESSMAP,
                      delete this.defines.USE_UV);
              },
            },
          }),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.specularMap = e.specularMap),
          this.specular.copy(e.specular),
          (this.glossinessMap = e.glossinessMap),
          (this.glossiness = e.glossiness),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this
        );
      }
    }
    class rh {
      constructor() {
        (this.name = Uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
          (this.specularGlossinessParams = [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity",
            "refractionRatio",
          ]);
      }
      getMaterialType() {
        return ih;
      }
      extendParams(e, t, n) {
        const i = t.extensions[this.name];
        (e.color = new st(1, 1, 1)), (e.opacity = 1);
        const r = [];
        if (Array.isArray(i.diffuseFactor)) {
          const t = i.diffuseFactor;
          e.color.fromArray(t), (e.opacity = t[3]);
        }
        if (
          (void 0 !== i.diffuseTexture &&
            r.push(n.assignTexture(e, "map", i.diffuseTexture)),
          (e.emissive = new st(0, 0, 0)),
          (e.glossiness =
            void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
          (e.specular = new st(1, 1, 1)),
          Array.isArray(i.specularFactor) &&
            e.specular.fromArray(i.specularFactor),
          void 0 !== i.specularGlossinessTexture)
        ) {
          const t = i.specularGlossinessTexture;
          r.push(n.assignTexture(e, "glossinessMap", t)),
            r.push(n.assignTexture(e, "specularMap", t));
        }
        return Promise.all(r);
      }
      createMaterial(e) {
        const t = new ih(e);
        return (
          (t.fog = !0),
          (t.color = e.color),
          (t.map = void 0 === e.map ? null : e.map),
          (t.lightMap = null),
          (t.lightMapIntensity = 1),
          (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
          (t.aoMapIntensity = 1),
          (t.emissive = e.emissive),
          (t.emissiveIntensity = 1),
          (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
          (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
          (t.bumpScale = 1),
          (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
          (t.normalMapType = 0),
          e.normalScale && (t.normalScale = e.normalScale),
          (t.displacementMap = null),
          (t.displacementScale = 1),
          (t.displacementBias = 0),
          (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
          (t.specular = e.specular),
          (t.glossinessMap =
            void 0 === e.glossinessMap ? null : e.glossinessMap),
          (t.glossiness = e.glossiness),
          (t.alphaMap = null),
          (t.envMap = void 0 === e.envMap ? null : e.envMap),
          (t.envMapIntensity = 1),
          (t.refractionRatio = 0.98),
          t
        );
      }
    }
    class sh {
      constructor() {
        this.name = Uc.KHR_MESH_QUANTIZATION;
      }
    }
    class ah extends co {
      constructor(e, t, n, i) {
        super(e, t, n, i);
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = e * i * 3 + i;
        for (let e = 0; e !== i; e++) t[e] = n[r + e];
        return t;
      }
    }
    (ah.prototype.beforeStart_ = ah.prototype.copySampleValue_),
      (ah.prototype.afterEnd_ = ah.prototype.copySampleValue_),
      (ah.prototype.interpolate_ = function (e, t, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          a = this.valueSize,
          o = 2 * a,
          l = 3 * a,
          c = i - t,
          h = (n - t) / c,
          u = h * h,
          d = u * h,
          p = e * l,
          m = p - l,
          f = -2 * d + 3 * u,
          g = d - u,
          v = 1 - f,
          _ = g - u + h;
        for (let e = 0; e !== a; e++) {
          const t = s[m + e + a],
            n = s[m + e + o] * c,
            i = s[p + e + a],
            l = s[p + e] * c;
          r[e] = v * t + _ * n + f * i + g * l;
        }
        return r;
      });
    const oh = new z();
    class lh extends ah {
      interpolate_(e, t, n, i) {
        const r = super.interpolate_(e, t, n, i);
        return oh.fromArray(r).normalize().toArray(r), r;
      }
    }
    const ch = 0,
      hh = 1,
      uh = 2,
      dh = 3,
      ph = 4,
      mh = 5,
      fh = 6,
      gh = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      },
      vh = {
        9728: 1003,
        9729: 1006,
        9984: 1004,
        9985: 1007,
        9986: 1005,
        9987: 1008,
      },
      _h = { 33071: 1001, 33648: 1002, 10497: 1e3 },
      xh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      yh = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex",
      },
      bh = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences",
      },
      wh = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
      Mh = "OPAQUE",
      Sh = "MASK",
      Th = "BLEND";
    function Eh(e, t, n) {
      for (const i in n.extensions)
        void 0 === e[i] &&
          ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
          (t.userData.gltfExtensions[i] = n.extensions[i]));
    }
    function Ah(e, t) {
      void 0 !== t.extras &&
        ("object" == typeof t.extras
          ? Object.assign(e.userData, t.extras)
          : console.warn(
              "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
            ));
    }
    function Lh(e, t) {
      if ((e.updateMorphTargets(), void 0 !== t.weights))
        for (let n = 0, i = t.weights.length; n < i; n++)
          e.morphTargetInfluences[n] = t.weights[n];
      if (t.extras && Array.isArray(t.extras.targetNames)) {
        const n = t.extras.targetNames;
        if (e.morphTargetInfluences.length === n.length) {
          e.morphTargetDictionary = {};
          for (let t = 0, i = n.length; t < i; t++)
            e.morphTargetDictionary[n[t]] = t;
        } else
          console.warn(
            "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
          );
      }
    }
    function Rh(e) {
      const t = e.extensions && e.extensions[Uc.KHR_DRACO_MESH_COMPRESSION];
      let n;
      return (
        (n = t
          ? "draco:" + t.bufferView + ":" + t.indices + ":" + Ch(t.attributes)
          : e.indices + ":" + Ch(e.attributes) + ":" + e.mode),
        n
      );
    }
    function Ch(e) {
      let t = "";
      const n = Object.keys(e).sort();
      for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
      return t;
    }
    function Ph(e) {
      switch (e) {
        case Int8Array:
          return 1 / 127;
        case Uint8Array:
          return 1 / 255;
        case Int16Array:
          return 1 / 32767;
        case Uint16Array:
          return 1 / 65535;
        default:
          throw new Error(
            "THREE.GLTFLoader: Unsupported normalized accessor component type."
          );
      }
    }
    class Ih {
      constructor(e = {}, t = {}) {
        (this.json = e),
          (this.extensions = {}),
          (this.plugins = {}),
          (this.options = t),
          (this.cache = new Bc()),
          (this.associations = new Map()),
          (this.primitiveCache = {}),
          (this.meshCache = { refs: {}, uses: {} }),
          (this.cameraCache = { refs: {}, uses: {} }),
          (this.lightCache = { refs: {}, uses: {} }),
          (this.textureCache = {}),
          (this.nodeNamesUsed = {}),
          "undefined" != typeof createImageBitmap &&
          !1 === /Firefox/.test(navigator.userAgent)
            ? (this.textureLoader = new el(this.options.manager))
            : (this.textureLoader = new Io(this.options.manager)),
          this.textureLoader.setCrossOrigin(this.options.crossOrigin),
          this.textureLoader.setRequestHeader(this.options.requestHeader),
          (this.fileLoader = new Ro(this.options.manager)),
          this.fileLoader.setResponseType("arraybuffer"),
          "use-credentials" === this.options.crossOrigin &&
            this.fileLoader.setWithCredentials(!0);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        const n = this,
          i = this.json,
          r = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (e) {
            return e._markDefs && e._markDefs();
          }),
          Promise.all(
            this._invokeAll(function (e) {
              return e.beforeRoot && e.beforeRoot();
            })
          )
            .then(function () {
              return Promise.all([
                n.getDependencies("scene"),
                n.getDependencies("animation"),
                n.getDependencies("camera"),
              ]);
            })
            .then(function (t) {
              const s = {
                scene: t[0][i.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: i.asset,
                parser: n,
                userData: {},
              };
              Eh(r, s, i),
                Ah(s, i),
                Promise.all(
                  n._invokeAll(function (e) {
                    return e.afterRoot && e.afterRoot(s);
                  })
                ).then(function () {
                  e(s);
                });
            })
            .catch(t);
      }
      _markDefs() {
        const e = this.json.nodes || [],
          t = this.json.skins || [],
          n = this.json.meshes || [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n].joints;
          for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
        }
        for (let t = 0, i = e.length; t < i; t++) {
          const i = e[t];
          void 0 !== i.mesh &&
            (this._addNodeRef(this.meshCache, i.mesh),
            void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
            void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
        }
      }
      _addNodeRef(e, t) {
        void 0 !== t &&
          (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1) return n;
        const i = n.clone(),
          r = (e, t) => {
            const n = this.associations.get(e);
            null != n && this.associations.set(t, n);
            for (const [n, i] of e.children.entries()) r(i, t.children[n]);
          };
        return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
      }
      _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
          const i = e(t[n]);
          if (i) return i;
        }
        return null;
      }
      _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
          const r = e(t[i]);
          r && n.push(r);
        }
        return n;
      }
      getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
          switch (e) {
            case "scene":
              i = this.loadScene(t);
              break;
            case "node":
              i = this.loadNode(t);
              break;
            case "mesh":
              i = this._invokeOne(function (e) {
                return e.loadMesh && e.loadMesh(t);
              });
              break;
            case "accessor":
              i = this.loadAccessor(t);
              break;
            case "bufferView":
              i = this._invokeOne(function (e) {
                return e.loadBufferView && e.loadBufferView(t);
              });
              break;
            case "buffer":
              i = this.loadBuffer(t);
              break;
            case "material":
              i = this._invokeOne(function (e) {
                return e.loadMaterial && e.loadMaterial(t);
              });
              break;
            case "texture":
              i = this._invokeOne(function (e) {
                return e.loadTexture && e.loadTexture(t);
              });
              break;
            case "skin":
              i = this.loadSkin(t);
              break;
            case "animation":
              i = this.loadAnimation(t);
              break;
            case "camera":
              i = this.loadCamera(t);
              break;
            default:
              throw new Error("Unknown type: " + e);
          }
          this.cache.add(n, i);
        }
        return i;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          const n = this,
            i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
          (t = Promise.all(
            i.map(function (t, i) {
              return n.getDependency(e, i);
            })
          )),
            this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        const t = this.json.buffers[e],
          n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
          throw new Error(
            "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
          );
        if (void 0 === t.uri && 0 === e)
          return Promise.resolve(this.extensions[Uc.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function (e, r) {
          n.load(Qo.resolveURL(t.uri, i.path), e, void 0, function () {
            r(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
              )
            );
          });
        });
      }
      loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (e) {
          const n = t.byteLength || 0,
            i = t.byteOffset || 0;
          return e.slice(i, i + n);
        });
      }
      loadAccessor(e) {
        const t = this,
          n = this.json,
          i = this.json.accessors[e];
        if (void 0 === i.bufferView && void 0 === i.sparse)
          return Promise.resolve(null);
        const r = [];
        return (
          void 0 !== i.bufferView
            ? r.push(this.getDependency("bufferView", i.bufferView))
            : r.push(null),
          void 0 !== i.sparse &&
            (r.push(
              this.getDependency("bufferView", i.sparse.indices.bufferView)
            ),
            r.push(
              this.getDependency("bufferView", i.sparse.values.bufferView)
            )),
          Promise.all(r).then(function (e) {
            const r = e[0],
              s = xh[i.type],
              a = gh[i.componentType],
              o = a.BYTES_PER_ELEMENT,
              l = o * s,
              c = i.byteOffset || 0,
              h =
                void 0 !== i.bufferView
                  ? n.bufferViews[i.bufferView].byteStride
                  : void 0,
              u = !0 === i.normalized;
            let d, p;
            if (h && h !== l) {
              const e = Math.floor(c / h),
                n =
                  "InterleavedBuffer:" +
                  i.bufferView +
                  ":" +
                  i.componentType +
                  ":" +
                  e +
                  ":" +
                  i.count;
              let l = t.cache.get(n);
              l ||
                ((d = new a(r, e * h, (i.count * h) / o)),
                (l = new Kr(d, h / o)),
                t.cache.add(n, l)),
                (p = new $r(l, s, (c % h) / o, u));
            } else (d = null === r ? new a(i.count * s) : new a(r, c, i.count * s)), (p = new ct(d, s, u));
            if (void 0 !== i.sparse) {
              const t = xh.SCALAR,
                n = gh[i.sparse.indices.componentType],
                o = i.sparse.indices.byteOffset || 0,
                l = i.sparse.values.byteOffset || 0,
                c = new n(e[1], o, i.sparse.count * t),
                h = new a(e[2], l, i.sparse.count * s);
              null !== r &&
                (p = new ct(p.array.slice(), p.itemSize, p.normalized));
              for (let e = 0, t = c.length; e < t; e++) {
                const t = c[e];
                if (
                  (p.setX(t, h[e * s]),
                  s >= 2 && p.setY(t, h[e * s + 1]),
                  s >= 3 && p.setZ(t, h[e * s + 2]),
                  s >= 4 && p.setW(t, h[e * s + 3]),
                  s >= 5)
                )
                  throw new Error(
                    "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                  );
              }
            }
            return p;
          })
        );
      }
      loadTexture(e) {
        const t = this.json,
          n = this.options,
          i = t.textures[e],
          r = t.images[i.source];
        let s = this.textureLoader;
        if (r.uri) {
          const e = n.manager.getHandler(r.uri);
          null !== e && (s = e);
        }
        return this.loadTextureImage(e, r, s);
      }
      loadTextureImage(e, t, n) {
        const i = this,
          r = this.json,
          s = this.options,
          a = r.textures[e],
          o = (t.uri || t.bufferView) + ":" + a.sampler;
        if (this.textureCache[o]) return this.textureCache[o];
        const l = self.URL || self.webkitURL;
        let c = t.uri || "",
          h = !1;
        if (void 0 !== t.bufferView)
          c = i.getDependency("bufferView", t.bufferView).then(function (e) {
            h = !0;
            const n = new Blob([e], { type: t.mimeType });
            return (c = l.createObjectURL(n)), c;
          });
        else if (void 0 === t.uri)
          throw new Error(
            "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
          );
        const u = Promise.resolve(c)
          .then(function (e) {
            return new Promise(function (t, i) {
              let r = t;
              !0 === n.isImageBitmapLoader &&
                (r = function (e) {
                  const n = new P(e);
                  (n.needsUpdate = !0), t(n);
                }),
                n.load(Qo.resolveURL(e, s.path), r, void 0, i);
            });
          })
          .then(function (t) {
            !0 === h && l.revokeObjectURL(c),
              (t.flipY = !1),
              a.name && (t.name = a.name);
            const n = (r.samplers || {})[a.sampler] || {};
            return (
              (t.magFilter = vh[n.magFilter] || 1006),
              (t.minFilter = vh[n.minFilter] || 1008),
              (t.wrapS = _h[n.wrapS] || 1e3),
              (t.wrapT = _h[n.wrapT] || 1e3),
              i.associations.set(t, { textures: e }),
              t
            );
          })
          .catch(function () {
            return (
              console.error("THREE.GLTFLoader: Couldn't load texture", c), null
            );
          });
        return (this.textureCache[o] = u), u;
      }
      assignTexture(e, t, n) {
        const i = this;
        return this.getDependency("texture", n.index).then(function (r) {
          if (
            (void 0 === n.texCoord ||
              0 == n.texCoord ||
              ("aoMap" === t && 1 == n.texCoord) ||
              console.warn(
                "THREE.GLTFLoader: Custom UV set " +
                  n.texCoord +
                  " for texture " +
                  t +
                  " not yet supported."
              ),
            i.extensions[Uc.KHR_TEXTURE_TRANSFORM])
          ) {
            const e =
              void 0 !== n.extensions
                ? n.extensions[Uc.KHR_TEXTURE_TRANSFORM]
                : void 0;
            if (e) {
              const t = i.associations.get(r);
              (r = i.extensions[Uc.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)),
                i.associations.set(r, t);
            }
          }
          return (e[t] = r), r;
        });
      }
      assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = void 0 === t.attributes.tangent,
          r = void 0 !== t.attributes.color,
          s = void 0 === t.attributes.normal;
        if (e.isPoints) {
          const e = "PointsMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new Ws()),
            Qe.prototype.copy.call(t, n),
            t.color.copy(n.color),
            (t.map = n.map),
            (t.sizeAttenuation = !1),
            this.cache.add(e, t)),
            (n = t);
        } else if (e.isLine) {
          const e = "LineBasicMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new Ds()),
            Qe.prototype.copy.call(t, n),
            t.color.copy(n.color),
            this.cache.add(e, t)),
            (n = t);
        }
        if (i || r || s) {
          let e = "ClonedMaterial:" + n.uuid + ":";
          n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
            i && (e += "derivative-tangents:"),
            r && (e += "vertex-colors:"),
            s && (e += "flat-shading:");
          let t = this.cache.get(e);
          t ||
            ((t = n.clone()),
            r && (t.vertexColors = !0),
            s && (t.flatShading = !0),
            i &&
              (t.normalScale && (t.normalScale.y *= -1),
              t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
            this.cache.add(e, t),
            this.associations.set(t, this.associations.get(n))),
            (n = t);
        }
        n.aoMap &&
          void 0 === t.attributes.uv2 &&
          void 0 !== t.attributes.uv &&
          t.setAttribute("uv2", t.attributes.uv),
          (e.material = n);
      }
      getMaterialType() {
        return eo;
      }
      loadMaterial(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          r = n.materials[e];
        let s;
        const a = {},
          o = r.extensions || {},
          l = [];
        if (o[Uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          const e = i[Uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
        } else if (o[Uc.KHR_MATERIALS_UNLIT]) {
          const e = i[Uc.KHR_MATERIALS_UNLIT];
          (s = e.getMaterialType()), l.push(e.extendParams(a, r, t));
        } else {
          const n = r.pbrMetallicRoughness || {};
          if (
            ((a.color = new st(1, 1, 1)),
            (a.opacity = 1),
            Array.isArray(n.baseColorFactor))
          ) {
            const e = n.baseColorFactor;
            a.color.fromArray(e), (a.opacity = e[3]);
          }
          void 0 !== n.baseColorTexture &&
            l.push(t.assignTexture(a, "map", n.baseColorTexture)),
            (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
            (a.roughness =
              void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
            void 0 !== n.metallicRoughnessTexture &&
              (l.push(
                t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
              ),
              l.push(
                t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
              )),
            (s = this._invokeOne(function (t) {
              return t.getMaterialType && t.getMaterialType(e);
            })),
            l.push(
              Promise.all(
                this._invokeAll(function (t) {
                  return t.extendMaterialParams && t.extendMaterialParams(e, a);
                })
              )
            );
        }
        !0 === r.doubleSided && (a.side = 2);
        const c = r.alphaMode || Mh;
        if (
          (c === Th
            ? ((a.transparent = !0), (a.depthWrite = !1))
            : ((a.format = 1022),
              (a.transparent = !1),
              c === Sh &&
                (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
          void 0 !== r.normalTexture &&
            s !== at &&
            (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
            (a.normalScale = new M(1, 1)),
            void 0 !== r.normalTexture.scale))
        ) {
          const e = r.normalTexture.scale;
          a.normalScale.set(e, e);
        }
        return (
          void 0 !== r.occlusionTexture &&
            s !== at &&
            (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
            void 0 !== r.occlusionTexture.strength &&
              (a.aoMapIntensity = r.occlusionTexture.strength)),
          void 0 !== r.emissiveFactor &&
            s !== at &&
            (a.emissive = new st().fromArray(r.emissiveFactor)),
          void 0 !== r.emissiveTexture &&
            s !== at &&
            l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)),
          Promise.all(l).then(function () {
            let n;
            return (
              (n =
                s === ih
                  ? i[Uc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(
                      a
                    )
                  : new s(a)),
              r.name && (n.name = r.name),
              n.map && (n.map.encoding = 3001),
              n.emissiveMap && (n.emissiveMap.encoding = 3001),
              Ah(n, r),
              t.associations.set(n, { materials: e }),
              r.extensions && Eh(i, n, r),
              n
            );
          })
        );
      }
      createUniqueName(e) {
        const t = ml.sanitizeNodeName(e || "");
        let n = t;
        for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
        return (this.nodeNamesUsed[n] = !0), n;
      }
      loadGeometries(e) {
        const t = this,
          n = this.extensions,
          i = this.primitiveCache;
        function r(e) {
          return n[Uc.KHR_DRACO_MESH_COMPRESSION]
            .decodePrimitive(e, t)
            .then(function (n) {
              return Nh(n, e, t);
            });
        }
        const s = [];
        for (let n = 0, a = e.length; n < a; n++) {
          const a = e[n],
            o = Rh(a),
            l = i[o];
          if (l) s.push(l.promise);
          else {
            let e;
            (e =
              a.extensions && a.extensions[Uc.KHR_DRACO_MESH_COMPRESSION]
                ? r(a)
                : Nh(new yt(), a, t)),
              (i[o] = { primitive: a, promise: e }),
              s.push(e);
          }
        }
        return Promise.all(s);
      }
      loadMesh(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          r = n.meshes[e],
          s = r.primitives,
          a = [];
        for (let e = 0, t = s.length; e < t; e++) {
          const t =
            void 0 === s[e].material
              ? (void 0 === (o = this.cache).DefaultMaterial &&
                  (o.DefaultMaterial = new eo({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0,
                  })),
                o.DefaultMaterial)
              : this.getDependency("material", s[e].material);
          a.push(t);
        }
        var o;
        return (
          a.push(t.loadGeometries(s)),
          Promise.all(a).then(function (n) {
            const a = n.slice(0, n.length - 1),
              o = n[n.length - 1],
              l = [];
            for (let n = 0, c = o.length; n < c; n++) {
              const c = o[n],
                h = s[n];
              let u;
              const d = a[n];
              if (
                h.mode === ph ||
                h.mode === mh ||
                h.mode === fh ||
                void 0 === h.mode
              )
                (u = !0 === r.isSkinnedMesh ? new bs(c, d) : new Bt(c, d)),
                  !0 !== u.isSkinnedMesh ||
                    u.geometry.attributes.skinWeight.normalized ||
                    u.normalizeSkinWeights(),
                  h.mode === mh
                    ? (u.geometry = Oh(u.geometry, 1))
                    : h.mode === fh && (u.geometry = Oh(u.geometry, 2));
              else if (h.mode === hh) u = new Gs(c, d);
              else if (h.mode === dh) u = new Us(c, d);
              else if (h.mode === uh) u = new Vs(c, d);
              else {
                if (h.mode !== ch)
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
                  );
                u = new Js(c, d);
              }
              Object.keys(u.geometry.morphAttributes).length > 0 && Lh(u, r),
                (u.name = t.createUniqueName(r.name || "mesh_" + e)),
                Ah(u, r),
                h.extensions && Eh(i, u, h),
                t.assignFinalMaterial(u),
                l.push(u);
            }
            for (let n = 0, i = l.length; n < i; n++)
              t.associations.set(l[n], { meshes: e, primitives: n });
            if (1 === l.length) return l[0];
            const c = new kr();
            t.associations.set(c, { meshes: e });
            for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
            return c;
          })
        );
      }
      loadCamera(e) {
        let t;
        const n = this.json.cameras[e],
          i = n[n.type];
        if (i)
          return (
            "perspective" === n.type
              ? (t = new qt(
                  w.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : "orthographic" === n.type &&
                (t = new gn(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            Ah(t, n),
            Promise.resolve(t)
          );
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
      }
      loadSkin(e) {
        const t = this.json.skins[e],
          n = { joints: t.joints };
        return void 0 === t.inverseBindMatrices
          ? Promise.resolve(n)
          : this.getDependency("accessor", t.inverseBindMatrices).then(
              function (e) {
                return (n.inverseBindMatrices = e), n;
              }
            );
      }
      loadAnimation(e) {
        const t = this.json.animations[e],
          n = [],
          i = [],
          r = [],
          s = [],
          a = [];
        for (let e = 0, o = t.channels.length; e < o; e++) {
          const o = t.channels[e],
            l = t.samplers[o.sampler],
            c = o.target,
            h = void 0 !== c.node ? c.node : c.id,
            u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
          n.push(this.getDependency("node", h)),
            i.push(this.getDependency("accessor", u)),
            r.push(this.getDependency("accessor", d)),
            s.push(l),
            a.push(c);
        }
        return Promise.all([
          Promise.all(n),
          Promise.all(i),
          Promise.all(r),
          Promise.all(s),
          Promise.all(a),
        ]).then(function (n) {
          const i = n[0],
            r = n[1],
            s = n[2],
            a = n[3],
            o = n[4],
            l = [];
          for (let e = 0, t = i.length; e < t; e++) {
            const t = i[e],
              n = r[e],
              c = s[e],
              h = a[e],
              u = o[e];
            if (void 0 === t) continue;
            let d;
            switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), bh[u.path])) {
              case bh.weights:
                d = vo;
                break;
              case bh.rotation:
                d = xo;
                break;
              case bh.position:
              case bh.scale:
              default:
                d = bo;
            }
            const p = t.name ? t.name : t.uuid,
              m = void 0 !== h.interpolation ? wh[h.interpolation] : 2301,
              f = [];
            bh[u.path] === bh.weights
              ? t.traverse(function (e) {
                  e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid);
                })
              : f.push(p);
            let g = c.array;
            if (c.normalized) {
              const e = Ph(g.constructor),
                t = new Float32Array(g.length);
              for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
              g = t;
            }
            for (let e = 0, t = f.length; e < t; e++) {
              const t = new d(f[e] + "." + bh[u.path], n.array, g, m);
              "CUBICSPLINE" === h.interpolation &&
                ((t.createInterpolant = function (e) {
                  return new (this instanceof xo ? lh : ah)(
                    this.times,
                    this.values,
                    this.getValueSize() / 3,
                    e
                  );
                }),
                (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                  !0)),
                l.push(t);
            }
          }
          const c = t.name ? t.name : "animation_" + e;
          return new wo(c, void 0, l);
        });
      }
      createNodeMesh(e) {
        const t = this.json,
          n = this,
          i = t.nodes[e];
        return void 0 === i.mesh
          ? null
          : n.getDependency("mesh", i.mesh).then(function (e) {
              const t = n._getNodeRef(n.meshCache, i.mesh, e);
              return (
                void 0 !== i.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (let t = 0, n = i.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = i.weights[t];
                  }),
                t
              );
            });
      }
      loadNode(e) {
        const t = this.json,
          n = this.extensions,
          i = this,
          r = t.nodes[e],
          s = r.name ? i.createUniqueName(r.name) : "";
        return (function () {
          const t = [],
            n = i._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            n && t.push(n),
            void 0 !== r.camera &&
              t.push(
                i.getDependency("camera", r.camera).then(function (e) {
                  return i._getNodeRef(i.cameraCache, r.camera, e);
                })
              ),
            i
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                t.push(e);
              }),
            Promise.all(t)
          );
        })().then(function (t) {
          let a;
          if (
            ((a =
              !0 === r.isBone
                ? new ws()
                : t.length > 1
                ? new kr()
                : 1 === t.length
                ? t[0]
                : new Ue()),
            a !== t[0])
          )
            for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
          if (
            (r.name && ((a.userData.name = r.name), (a.name = s)),
            Ah(a, r),
            r.extensions && Eh(n, a, r),
            void 0 !== r.matrix)
          ) {
            const e = new me();
            e.fromArray(r.matrix), a.applyMatrix4(e);
          } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
          return (
            i.associations.has(a) || i.associations.set(a, {}),
            (i.associations.get(a).nodes = e),
            a
          );
        });
      }
      loadScene(e) {
        const t = this.json,
          n = this.extensions,
          i = this.json.scenes[e],
          r = this,
          s = new kr();
        i.name && (s.name = r.createUniqueName(i.name)),
          Ah(s, i),
          i.extensions && Eh(n, s, i);
        const a = i.nodes || [],
          o = [];
        for (let e = 0, n = a.length; e < n; e++) o.push(Dh(a[e], s, t, r));
        return Promise.all(o).then(function () {
          return (
            (r.associations = ((e) => {
              const t = new Map();
              for (const [e, n] of r.associations)
                (e instanceof Qe || e instanceof P) && t.set(e, n);
              return (
                e.traverse((e) => {
                  const n = r.associations.get(e);
                  null != n && t.set(e, n);
                }),
                t
              );
            })(s)),
            s
          );
        });
      }
    }
    function Dh(e, t, n, i) {
      const r = n.nodes[e];
      return i
        .getDependency("node", e)
        .then(function (e) {
          if (void 0 === r.skin) return e;
          let t;
          return i
            .getDependency("skin", r.skin)
            .then(function (e) {
              t = e;
              const n = [];
              for (let e = 0, r = t.joints.length; e < r; e++)
                n.push(i.getDependency("node", t.joints[e]));
              return Promise.all(n);
            })
            .then(function (n) {
              return (
                e.traverse(function (e) {
                  if (!e.isMesh) return;
                  const i = [],
                    r = [];
                  for (let e = 0, s = n.length; e < s; e++) {
                    const s = n[e];
                    if (s) {
                      i.push(s);
                      const n = new me();
                      void 0 !== t.inverseBindMatrices &&
                        n.fromArray(t.inverseBindMatrices.array, 16 * e),
                        r.push(n);
                    } else
                      console.warn(
                        'THREE.GLTFLoader: Joint "%s" could not be found.',
                        t.joints[e]
                      );
                  }
                  e.bind(new Es(i, r), e.matrixWorld);
                }),
                e
              );
            });
        })
        .then(function (e) {
          t.add(e);
          const s = [];
          if (r.children) {
            const t = r.children;
            for (let r = 0, a = t.length; r < a; r++) {
              const a = t[r];
              s.push(Dh(a, e, n, i));
            }
          }
          return Promise.all(s);
        });
    }
    function Nh(e, t, n) {
      const i = t.attributes,
        r = [];
      function s(t, i) {
        return n.getDependency("accessor", t).then(function (t) {
          e.setAttribute(i, t);
        });
      }
      for (const t in i) {
        const n = yh[t] || t.toLowerCase();
        n in e.attributes || r.push(s(i[t], n));
      }
      if (void 0 !== t.indices && !e.index) {
        const i = n.getDependency("accessor", t.indices).then(function (t) {
          e.setIndex(t);
        });
        r.push(i);
      }
      return (
        Ah(e, t),
        (function (e, t, n) {
          const i = t.attributes,
            r = new H();
          if (void 0 === i.POSITION) return;
          {
            const e = n.json.accessors[i.POSITION],
              t = e.min,
              s = e.max;
            if (void 0 === t || void 0 === s)
              return void console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
            if (
              (r.set(new F(t[0], t[1], t[2]), new F(s[0], s[1], s[2])),
              e.normalized)
            ) {
              const t = Ph(gh[e.componentType]);
              r.min.multiplyScalar(t), r.max.multiplyScalar(t);
            }
          }
          const s = t.targets;
          if (void 0 !== s) {
            const e = new F(),
              t = new F();
            for (let i = 0, r = s.length; i < r; i++) {
              const r = s[i];
              if (void 0 !== r.POSITION) {
                const i = n.json.accessors[r.POSITION],
                  s = i.min,
                  a = i.max;
                if (void 0 !== s && void 0 !== a) {
                  if (
                    (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                    t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                    t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                    i.normalized)
                  ) {
                    const e = Ph(gh[i.componentType]);
                    t.multiplyScalar(e);
                  }
                  e.max(t);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            }
            r.expandByVector(e);
          }
          e.boundingBox = r;
          const a = new se();
          r.getCenter(a.center),
            (a.radius = r.min.distanceTo(r.max) / 2),
            (e.boundingSphere = a);
        })(e, t, n),
        Promise.all(r).then(function () {
          return void 0 !== t.targets
            ? (function (e, t, n) {
                let i = !1,
                  r = !1;
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e];
                  if (
                    (void 0 !== n.POSITION && (i = !0),
                    void 0 !== n.NORMAL && (r = !0),
                    i && r)
                  )
                    break;
                }
                if (!i && !r) return Promise.resolve(e);
                const s = [],
                  a = [];
                for (let o = 0, l = t.length; o < l; o++) {
                  const l = t[o];
                  if (i) {
                    const t =
                      void 0 !== l.POSITION
                        ? n.getDependency("accessor", l.POSITION)
                        : e.attributes.position;
                    s.push(t);
                  }
                  if (r) {
                    const t =
                      void 0 !== l.NORMAL
                        ? n.getDependency("accessor", l.NORMAL)
                        : e.attributes.normal;
                    a.push(t);
                  }
                }
                return Promise.all([Promise.all(s), Promise.all(a)]).then(
                  function (t) {
                    const n = t[0],
                      s = t[1];
                    return (
                      i && (e.morphAttributes.position = n),
                      r && (e.morphAttributes.normal = s),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  }
                );
              })(e, t.targets, n)
            : e;
        })
      );
    }
    function Oh(e, t) {
      let n = e.getIndex();
      if (null === n) {
        const t = [],
          i = e.getAttribute("position");
        if (void 0 === i)
          return (
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            e
          );
        for (let e = 0; e < i.count; e++) t.push(e);
        e.setIndex(t), (n = e.getIndex());
      }
      const i = n.count - 2,
        r = [];
      if (2 === t)
        for (let e = 1; e <= i; e++)
          r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
      else
        for (let e = 0; e < i; e++)
          e % 2 == 0
            ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2)))
            : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
      r.length / 3 !== i &&
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      const s = e.clone();
      return s.setIndex(r), s;
    }
    var zh,
      Fh,
      Bh,
      Uh,
      Hh,
      kh = n.p + "assets/src/objects/Flat.gltf",
      Gh = n.p + "assets/src/objects/Flat2.gltf",
      Vh = n.p + "assets/src/objects/HouseTexture1.png",
      Wh = n.p + "assets/src/objects/House.gltf",
      jh = 0,
      qh = [],
      Xh = !1;
    const Yh = {
      play: !0,
      tSpeed: 0.001,
      peopleCount: 100,
      infectedBlobs: 10,
      contactedWithBlobs: 10,
      infectionChance: 5,
      showPaths: !1,
      reload: function () {
        (this.play = !1),
          qh.forEach((e) => {
            e.sphere.parent.remove(e.sphere);
          }),
          (qh = null),
          (qh = []),
          (qh = []),
          $h(),
          (this.play = !0);
      },
      stopAnimation: function () {
        (this.play = !this.play), this.play && Jh();
      },
    };
    function Jh() {
      Yh.play &&
        (requestAnimationFrame(Jh),
        Uh.update(),
        (function () {
          qh.forEach((e) => {
            var t = e.points.getPoint(jh);
            e.sphere.position.set(t.x, t.y, t.z);
          }),
            jh - Yh.tSpeed <= 0 && Xh
              ? ((Xh = !1),
                1,
                (function () {
                  for (var e = Yh.infectedBlobs, t = 0; t < e; t++)
                    for (var n = 1; n < Yh.contactedWithBlobs; n++)
                      if (
                        (r = Yh.infectionChance) &&
                        100 * Math.random() <= r
                      ) {
                        var i = Qh(0, qh.length - 1);
                        0 == qh[i].isInfected &&
                          ((qh[i].sphere.material.color = new st(15672124)),
                          (qh[i].isInfected = !0),
                          (Yh.infectedBlobs += 1),
                          (document.querySelector(".counter").innerHTML =
                            Yh.infectedBlobs));
                      }
                  var r;
                })())
              : jh + Yh.tSpeed >= 1 && !Xh && (Xh = !0);
          (jh = Xh ? jh - Yh.tSpeed : jh + Yh.tSpeed), zh.render(Bh, Fh);
        })());
    }
    function Zh() {
      (Fh.aspect = window.innerWidth / window.innerHeight),
        Fh.updateProjectionMatrix(),
        zh.setSize(window.innerWidth, window.innerHeight);
    }
    function Kh(e, t, n, i, r) {
      var s = new me().makeTranslation(-650, 0, -650),
        a = new Fc(),
        o = new so({ color: 16777215 }),
        l = new Io().load(t),
        c = i ? -Math.PI / 2 : Math.PI / 2;
      a.load(
        e,
        function (e) {
          var t = e.scene.children[0];
          e.scene.traverse(function (e) {
            e.isMesh &&
              ((e.material = o),
              (e.material.map = l),
              (e.receiveShadow = !0),
              (e.castShadow = !0));
          }),
            (t.visible = !0),
            t.applyMatrix4(n),
            t.applyMatrix4(s),
            (t.position.y = 1),
            t.rotateY(c),
            t.scale.set(r, r, r),
            Bh.add(t);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      );
    }
    function Qh(e, t) {
      return Math.floor(Math.random() * (t - e)) + e;
    }
    function $h() {
      for (var e = 0; e < Yh.peopleCount; e++) {
        eu(nu(), nu());
      }
      qh.forEach((e) => {
        Yh.showPaths && Bh.add(e.line), Bh.add(e.sphere);
      });
      for (e = 0; e < Yh.infectedBlobs; e++)
        (qh[e].sphere.material.color = new st(15672124)),
          (qh[e].isInfected = !0);
    }
    function eu(e, t) {
      var n = new me().makeTranslation(-650, 0, -650),
        i = new _a(),
        r = e[0] % 5 == 0 ? 5 : e[0] % 5,
        s = e[0] % 5 == 0 ? e[0] / 5 : Math.floor(e[0] / 5) + 1,
        a = t[0] % 5 == 0 ? 5 : t[0] % 5,
        o = t[0] % 5 == 0 ? t[0] / 5 : Math.floor(t[0] / 5) + 1,
        l = new F(25 + 250 * (r - 1), 5, 25 + 250 * (s - 1));
      l.setX(iu(e[1]) ? l.x : l.x + 250),
        l.setZ(ru(e[1]) ? l.z + 80 : l.z + 170);
      var c = new F(25 + 250 * (r - 1), 5, l.z);
      c.setX(iu(e[1]) ? l.x + 80 : l.x - 80);
      var h = new F(l.x, 5, 25 + 250 * s),
        u = new F(25 + 250 * (a - 1), 5, 25 + 250 * (o - 1));
      u.setX(iu(t[1]) ? u.x : u.x + 250),
        u.setZ(ru(t[1]) ? u.z + 80 : u.z + 170);
      var d = new F(25 + 250 * (a - 1), 5, u.z);
      d.setX(iu(t[1]) ? u.x + 80 : u.x - 80);
      var p = new F(u.x, 5, 25 + 250 * o),
        m = new F(25 + 250 * (Qh(r, a) - 1), 5, h.z),
        f = new F(m.x, 5, p.z);
      c.applyMatrix4(n),
        d.applyMatrix4(n),
        l.applyMatrix4(n),
        h.applyMatrix4(n),
        u.applyMatrix4(n),
        p.applyMatrix4(n),
        m.applyMatrix4(n),
        f.applyMatrix4(n),
        i.add(new pa(c, l)),
        i.add(new pa(l, h)),
        i.add(new pa(h, m)),
        i.add(new pa(m, f)),
        i.add(new pa(f, p)),
        i.add(new pa(p, u)),
        i.add(new pa(u, d));
      var g = i.curves.reduce((e, t) => [...e, ...t.getPoints(20)], []),
        v = new yt().setFromPoints(g),
        _ = new Ds({ color: 16773807 }),
        x = new Us(v, _);
      (x.castShadow = !0),
        qh.push({ line: x, points: i, sphere: tu(), isInfected: !1 });
    }
    function tu() {
      var e = new Qa(6, 20, 20),
        t = new at({ color: 896610, transparent: !0, opacity: 0.9 }),
        n = new Bt(e, t);
      return (n.name = "blob"), (n.castShadow = !0), (n.receiveShadow = !0), n;
    }
    function nu() {
      return [
        Math.floor(Math.random() * Math.floor(25)) + 1,
        Math.floor(Math.random() * Math.floor(4)) + 1,
      ];
    }
    function iu(e) {
      return e % 2 == 1;
    }
    function ru(e) {
      return e <= 2;
    }
    !(function () {
      (document.querySelector(".counter").innerHTML = Yh.infectedBlobs),
        (zh = new Xr({ antialias: !0 })).setClearColor(new st(16777215)),
        zh.setSize(window.innerWidth, window.innerHeight),
        (zh.shadowMap.enabled = !0),
        (zh.shadowMap.type = 2),
        document.body.appendChild(zh.domElement),
        (Bh = new Zr()),
        ((Fh = new qt(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1e4
        )).position.y = 1300),
        (Fh.position.z = 0),
        (Fh.position.x = -600),
        Bh.add(Fh),
        ((Uh = new Rl(Fh, zh.domElement)).enableDamping = !0),
        (Uh.dampingFactor = 0.09),
        (Uh.screenSpacePanning = !1),
        (Uh.maxPolarAngle = 0.45 * Math.PI),
        (Uh.minPolarAngle = 0 * Math.PI),
        (Uh.minDistance = 200),
        (Uh.maxDistance = 2e3),
        (Uh.smoothZoom = !0),
        (Uh.zoomSpeed = 2);
      var e = new Ht(1e4, 1e4, 1e4),
        t = new at({ color: 16777215, side: 1 }),
        n = new Bt(e, t);
      Bh.add(n), (Bh.fog = new Jr(t.color, 300, 4e3));
      var i = new an(1300, 1300),
        r = new eo({
          color: 3158064,
          polygonOffset: !0,
          polygonOffsetFactor: 5,
          side: 2,
        });
      ((Hh = new Bt(i, r)).receiveShadow = !0),
        (Hh.rotation.x = -Math.PI / 2),
        Bh.add(Hh);
      var s = new an(1e4, 1e4),
        a = new no({ color: 15987699, side: 2 }),
        o = new Bt(s, a);
      (o.rotation.x = -Math.PI / 2), (o.position.y = -15), Bh.add(o);
      var l = new Yo(7895160, 0.9);
      Bh.add(l);
      var c = new Xo(16777215, 1);
      c.position.set(-500, 1e3, -300),
        (c.shadow.camera.near = 2),
        (c.shadow.camera.far = 2e3),
        (c.shadow.camera.left = -2e3),
        (c.shadow.camera.right = 2e3),
        (c.shadow.camera.top = 2e3),
        (c.shadow.camera.bottom = -2e3),
        (c.castShadow = !0),
        (c.shadow.mapSize.height = 3096),
        (c.shadow.mapSize.width = 3096),
        Bh.add(c),
        Bh.add(
          (function (e, t) {
            for (
              var n = Math.floor(e / 250), i = Math.floor(t / 250), r = 0;
              r < i;
              r++
            )
              for (var s = 0; s < n; s++) {
                var a = 250 * s + 50 + 55,
                  o = 250 * r + 50 + 55,
                  l = new an(200, 200),
                  c = new no({ color: 14737632, side: 2, shininess: 10 }),
                  h = new Bt(l, c);
                (h.receiveShadow = !0),
                  (h.rotation.x = -Math.PI / 2),
                  (h.position.y = 1),
                  h.applyMatrix4(
                    new me().makeTranslation(a + 45 - e / 2, 0, o + 45 - t / 2)
                  ),
                  Bh.add(h);
                for (var u = 1; u <= 4; u++) {
                  var d = iu(u) ? 0 : 90,
                    p = ru(u) ? 0 : 90,
                    m = new me().makeTranslation(a + d, 0, o + p),
                    f = ((v = 100), (g = 0) + Math.random() * (v - g));
                  f <= 33
                    ? Kh(kh, Vh, m, iu(u), 30)
                    : f > 33 && f <= 60
                    ? Kh(Gh, Vh, m, iu(u), 30)
                    : Kh(Wh, Vh, m, iu(u), 60);
                }
              }
            var g, v;
          })(1300, 1300)
        ),
        window.addEventListener("resize", Zh, !1);
    })(),
      $h(),
      (function () {
        var e = new zc({ width: 500 }),
          t = e.addFolder("Population");
        t.add(Yh, "peopleCount", 50, 500, 2).name("Population (Reload)"),
          t.add(Yh, "tSpeed", 5e-4, 0.01, 95e-6).name("Blob Speed"),
          t.open();
        var n = e.addFolder("Disease Spread");
        n.add(Yh, "infectedBlobs", 1, 50, 1).name("Infected Blobs"),
          n.add(Yh, "infectionChance", 1, 50, 1).name("Infection Chance (%)"),
          n
            .add(Yh, "contactedWithBlobs", 1, 50, 1)
            .name("Physical contacts per blob");
        var i = e.addFolder("Controls");
        i.add(Yh, "showPaths").name("Show paths (Reload)"),
          i.add(Yh, "stopAnimation").name("Play/Stop Simulation"),
          i.add(Yh, "reload").name("Reload"),
          i.open();
      })(),
      Jh();
  },
]);
//# sourceMappingURL=main.js.map
